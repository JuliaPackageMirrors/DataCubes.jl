{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to MultidimensionalTables.jl\n\n\nMultidimensionalTables provides a framework to handle multidimensional tables.",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-multidimensionaltablesjl",
            "text": "MultidimensionalTables provides a framework to handle multidimensional tables.",
            "title": "Welcome to MultidimensionalTables.jl"
        },
        {
            "location": "/introduction/",
            "text": "Introduction to the MultidimensionalTables package\n\n\nThe MultidimensionalTables package provides several new data types and associated functions/macros, to deal with multidimensional tables. The package has the following notable features:\n\n\n\n\nIt includes data types \nDictArray\n and \nLabeledArray\n that can describe multimensional tables.\n\n\nExtensive number of functions/macros are available to process common type of table manipulations and they can cover multidimensional tables as well.\n\n\nEach element in any field of a multidimensional table is \nNullable\n. So there is no type instability when you access an element: a non \nNA\n(i.e. null) value will be represented by \nNullable(value)\n and a \nNA\n value by \nNullable{T}()\n for some \nT\n.\n\n\n\n\nDictArray\n\n\nConceptually, \nDictArray\n is an array of ordered dictionaries with identical keys. For example, a table with two columns \ncol1=[10, 11]\n and \ncol2=[:sym1, :sym2]\n can be considered as a one-dimensional array of length 2, whose elements are \n[LDict(:col1=>10, :col2=>:sym1), LDict(:col1=>11, :col2=>:sym2)]\n where \nLDict\n represents a kind of ordered dictionary, which will be described in detail later. This is a conceptual level description, and the methods in the packages utilizes as much as possible the fact that each ordered dictionary is from a set of arrays. One advantage of describing a table in terms of a one-dimensional array of ordered dictionaries is that it is straightforward to generalize this to multidimensional arrays. For example, \n@darr\n is a macro in the package to create a \nDictArray\n like this:\n\n\njulia> using MultidimensionalTables\n\njulia> d = @darr(A=[1 2 3;4 5 6], B=['a' 'b' 'a';'a' 'a' 'b'])\n2 x 3 DictArray\n\nA B |A B |A B \n----+----+----\n1 a |2 b |3 a \n4 a |5 a |6 b \n\n\n\n\nHere, the \nDictArray\n \nd\n has two fields \nA\n and \nB\n and each is a two-dimensional array. A component of \nd\n is an ordered dictionary:\n\n\njulia> d[1, 2]\nMultidimensionalTables.LDict{Symbol,Nullable{T}} with 2 entries:\n  :A => Nullable(2)\n  :B => Nullable('b')\n\n\n\n\nNote that each value is \nNullable\n: It is typical for a value to be \nNA\n during an array transformation, and it makes more sense to make any values in the elements of a \nDictArray\n to be \nNullable\n.\nNote also that we use the term \nfields\n and not \ncolumn\n to denote the two dimensional arrays represented by \nA\n and \nB\n above. The reason is, in multidimensional situations, they are not \ncolumns\n anymore.\n\n\nLabeledArray\n\n\nA \nLabeledArray\n is a \nDictArray\n or usual array with labels attached to each axis. The labels for each axis is an array: It can be a normal array, or a \nDictArray\n. For example, \n@larr\n is a macro in the package to create a \nLabeledArray\n:\n\n\njulia> using MultidimensionalTables\n\njulia> l = @larr(A=[1 2 3;4 5 6],\n                       B=['a' 'b' 'a';'a' 'a' 'b'],\n                       axis1[a1=[:row1, :row2]],\n                       axis2[a2=[\"X\", \"Y\", \"Z\"]])\n2 x 3 LabeledArray\n\na2   |X   |Y   |Z   \n-----+----+----+----\na1   |A B |A B |A B \n-----+----+----+----\nrow1 |1 a |2 b |3 a \nrow2 |4 a |5 a |6 b \n\n\n\n\nThe \nLabeledArray\n along with \nDictArray\n are the main data types that represent multidimensional tables.\n\n\n@select\n\n\nThe macro \n@select\n transforms a \nLabeledArray\n into another \nLabeledArray\n. This macro is similar to the \nselect\n statement in SQL. As an example:\n\n\njulia> using MultidimensionalTables\n\njulia> l = @larr(A=[1 2 3;4 5 6],\n                 B=['a' 'b' 'a';'a' 'a' 'b'],\n                 axis1[axis1=[:row1, :row2]],\n                 axis2[axis2=[\"col1\", \"col2\", \"col3\"]])\n2 x 3 LabeledArray\n\naxis2 |col1   |col2   |col3   \n------+-------+-------+-------\naxis1 |A    B |A    B |A    B \n------+-------+-------+-------\nrow1  |1    a |2    b |3    a \nrow2  |4    a |5    a |6    b \n\n\njulia> @select(l, S=sum(_A), by[:B], where[_A .< 5])\n2 LabeledArray\n\nB |S \n--+--\na |8 \nb |2 \n\n\n\n\nThis \n@select\n macro chooses all elements in the \nLabeledArray\n \nl\n where the \nA\n field is less than 5, and sum the \nA\n field values after grouping by the \nB\n field value.",
            "title": "Introduction"
        },
        {
            "location": "/introduction/#introduction-to-the-multidimensionaltables-package",
            "text": "The MultidimensionalTables package provides several new data types and associated functions/macros, to deal with multidimensional tables. The package has the following notable features:   It includes data types  DictArray  and  LabeledArray  that can describe multimensional tables.  Extensive number of functions/macros are available to process common type of table manipulations and they can cover multidimensional tables as well.  Each element in any field of a multidimensional table is  Nullable . So there is no type instability when you access an element: a non  NA (i.e. null) value will be represented by  Nullable(value)  and a  NA  value by  Nullable{T}()  for some  T .   DictArray  Conceptually,  DictArray  is an array of ordered dictionaries with identical keys. For example, a table with two columns  col1=[10, 11]  and  col2=[:sym1, :sym2]  can be considered as a one-dimensional array of length 2, whose elements are  [LDict(:col1=>10, :col2=>:sym1), LDict(:col1=>11, :col2=>:sym2)]  where  LDict  represents a kind of ordered dictionary, which will be described in detail later. This is a conceptual level description, and the methods in the packages utilizes as much as possible the fact that each ordered dictionary is from a set of arrays. One advantage of describing a table in terms of a one-dimensional array of ordered dictionaries is that it is straightforward to generalize this to multidimensional arrays. For example,  @darr  is a macro in the package to create a  DictArray  like this:  julia> using MultidimensionalTables\n\njulia> d = @darr(A=[1 2 3;4 5 6], B=['a' 'b' 'a';'a' 'a' 'b'])\n2 x 3 DictArray\n\nA B |A B |A B \n----+----+----\n1 a |2 b |3 a \n4 a |5 a |6 b   Here, the  DictArray   d  has two fields  A  and  B  and each is a two-dimensional array. A component of  d  is an ordered dictionary:  julia> d[1, 2]\nMultidimensionalTables.LDict{Symbol,Nullable{T}} with 2 entries:\n  :A => Nullable(2)\n  :B => Nullable('b')  Note that each value is  Nullable : It is typical for a value to be  NA  during an array transformation, and it makes more sense to make any values in the elements of a  DictArray  to be  Nullable .\nNote also that we use the term  fields  and not  column  to denote the two dimensional arrays represented by  A  and  B  above. The reason is, in multidimensional situations, they are not  columns  anymore.  LabeledArray  A  LabeledArray  is a  DictArray  or usual array with labels attached to each axis. The labels for each axis is an array: It can be a normal array, or a  DictArray . For example,  @larr  is a macro in the package to create a  LabeledArray :  julia> using MultidimensionalTables\n\njulia> l = @larr(A=[1 2 3;4 5 6],\n                       B=['a' 'b' 'a';'a' 'a' 'b'],\n                       axis1[a1=[:row1, :row2]],\n                       axis2[a2=[\"X\", \"Y\", \"Z\"]])\n2 x 3 LabeledArray\n\na2   |X   |Y   |Z   \n-----+----+----+----\na1   |A B |A B |A B \n-----+----+----+----\nrow1 |1 a |2 b |3 a \nrow2 |4 a |5 a |6 b   The  LabeledArray  along with  DictArray  are the main data types that represent multidimensional tables.  @select  The macro  @select  transforms a  LabeledArray  into another  LabeledArray . This macro is similar to the  select  statement in SQL. As an example:  julia> using MultidimensionalTables\n\njulia> l = @larr(A=[1 2 3;4 5 6],\n                 B=['a' 'b' 'a';'a' 'a' 'b'],\n                 axis1[axis1=[:row1, :row2]],\n                 axis2[axis2=[\"col1\", \"col2\", \"col3\"]])\n2 x 3 LabeledArray\n\naxis2 |col1   |col2   |col3   \n------+-------+-------+-------\naxis1 |A    B |A    B |A    B \n------+-------+-------+-------\nrow1  |1    a |2    b |3    a \nrow2  |4    a |5    a |6    b \n\n\njulia> @select(l, S=sum(_A), by[:B], where[_A .< 5])\n2 LabeledArray\n\nB |S \n--+--\na |8 \nb |2   This  @select  macro chooses all elements in the  LabeledArray   l  where the  A  field is less than 5, and sum the  A  field values after grouping by the  B  field value.",
            "title": "Introduction to the MultidimensionalTables package"
        },
        {
            "location": "/getting_started/",
            "text": "Getting Started\n\n\nInstallation\n\n\nTo install \nMultidimensionalTables\n, at the Julia REPL:\n\n\nPkg.add(\"MultidimensionalTables\")\n\n\n\n\nUsing the MultidimensionalTables package\n\n\nTo use \nMultidimensionalTables\n,\n\n\nusing MultidimensionalTables\n\n\n\n\nThis will introduce the core functions into namespace.\nA few helper functions have the form \ntbltool.*\n and they can be introduced into namespace as well by:\n\n\nusing MultidimensionalTables.Tools\n\n\n\n\nBelow, we assume you already executed \nusing MultidimensionalTables\n.\n\n\nCreating a multidimensional table\n\n\nDictArray\n\n\nA multidimensional table can be represented by either the \nDictArray\n or \nLabeledArray\n data type.\nA \nDictArray\n is an array of ordered dictionaries with the common keys, and represents a table with no speicial axis information.\nA \nLabeledArray\n is a \nDictArray\n with an additional vector for each axis for their labels.\nThe macro \n@darr\n is used to create a \nDictArray\n:\n\n\njulia> d = @darr(c1=[1,1,2], c2=[\"x\", \"y\", \"z\"])\n\n3 DictArray\n\nc1 c2 \n------\n1  x  \n1  y  \n2  z  \n\n\n\n\nNote that this is a \none\n-dimensional array. There are 3 elements in the array:\n\n\njulia> for elem in d\n         println(elem)\n       end\nMultidimensionalTables.LDict{Symbol,Nullable{T}}(:c1=>Nullable(1),:c2=>Nullable(\"x\"))\nMultidimensionalTables.LDict{Symbol,Nullable{T}}(:c1=>Nullable(1),:c2=>Nullable(\"y\"))\nMultidimensionalTables.LDict{Symbol,Nullable{T}}(:c1=>Nullable(2),:c2=>Nullable(\"z\"))\n\n\n\n\nLDict\n is an ordered dictionary. That is, it is similar to \nDict\n but keeps track of the order of the insertion of elements. Each element has two keys \n:c1\n and \n:c2\n. Their values are all \nNullable\n: the macro \n@darr\n wraps values appropriately by \nNullable\n if they are not wrapped already.\nTo choose an element, e.g. \ny\n in the \nDictArray\n \nd\n, you can use \nd[2][:c2]\n.\nTo choose one field, a function \npick\n is provided:\n\n\njulia> pick(d, :c1)\n3-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(1)\n Nullable(1)\n Nullable(2)\n\n\n\n\npick\n has many types of methods, and the meaning is different depending on the situation.\nFor example, to get a \nDictArray\n with only \nc1\n field, use \npick(d, [:c1])\n.\nAn array access expression such as \nd[2,:c2]\n cannot be provided because the field name (\n:c2\n) can be actually any type. For example:\n\n\njulia> d1 = @darr(:one=>[1,2,3], 2=>[:x,:y,:z], \"three\"=>['u','v','w'])\n3 DictArray\n\none 2 three \n------------\n1   x u     \n2   y v     \n3   z w     \n\n\n\n\nLabeledArray\n\n\nA \nLabeledArray\n adds axes information to a \nDictArray\n.\nA convenient way to create a \nLabeledArray\n by hand is using the macro \n@larr\n.\nFor example,\n\n\njulia> t = @larr(c1=[1 ,1 ,2], c2=[\"x\", \"y\", \"z\"], axis1[k1=[10,11,12], k2=[:r1, :r2, :r3]])\n3 LabeledArray\n\nk1 k2 |c1 c2 \n------+------\n10 r1 |1  x  \n11 r2 |1  y  \n12 r3 |2  z  \n\n\n\n\nNote the appearance of labels in the first column whose field names are \nk1\n and \nk2\n.\nYou can also construct a \nLabeledArray\n from a \nDictArray\n and axes labels:\n\n\njulia> d = @darr(c1=[1 ,1 ,2], c2=[\"x\", \"y\", \"z\"])\n3 DictArray\n\nc1 c2 \n------\n1  x  \n1  y  \n2  z  \n\n\njulia> t = @larr(d, axis1[k=[:r1, :r2, :r3]])\n3 LabeledArray\n\nk  |c1 c2 \n---+------\nr1 |1  x  \nr2 |1  y  \nr3 |2  z  \n\n\n\n\npeel(t)\n will return the underlying \nDictArray\n, stripping off all axes information.\n\npick(t, :c1)\n will return the field value array of \nc1\n.\n\n\nMultidimensional Tables\n\n\nBoth \nDictArray\n and \nLabeledArray\n can be multidimensional.\nFor example,\n\n\njulia> m = @larr(c1=[1 2;3 4;5 6],\n                 c2=['a' 'b';'b' 'a';'a' 'a'],\n                 axis1[k1=[\"x\",\"y\",\"z\"]],\n                 axis2[r1=[:A,:B]])\n3 x 2 LabeledArray\n\nr1 |A     |B     \n---+------+------\nk1 |c1 c2 |c1 c2 \n---+------+------\nx  |1  a  |2  b  \ny  |3  b  |4  a  \nz  |5  a  |6  a  \n\n\n\n\nYou can choose elements in the array using usual array indexing expressions:\n\n\njulia> m[2:3,2]\n2 LabeledArray\n\nk1 |c1 c2 \n---+------\ny  |4  a  \nz  |6  a  \n\n\n\n\nMany operations for multidimensional arrays are also applicable:\n\n\njulia> transpose(m)\n2 x 3 LabeledArray\n\nk1 |x     |y     |z     \n---+------+------+------\nr1 |c1 c2 |c1 c2 |c1 c2 \n---+------+------+------\nA  |1  a  |3  b  |5  a  \nB  |2  b  |4  a  |6  a  \n\n\njulia> sub(m, 1:2, 1:2)\n2 x 2 LabeledArray\n\nr1 |A     |B     \n---+------+------\nk1 |c1 c2 |c1 c2 \n---+------+------\nx  |1  a  |2  b  \ny  |3  b  |4  a  \n\n\n\n\nSome operations take slightly differnt set of arguments. For example, to sort a \nLabeledArray\n \nm\n along the first axis using the field \nc2\n:\n\n\njulia> sort(m, 1, :c2)\n3 x 2 LabeledArray\n\nr1 |A     |B     \n---+------+------\nk1 |c1 c2 |c1 c2 \n---+------+------\nx  |1  a  |2  b  \nz  |5  a  |6  a  \ny  |3  b  |4  a  \n\n\n\n\nManipulating LabeledArray\n\n\nThe macro \n@select\n uses a SQL-like syntax to transform one \nLabeledArray\n into another (or into a dictionary).\nLet's use this \nLabeledArray\n \nm\n as an example:\n\n\njulia> m = @larr(c1=[1 2;3 4;5 6],\n                 c2=['a' 'b';'b' 'a';'a' 'a'],\n                 c3=[10.0 NA;NA 12.0;20.0 20.0],\n                 axis1[k1=[\"x\",\"y\",\"z\"]],\n                 axis2[r1=[:A,:B]])\n3 x 2 LabeledArray\n\nr1 |A          |B          \n---+-----------+-----------\nk1 |c1 c2 c3   |c1 c2 c3   \n---+-----------+-----------\nx  |1  a  10.0 |2  b       \ny  |3  b       |4  a  12.0 \nz  |5  a  20.0 |6  a  20.0 \n\n\n\n\nTo select only the fields \nc1\n and \nc2\n,\n\n\njulia> @select(m, :c1, :c2)\n3 x 2 LabeledArray\n\nr1 |A     |B     \n---+------+------\nk1 |c1 c2 |c1 c2 \n---+------+------\nx  |1  a  |2  b  \ny  |3  b  |4  a  \nz  |5  a  |6  a  \n\n\n\n\nAn example to create a new column from the existing one:\n\n\njulia> @select(m, c=_c1 .* 2 .+ _c3)\n3 x 2 LabeledArray\n\nr1 |A    |B    \n---+-----+-----\nk1 |c    |c    \n---+-----+-----\nx  |12.0 |     \ny  |     |20.0 \nz  |30.0 |32.0 \n\n\n\n\n_c1\n refers to the \nc1\n field and \n.*\n does the component-wise multiplication.\n\n\nTo choose only relevant elements, use the \nwhere[...]\n expression,\n\n\njulia> @select(m, :c1, :c2, where[_c2 .== 'b'])\n2 x 2 LabeledArray\n\nr1 |A     |B     \n---+------+------\nk1 |c1 c2 |c1 c2 \n---+------+------\nx  |      |2  b  \ny  |3  b  |      \n\n\n\n\nwhere[...]\n can have many conditions inside \n...\n, and they will be applied sequentially.\nMultiple \nwhere[...]\n are also possible, and they will be simply concatenated.\n\n\nTo group the array elements by some fields, use the \nby[...]\n expression,\n\n\njulia> @select(m,c1=sum(_c1), c3=sum(_c3), by[:c2])\n2 LabeledArray\n\nc2 |c1 c3   \n---+--------\na  |16 62.0 \nb  |5  0.0  \n\n\n\n\nYou can provide multiple fields to group by:\n\n\njulia> @select(m,c1=sum(_c1), c3=mean(_c3), by[:c2,c4=_c1 .> 5])\n3 LabeledArray\n\nc2 c4    |c1 c3   \n---------+--------\na  false |10 14.0 \na  true  |6  20.0 \nb  false |5       \n\n\n\n\nBut it is also possible to group by the array in a multidimensional way:\n\n\njulia> @select(m,c1=sum(_c1), c3=mean(_c3), by[:c2], by[c4=_c1 .> 5])\n2 x 2 LabeledArray\n\nc4 |false      |true      \n---+-----------+----------\nc2 |c1    c3   |c1   c3   \n---+-----------+----------\na  |10    14.0 |6    20.0 \nb  |5          |",
            "title": "Getting Started"
        },
        {
            "location": "/getting_started/#getting-started",
            "text": "Installation  To install  MultidimensionalTables , at the Julia REPL:  Pkg.add(\"MultidimensionalTables\")  Using the MultidimensionalTables package  To use  MultidimensionalTables ,  using MultidimensionalTables  This will introduce the core functions into namespace.\nA few helper functions have the form  tbltool.*  and they can be introduced into namespace as well by:  using MultidimensionalTables.Tools  Below, we assume you already executed  using MultidimensionalTables .  Creating a multidimensional table  DictArray  A multidimensional table can be represented by either the  DictArray  or  LabeledArray  data type.\nA  DictArray  is an array of ordered dictionaries with the common keys, and represents a table with no speicial axis information.\nA  LabeledArray  is a  DictArray  with an additional vector for each axis for their labels.\nThe macro  @darr  is used to create a  DictArray :  julia> d = @darr(c1=[1,1,2], c2=[\"x\", \"y\", \"z\"])\n\n3 DictArray\n\nc1 c2 \n------\n1  x  \n1  y  \n2  z    Note that this is a  one -dimensional array. There are 3 elements in the array:  julia> for elem in d\n         println(elem)\n       end\nMultidimensionalTables.LDict{Symbol,Nullable{T}}(:c1=>Nullable(1),:c2=>Nullable(\"x\"))\nMultidimensionalTables.LDict{Symbol,Nullable{T}}(:c1=>Nullable(1),:c2=>Nullable(\"y\"))\nMultidimensionalTables.LDict{Symbol,Nullable{T}}(:c1=>Nullable(2),:c2=>Nullable(\"z\"))  LDict  is an ordered dictionary. That is, it is similar to  Dict  but keeps track of the order of the insertion of elements. Each element has two keys  :c1  and  :c2 . Their values are all  Nullable : the macro  @darr  wraps values appropriately by  Nullable  if they are not wrapped already.\nTo choose an element, e.g.  y  in the  DictArray   d , you can use  d[2][:c2] .\nTo choose one field, a function  pick  is provided:  julia> pick(d, :c1)\n3-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(1)\n Nullable(1)\n Nullable(2)  pick  has many types of methods, and the meaning is different depending on the situation.\nFor example, to get a  DictArray  with only  c1  field, use  pick(d, [:c1]) .\nAn array access expression such as  d[2,:c2]  cannot be provided because the field name ( :c2 ) can be actually any type. For example:  julia> d1 = @darr(:one=>[1,2,3], 2=>[:x,:y,:z], \"three\"=>['u','v','w'])\n3 DictArray\n\none 2 three \n------------\n1   x u     \n2   y v     \n3   z w       LabeledArray  A  LabeledArray  adds axes information to a  DictArray .\nA convenient way to create a  LabeledArray  by hand is using the macro  @larr .\nFor example,  julia> t = @larr(c1=[1 ,1 ,2], c2=[\"x\", \"y\", \"z\"], axis1[k1=[10,11,12], k2=[:r1, :r2, :r3]])\n3 LabeledArray\n\nk1 k2 |c1 c2 \n------+------\n10 r1 |1  x  \n11 r2 |1  y  \n12 r3 |2  z    Note the appearance of labels in the first column whose field names are  k1  and  k2 .\nYou can also construct a  LabeledArray  from a  DictArray  and axes labels:  julia> d = @darr(c1=[1 ,1 ,2], c2=[\"x\", \"y\", \"z\"])\n3 DictArray\n\nc1 c2 \n------\n1  x  \n1  y  \n2  z  \n\n\njulia> t = @larr(d, axis1[k=[:r1, :r2, :r3]])\n3 LabeledArray\n\nk  |c1 c2 \n---+------\nr1 |1  x  \nr2 |1  y  \nr3 |2  z    peel(t)  will return the underlying  DictArray , stripping off all axes information. pick(t, :c1)  will return the field value array of  c1 .  Multidimensional Tables  Both  DictArray  and  LabeledArray  can be multidimensional.\nFor example,  julia> m = @larr(c1=[1 2;3 4;5 6],\n                 c2=['a' 'b';'b' 'a';'a' 'a'],\n                 axis1[k1=[\"x\",\"y\",\"z\"]],\n                 axis2[r1=[:A,:B]])\n3 x 2 LabeledArray\n\nr1 |A     |B     \n---+------+------\nk1 |c1 c2 |c1 c2 \n---+------+------\nx  |1  a  |2  b  \ny  |3  b  |4  a  \nz  |5  a  |6  a    You can choose elements in the array using usual array indexing expressions:  julia> m[2:3,2]\n2 LabeledArray\n\nk1 |c1 c2 \n---+------\ny  |4  a  \nz  |6  a    Many operations for multidimensional arrays are also applicable:  julia> transpose(m)\n2 x 3 LabeledArray\n\nk1 |x     |y     |z     \n---+------+------+------\nr1 |c1 c2 |c1 c2 |c1 c2 \n---+------+------+------\nA  |1  a  |3  b  |5  a  \nB  |2  b  |4  a  |6  a  \n\n\njulia> sub(m, 1:2, 1:2)\n2 x 2 LabeledArray\n\nr1 |A     |B     \n---+------+------\nk1 |c1 c2 |c1 c2 \n---+------+------\nx  |1  a  |2  b  \ny  |3  b  |4  a    Some operations take slightly differnt set of arguments. For example, to sort a  LabeledArray   m  along the first axis using the field  c2 :  julia> sort(m, 1, :c2)\n3 x 2 LabeledArray\n\nr1 |A     |B     \n---+------+------\nk1 |c1 c2 |c1 c2 \n---+------+------\nx  |1  a  |2  b  \nz  |5  a  |6  a  \ny  |3  b  |4  a    Manipulating LabeledArray  The macro  @select  uses a SQL-like syntax to transform one  LabeledArray  into another (or into a dictionary).\nLet's use this  LabeledArray   m  as an example:  julia> m = @larr(c1=[1 2;3 4;5 6],\n                 c2=['a' 'b';'b' 'a';'a' 'a'],\n                 c3=[10.0 NA;NA 12.0;20.0 20.0],\n                 axis1[k1=[\"x\",\"y\",\"z\"]],\n                 axis2[r1=[:A,:B]])\n3 x 2 LabeledArray\n\nr1 |A          |B          \n---+-----------+-----------\nk1 |c1 c2 c3   |c1 c2 c3   \n---+-----------+-----------\nx  |1  a  10.0 |2  b       \ny  |3  b       |4  a  12.0 \nz  |5  a  20.0 |6  a  20.0   To select only the fields  c1  and  c2 ,  julia> @select(m, :c1, :c2)\n3 x 2 LabeledArray\n\nr1 |A     |B     \n---+------+------\nk1 |c1 c2 |c1 c2 \n---+------+------\nx  |1  a  |2  b  \ny  |3  b  |4  a  \nz  |5  a  |6  a    An example to create a new column from the existing one:  julia> @select(m, c=_c1 .* 2 .+ _c3)\n3 x 2 LabeledArray\n\nr1 |A    |B    \n---+-----+-----\nk1 |c    |c    \n---+-----+-----\nx  |12.0 |     \ny  |     |20.0 \nz  |30.0 |32.0   _c1  refers to the  c1  field and  .*  does the component-wise multiplication.  To choose only relevant elements, use the  where[...]  expression,  julia> @select(m, :c1, :c2, where[_c2 .== 'b'])\n2 x 2 LabeledArray\n\nr1 |A     |B     \n---+------+------\nk1 |c1 c2 |c1 c2 \n---+------+------\nx  |      |2  b  \ny  |3  b  |        where[...]  can have many conditions inside  ... , and they will be applied sequentially.\nMultiple  where[...]  are also possible, and they will be simply concatenated.  To group the array elements by some fields, use the  by[...]  expression,  julia> @select(m,c1=sum(_c1), c3=sum(_c3), by[:c2])\n2 LabeledArray\n\nc2 |c1 c3   \n---+--------\na  |16 62.0 \nb  |5  0.0    You can provide multiple fields to group by:  julia> @select(m,c1=sum(_c1), c3=mean(_c3), by[:c2,c4=_c1 .> 5])\n3 LabeledArray\n\nc2 c4    |c1 c3   \n---------+--------\na  false |10 14.0 \na  true  |6  20.0 \nb  false |5         But it is also possible to group by the array in a multidimensional way:  julia> @select(m,c1=sum(_c1), c3=mean(_c3), by[:c2], by[c4=_c1 .> 5])\n2 x 2 LabeledArray\n\nc4 |false      |true      \n---+-----------+----------\nc2 |c1    c3   |c1   c3   \n---+-----------+----------\na  |10    14.0 |6    20.0 \nb  |5          |",
            "title": "Getting Started"
        },
        {
            "location": "/where_to_look/",
            "text": "Where To Look\n\n\nCreate an array\n\n\n\n\nCreate a nullable array\n\n\nwith \nNA\n (i.e. null) elements in it, mostly for manual typing: \n@nalift\n.\n\n\nwithout \nNA\n, typically just to lift non \nNullable\n arrays: \nnalift\n.\n\n\n\n\n\n\nCreate a multidimensional table: \ndarr\n, \n@darr\n  to create a \nDictArray\n. The latter if you want to convert \nNA\n into appropriate null elements when manually typing.\n\n\nCreate an array with labels: \nlarr\n, \n@larr\n to create a \nLabeledArray\n. The latter if you want to convert \nNA\n into appropriate null elements when manually typing.\n\n\nCreate a nullable array where there are many duplications, i.e. create a pooled/enumeration array: \nenumeration\n, \n@enumeration\n\n\n\n\nChoose/Remove elements in an array\n\n\n\n\nChoose elements using index (normal way): index notation(\ngetindex\n).\n\n\nChoose/Remove based on labels in \nLabeledArray\n: \nextract\n, \ndiscard\n.\n\n\nChoose the underlying \nbase\n of \nLabeledArray\n: \npeel\n\n\nChoose the underlying ordered dictionary(\nLDict\n) of \nDictArray\n: \npeel\n\n\nChoose field name(s) from \nDictArray\n or \nLabeledArray\n: \npick\n\n\nChoose the axis or axes of \nLabeledArray\n: \npickaxis\n\n\nRemove fields in \nDictArray\n/\nLabeledArray\n or keys in \nLDict\n: \ndelete\n\n\n\n\nSelect/Update tables in SQL style\n\n\n\n\nCreate new fields and/or aggregating by some fields after choosing some elements based on given conditions: \n@select\n, \nselct\n\n\nUpdate existing fields or append new fields and/or aggregating by some fields after choosing some elements based on given conditions: \n@update\n, \nupdate\n\n\n\n\nJoin tables\n\n\n\n\nleft join tables: \nleftjoin\n\n\ninner join tables: \ninnerjoin\n\n\n\n\nDealing with \nNA\n (null elements)\n\n\n\n\nRemove \nNullable\n: \nigna\n\n\nRemove \nNullable\n from a nullable boolean array, replacing null elements with \nfalse\n: \nignabool\n\n\n\n\nTransform arrays\n\n\n\n\nChanging an array of arrays into an array, expanding the elements of array type along some direction: \nungroup\n\n\nMake the fields to the last axis in \nLabeledArray\n: \nflds2axis\n\n\nMake the last axis to fieldsi in \nLabeledArray\n: \naxis2flds\n\n\nReplace the current axes along some directions with some fields \nLabeledArray\n: \nreplace_axes\n\n\nFlatten some of the middle dimensions in an array: \ncollapse_axes\n\n\nReordering fields: \nreorder\n\n\nRenaming field names: \nrename\n\n\nTensor product arrays: \ntensorprod\n\n\nProviding/Withdrawing field names to \nLabeledArray\n when some of its base or axes are not \nDictArray\n: \nprovidenames\n, \nwithdrawnames\n\n\n\n\nMap arrays\n\n\n\n\nMap a function \nf\n element by element\n\n\nif \nf\n is from non nullable value to nullable or non nullable value: \nmapna\n\n\nif \nf\n is from nullable value to nullable or non nullable value: \nmap\n\n\n\n\n\n\nMap or reduce slices of an array: \nmapslices\n, \nreducedim\n\n\nMap values into another values keeping keys or field names the same: \nmapvalues\n\n\n\n\nCalculate statistics\n\n\n\n\n\n\nAvailable statistical functions:\n\nmsum\n,\n\nmprod\n,\n\nmmean\n,\n\nmmedian\n,\n\nmminimum\n,\n\nmmaximum\n,\n\nmmiddle\n,\n\nmquantile\n\n\n\n\n\n\nSummarize fields in \nDictArray\n: \ndescribe\n\n\n\n\n\n\nFill \nNA\ns forward or backward: \nnafill\n\n\n\n\nShift arrays by some amount. Can be used, for example, to obtain previous or next month time series: \nshift\n\n\n\n\nWork with DataFrames\n\n\n\n\nconvert to DataFrames: \nconvert(::DataFrame, ::DictArray)\n, \nconvert(::DataFrame, ::LabeledArray)\n\n\nconvert from DataFrames: \nconvert(::DictArray, ::DataFrame)\n, \nconvert(::LabeledArray, ::DataFrame)\n, \nconvert(::EnumerationArray, ::DataFrame)\n\n\n\n\nMiscellaneous\n\n\n\n\nRemove all \nNA\n elements in an array, possibly reducing its size when some elements along some slice are all \nNA\n: \ndropna\n\n\nCombining two arrays of the same shape. The second one updates the first one only when the element is not \nNA\n: \nnamerge\n\n\nWant to avoid excessive numbers of parentheses when applying several functions: \n@rap\n.\n\n\nCreate a labels => base value nested dictionary from \nLabeledArray\n: \ntbltool.create_dict\n\n\nSet elements in an array to \nNA\n: \ntbltool.setna!\n\n\nChoose whether to display fields along row or column: \nalongrow=true/false\n option in \nshow\n for \nDictArray\n and \nshow\n for \nLabeledArray\n.\n\n\nTake some number of elements repeatedly along some direction in an array: \ntbltool.gtake\n.\n\n\nDrop some number of elements along some direction in an array: \ntbltool.gdrop\n.\n\n\nSet show size when printing \nDictArray\n and \nLabeledArray\n to console: \ntbltool.set_showalongrow!!\n,\ntbltool.set_showheight!!\n, \ntbltool.set_showwidth!!\n, \ntbltool.set_default_showsize!!\n\n\nSet display size for html output of \nDictArray\n and \nLabeledArray\n: \ntbltool.set_dispalongrow!!\n, \ntbltool.set_dispheight!!\n, \ntbltool.set_dispwidth!!\n, \ntbltool.set_default_dispsize!!",
            "title": "Where To Look"
        },
        {
            "location": "/where_to_look/#where-to-look",
            "text": "Create an array   Create a nullable array  with  NA  (i.e. null) elements in it, mostly for manual typing:  @nalift .  without  NA , typically just to lift non  Nullable  arrays:  nalift .    Create a multidimensional table:  darr ,  @darr   to create a  DictArray . The latter if you want to convert  NA  into appropriate null elements when manually typing.  Create an array with labels:  larr ,  @larr  to create a  LabeledArray . The latter if you want to convert  NA  into appropriate null elements when manually typing.  Create a nullable array where there are many duplications, i.e. create a pooled/enumeration array:  enumeration ,  @enumeration   Choose/Remove elements in an array   Choose elements using index (normal way): index notation( getindex ).  Choose/Remove based on labels in  LabeledArray :  extract ,  discard .  Choose the underlying  base  of  LabeledArray :  peel  Choose the underlying ordered dictionary( LDict ) of  DictArray :  peel  Choose field name(s) from  DictArray  or  LabeledArray :  pick  Choose the axis or axes of  LabeledArray :  pickaxis  Remove fields in  DictArray / LabeledArray  or keys in  LDict :  delete   Select/Update tables in SQL style   Create new fields and/or aggregating by some fields after choosing some elements based on given conditions:  @select ,  selct  Update existing fields or append new fields and/or aggregating by some fields after choosing some elements based on given conditions:  @update ,  update   Join tables   left join tables:  leftjoin  inner join tables:  innerjoin   Dealing with  NA  (null elements)   Remove  Nullable :  igna  Remove  Nullable  from a nullable boolean array, replacing null elements with  false :  ignabool   Transform arrays   Changing an array of arrays into an array, expanding the elements of array type along some direction:  ungroup  Make the fields to the last axis in  LabeledArray :  flds2axis  Make the last axis to fieldsi in  LabeledArray :  axis2flds  Replace the current axes along some directions with some fields  LabeledArray :  replace_axes  Flatten some of the middle dimensions in an array:  collapse_axes  Reordering fields:  reorder  Renaming field names:  rename  Tensor product arrays:  tensorprod  Providing/Withdrawing field names to  LabeledArray  when some of its base or axes are not  DictArray :  providenames ,  withdrawnames   Map arrays   Map a function  f  element by element  if  f  is from non nullable value to nullable or non nullable value:  mapna  if  f  is from nullable value to nullable or non nullable value:  map    Map or reduce slices of an array:  mapslices ,  reducedim  Map values into another values keeping keys or field names the same:  mapvalues   Calculate statistics    Available statistical functions: msum , mprod , mmean , mmedian , mminimum , mmaximum , mmiddle , mquantile    Summarize fields in  DictArray :  describe    Fill  NA s forward or backward:  nafill   Shift arrays by some amount. Can be used, for example, to obtain previous or next month time series:  shift   Work with DataFrames   convert to DataFrames:  convert(::DataFrame, ::DictArray) ,  convert(::DataFrame, ::LabeledArray)  convert from DataFrames:  convert(::DictArray, ::DataFrame) ,  convert(::LabeledArray, ::DataFrame) ,  convert(::EnumerationArray, ::DataFrame)   Miscellaneous   Remove all  NA  elements in an array, possibly reducing its size when some elements along some slice are all  NA :  dropna  Combining two arrays of the same shape. The second one updates the first one only when the element is not  NA :  namerge  Want to avoid excessive numbers of parentheses when applying several functions:  @rap .  Create a labels => base value nested dictionary from  LabeledArray :  tbltool.create_dict  Set elements in an array to  NA :  tbltool.setna!  Choose whether to display fields along row or column:  alongrow=true/false  option in  show  for  DictArray  and  show  for  LabeledArray .  Take some number of elements repeatedly along some direction in an array:  tbltool.gtake .  Drop some number of elements along some direction in an array:  tbltool.gdrop .  Set show size when printing  DictArray  and  LabeledArray  to console:  tbltool.set_showalongrow!! , tbltool.set_showheight!! ,  tbltool.set_showwidth!! ,  tbltool.set_default_showsize!!  Set display size for html output of  DictArray  and  LabeledArray :  tbltool.set_dispalongrow!! ,  tbltool.set_dispheight!! ,  tbltool.set_dispwidth!! ,  tbltool.set_default_dispsize!!",
            "title": "Where To Look"
        },
        {
            "location": "/api/",
            "text": "MultidimensionalTables\n\n\nExported\n\n\n\n\n\n\nMultidimensionalTables.axis2flds \n\u00b6\n\n\naxis2flds(arr::LabeledArray (; name_collapse_function=..., default_axis_value=nothing)\n\n\nCollapse a dimension of a \nLabeledArray\n, making the axis along that direction as field names.\n\n\nArguments\n\n\n\n\nlarr\n : a LabeledArray.\n\n\nname_collapse_function\n (optional keyword) : a function to combine the axis label and the column name. By default, it concatenates the names with '_' inserted in between.\n\n\ndefault_axis_value\n (optional keyword) : a default value to be used when an axis element is null. If \nnothing\n (by default), an exception will raise.\n\n\n\n\nExamples\n\n\njulia> t = larr(reshape(1:10,5,2), axis1=darr(k=['a','b','c','d','e']), axis2=darr(r1=[:M,:N],r2=[\"A\",\"A\"]))\n5 x 2 LabeledArray\n\nr1 |M |N  \nr2 |A |A  \n---+--+---\nk  |  |   \n---+--+---\na  |1 |6  \nb  |2 |7  \nc  |3 |8  \nd  |4 |9  \ne  |5 |10 \n\n\njulia> axis2flds(t)\n5 LabeledArray\n\nk |M_A N_A \n--+--------\na |1   6   \nb |2   7   \nc |3   8   \nd |4   9   \ne |5   10  \n\n\njulia> axis2flds(t, name_collapse_function=x->join(x, \"*\"))\n5 LabeledArray\n\nk |M*A N*A \n--+--------\na |1   6   \nb |2   7   \nc |3   8   \nd |4   9   \ne |5   10  \n\n\njulia> m = @larr(reshape(1:10,5,2), axis1[k=['a','b','c','d','e']], axis2[:M,NA])\n5 x 2 LabeledArray\n\n  |M |   \n--+--+---\nk |  |   \n--+--+---\na |1 |6  \nb |2 |7  \nc |3 |8  \nd |4 |9  \ne |5 |10 \n\n\njulia> axis2flds(m, default_axis_value=\"N/A\")\n5 LabeledArray\n\nk |M N/A \n--+------\na |1 6   \nb |2 7   \nc |3 8   \nd |4 9   \ne |5 10  \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:614\n\n\n\n\n\n\nMultidimensionalTables.collapse_axes \n\u00b6\n\n\ncollapse_axes(arr::AbstractArray, front_dim::Integer, back_end::Integer)\n\n\nCollapse front_dim to back_dim dimensions into one.\n\n\nArguments\n\n\n\n\narr\n : an array\n\n\nfront_dims\n : the starting direction to collapse.\n\n\nback_dims\n : the end direction to collapse.\n\n\n\n\nThe result is an array whose elements along front_dims to back_dims are all flattened into one dimension.\nIf \narr\n is a LabeledArray, all the labels along the flattened direction are combined together.\n\n\nExamples\n\n\njulia> collapse_axes(darr(a=reshape(1:40, 2,4,5), b=reshape(11:50, 2,4,5)), 1, 2)\n8 x 5 DictArray\n\na b  |a  b  |a  b  |a  b  |a  b  \n-----+------+------+------+------\n1 11 |9  19 |17 27 |25 35 |33 43 \n2 12 |10 20 |18 28 |26 36 |34 44 \n3 13 |11 21 |19 29 |27 37 |35 45 \n4 14 |12 22 |20 30 |28 38 |36 46 \n5 15 |13 23 |21 31 |29 39 |37 47 \n6 16 |14 24 |22 32 |30 40 |38 48 \n7 17 |15 25 |23 33 |31 41 |39 49 \n8 18 |16 26 |24 34 |32 42 |40 50 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:203\n\n\n\n\n\n\nMultidimensionalTables.darr \n\u00b6\n\n\ndarr(...)\n\n\nCreate a \nDictArray\n. The arguments \n...\n can be one of the following:\n\n\nArguments\n\n\n\n\nk=>v\n creates a field using an array \nv\n with field name \nk\n. \nk\n can be an arbitrary type. If the element type of \nv\n is not \nNullable\n, each element will be wrapped by \nNullable\n. If you want to manually provide a \nNullable\n array with \nNullable{T}()\n elements in it, the macro version \n@darr\n may be more convenient to use. Note that this type of argument precedes the keyword type argument in the return \nDictArray\n, as shown in Examples below.\n\n\nk=v\n creates a field using an array \nv\n with field name \n:k\n.\n\n\nThere can be at most one non pair type argument, which will be converted into a \nDictArray\n and other pair arguments will update it.\nEspecially, if the non pair type argument is an array of \nLDict\n, it will be converted into a \nDictArray\n.\n\n\n\n\nExamples\n\n\njulia> t = darr(a=[1 2;3 4;5 6],b=[\"abc\" 'a';1 2;:m \"xyz\"],:c=>[1.0 1.5;:sym 'a';\"X\" \"Y\"])\n3 x 2 DictArray\n\nc   a b   |c   a b   \n----------+----------\n1.0 1 abc |1.5 2 a   \nsym 3 1   |a   4 2   \nX   5 m   |Y   6 xyz \n\n\njulia> darr(t, c=[1 2;3 4;5 6], :d=>map(Nullable, [1 2;3 4;5 6]))\n3 x 2 DictArray\n\nc a b   d |c a b   d \n----------+----------\n1 1 abc 1 |2 2 a   2 \n3 3 1   3 |4 4 2   4 \n5 5 m   5 |6 6 xyz 6 \n\njulia> darr(Any[LDict(:a => Nullable(1),:b => Nullable{Int}()),LDict(:a => Nullable(3),:b => Nullable(4))])\n2 DictArray\n\na b \n----\n1   \n3 4 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:1288\n\n\n\n\n\n\nMultidimensionalTables.delete \n\u00b6\n\n\nDelete keys or fields from \nLDict\n, \nDictArray\n, or \nLabeledArray\n.\n\n\n\n\ndelete(dict::LDict, keys...)\n deletes the keys \nkeys\n from \ndict\n and returns a new \nLDict\n.\n\n\ndelete(arr::DictArray, fieldnames...)\n deletes the fields for \nfieldnames\n from \narr\n and returns a new \nDictArray\n.\n\n\ndelete(arr::LabeledArray, fieldnames...)\n deletes the fields for \nfieldnames\n from \narr\n, either from the base or axes, and returns a new \nLabeledArray\n.\n\n\n\n\nExamples\n\n\njulia> delete(LDict(:a=>1, :b=>2, :c=>3), :a, :c)\nMultidimensionalTables.LDict{Symbol,Int64} with 1 entry:\n  :b => 2\n\njulia> delete(darr(a=[1,2,3], b=[:m,:n,:p]), :b)\n3 DictArray\n\na \n--\n1 \n2 \n3 \n\n\njulia> t = larr(a=[1 2;3 4;5 6], b=[:x :y;:z :u;:v :w], axis1=darr(k=[\"X\",\"Y\",\"Z\"]), axis2=[:A,:B])\n3 x 2 LabeledArray\n\n  |A   |B   \n--+----+----\nk |a b |a b \n--+----+----\nX |1 x |2 y \nY |3 z |4 u \nZ |5 v |6 w \n\n\njulia> delete(t, :k, :b)\n3 x 2 LabeledArray\n\n  |A |B \n--+--+--\n  |a |a \n--+--+--\n1 |1 |2 \n2 |3 |4 \n3 |5 |6 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:979\n\n\n\n\n\n\nMultidimensionalTables.describe \n\u00b6\n\n\ndescribe(arr)\n\n\nGenerate a \nLabeledArray\n showing the overall statistics of the input.\nIf the input is a \nNullable\n array, its summary statistics is calculated and the return value is of type \nLDict\n.\nIf the input is a \nDictArray\n, the summary is calculated for each field and the result is a \nDictArray\n.\nIf the input is a \nLabeledArray\n, \ndescribe\n returns the summary of its base.\n\n\nExamples\n\n\njulia> describe(@nalift([1,2,3,4,NA]))\nMultidimensionalTables.LDict{Symbol,Any} with 10 entries:\n  :min     => [Nullable(1)]\n  :q1      => Nullable(1.75)\n  :med     => Nullable(2.5)\n  :q3      => Nullable(3.25)\n  :max     => Nullable(4)\n  :mean    => Nullable(2.5)\n  :std     => Nullable(1.2909944487358056)\n  :count   => Nullable(5)\n  :nacount => Nullable(1)\n  :naratio => Nullable(0.2)\n\njulia> describe(@darr(a=[1,2,3,4,NA],b=[1,2,3,4,5]))\n2 LabeledArray\n\n  |min q1   med q3   max mean std                count nacount naratio \n--+--------------------------------------------------------------------\na |1   1.75 2.5 3.25 4   2.5  1.2909944487358056 5     1       0.2     \nb |1   2.0  3.0 4.0  5   3.0  1.5811388300841898 5     0       0.0     \n\n\njulia> describe(@larr(a=[1,2,3,4,NA],b=[1,2,3,4,5],axis1[:m,:n,:p,:q,:r]))\n2 LabeledArray\n\n  |min q1   med q3   max mean std                count nacount naratio \n--+--------------------------------------------------------------------\na |1   1.75 2.5 3.25 4   2.5  1.2909944487358056 5     1       0.2     \nb |1   2.0  3.0 4.0  5   3.0  1.5811388300841898 5     0       0.0     \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_helper_functions.jl:1312\n\n\n\n\n\n\nMultidimensionalTables.discard \n\u00b6\n\n\ndiscard(arr, ns...)\n\n\nDiscard a block of array discarding all elements specified by \nns\n..., using labels for \nLabeledArray\ns, indices for other types of arrays or \nLDict\ns.\n\n\nArguments\n\n\n\n\narr\n: an \nAbstractArray\n or \nLDict\n.\n\n\nns...\n: each element in \nns\n chooses specific elements along that direction. The element can be\n\n\nColon()\n (\n:\n): the entire range will be removed and the return value will be empty.\n\n\na label or array of labels along that direction to discard.\n\n\na boolean array of the same size as the axis along that direction to denote which position to discard.\n\n\na function that takes the axis along that direction and generates either an array of integers or a boolean array for the deleted positions.\n\n\n\n\nReturn\n\n\nAn array or \nLDict\n of the same type as \narr\n, which is selected based on \nns\n.... All indices will be chosen for the rest of the directions not specified in \nns\n.... If any label is missing or the integer range is out of bound, it will be ignored.\n\n\nExamples\n\n\njulia> t = larr(a=map(x->'a'+x,reshape(0:14,5,3)), b=reshape(1:15,5,3), axis1=[:X,:Y,:Z,:U,:V], axis2=darr(r1=[:A,:A,:B],r2=[:m,:n,:n]))\n5 x 3 LabeledArray\n\nr1 |A   |A    |B    \nr2 |m   |n    |n    \n---+----+-----+-----\n   |a b |a b  |a b  \n---+----+-----+-----\nX  |a 1 |f 6  |k 11 \nY  |b 2 |g 7  |l 12 \nZ  |c 3 |h 8  |m 13 \nU  |d 4 |i 9  |n 14 \nV  |e 5 |j 10 |o 15 \n\n\njulia> discard(t, [:X,:V,:W], map(Nullable,(:A,:m)))\n3 x 2 LabeledArray\n\nr1 |A   |B    \nr2 |n   |n    \n---+----+-----\n   |a b |a b  \n---+----+-----\nY  |g 7 |l 12 \nZ  |h 8 |m 13 \nU  |i 9 |n 14 \n\n\njulia> discard(t, [:X,:V,:W], darr(r1=[:A,:B],r2=[:m,:m]))\n3 x 2 LabeledArray\n\nr1 |A   |B    \nr2 |n   |n    \n---+----+-----\n   |a b |a b  \n---+----+-----\nY  |g 7 |l 12 \nZ  |h 8 |m 13 \nU  |i 9 |n 14 \n\n\njulia> discard(t, [], d->d[:r1] .== :A)\n5 x 1 LabeledArray\n\nr1 |B    \nr2 |n    \n---+-----\n   |a b  \n---+-----\nX  |k 11 \nY  |l 12 \nZ  |m 13 \nU  |n 14 \nV  |o 15 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:1611\n\n\n\n\n\n\nMultidimensionalTables.dropna \n\u00b6\n\n\nRemove any \nNA\n entries. If all elements are \nNA\n along some slice, that slice will be removed and the array size will shrink.\n\n\nExamples\n\n\njulia> t = @darr(a=[1 2 NA;NA 5 NA], b=[NA :n NA;:x NA NA])\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n1   |2 n |    \n  x |5   |    \n\n\njulia> dropna(t)\n2 x 2 DictArray\n\na b |a b \n----+----\n1   |2 n \n  x |5   \n\n\njulia> m = @larr(a=[1 2 NA;NA 5 NA], b=[NA :n NA;:x NA NA], axis1[:M,:N])\nd2 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nM |1   |2 n |    \nN |  x |5   |    \n\n\njulia> dropna(m)\n2 x 2 LabeledArray\n\n  |1   |2   \n--+----+----\n  |a b |a b \n--+----+----\nM |1   |2 n \nN |  x |5   \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:1067\n\n\n\n\n\n\nMultidimensionalTables.enumeration \n\u00b6\n\n\nenumeration(arr [, poolorder])\n\n\nCreate an \nEnumerationArray\n.\n\n\nArguments\n\n\n\n\narr\n: an input array of \nNullable\n element type. It is assumed that there are only a few possible values in \narr\n and each value is converted into an integer when creating an \nEnumerationArray\n.\n\n\npoolorder\n: a vector to fix some of the integer values in the mapping from the values in \narr\n to integers. If there are \nn\n elements in \npoolorder\n, those \nn\n elements in \narr\n will be assigned 1...\nn\n when creating an \nEnumerationArray\n. All the others are assigned integers in order of their appearance.\n\n\n\n\nExamples\n\n\njulia> enumeration([:A,:A,:B,:B,:C])\n5-element MultidimensionalTables.EnumerationArray{Symbol,1,MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}},Int64}:\n Nullable(:A)\n Nullable(:A)\n Nullable(:B)\n Nullable(:B)\n Nullable(:C)\n\njulia> enumeration([:A,:A,:B,:B,:C]).pool\n3-element Array{Symbol,1}:\n :A\n :B\n :C\n\njulia> enumeration([:A,:A,:B,:B,:C]).elems\n5-element MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}}:\n 1\n 1\n 2\n 2\n 3\n\njulia> enumeration([:A,:A,:B,:B,:C], [:C,:B])\n5-element MultidimensionalTables.EnumerationArray{Symbol,1,MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}},Int64}:\n Nullable(:A)\n Nullable(:A)\n Nullable(:B)\n Nullable(:B)\n Nullable(:C)\n\njulia> enumeration([:A,:A,:B,:B,:C], [:C,:B]).pool\n3-element Array{Symbol,1}:\n :C\n :B\n :A\n\njulia> enumeration([:A,:A,:B,:B,:C], [:C,:B]).elems\n5-element MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}}:\n 3\n 3\n 2\n 2\n 1\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/enumeration_array.jl:178\n\n\n\n\n\n\nMultidimensionalTables.extract \n\u00b6\n\n\nextract(arr, ns...)\n\n\nExtract a block of array using labels for \nLabeledArray\ns, indices for other types of arrays or \nLDict\ns.\n\n\nArguments\n\n\n\n\narr\n: an \nAbstractArray\n or \nLDict\n.\n\n\nns...\n: each element in \nns\n chooses specific elements along that direction. The element can be\n\n\nColon()\n (\n:\n): the entire range.\n\n\na label along that direction. If the axis along the direction is \nDictArray\n, the label can be either an \nLDict\n for its element or a tuple to denote the values of \nLDict\n.\n\n\narray of labels along that direction.\n\n\na boolean array of the same size as the axis along that direction to denote which position to choose.\n\n\na function that takes the axis along that direction and generates either an array of integers or a boolean array for the selected positions.\n\n\n\n\nReturn\n\n\nAn array or \nLDict\n of the same type as \narr\n, which is selected based on \nns\n.... All indices will be chosen for the rest of the directions not specified in \nns\n.... If any label is missing or the integer range is out of bound, \nNA\n will be used for that element in the return value. If an element in \nns\n is scalar, the dimension along that direction will be collapsed just as in \nslice\n.\n\n\nExamples\n\n\njulia> t = larr(a=map(x->'a'+x,reshape(0:14,5,3)), b=reshape(1:15,5,3), axis1=[:X,:Y,:Z,:U,:V], axis2=darr(r1=[:A,:A,:B],r2=[:m,:n,:n]))\n5 x 3 LabeledArray\n\nr1 |A   |A    |B    \nr2 |m   |n    |n    \n---+----+-----+-----\n   |a b |a b  |a b  \n---+----+-----+-----\nX  |a 1 |f 6  |k 11 \nY  |b 2 |g 7  |l 12 \nZ  |c 3 |h 8  |m 13 \nU  |d 4 |i 9  |n 14 \nV  |e 5 |j 10 |o 15 \n\n\njulia> extract(t, [:X,:V,:W], map(Nullable,(:A,:m)))\n3 LabeledArray\n\n  |a b \n--+----\nX |a 1 \nV |e 5 \nW |    \n\n\njulia> extract(t, [:X,:V,:W], darr(r1=[:A,:B],r2=[:m,:m]))\n3 x 2 LabeledArray\n\nr1 |A   |B   \nr2 |m   |m   \n---+----+----\n   |a b |a b \n---+----+----\nX  |a 1 |    \nV  |e 5 |    \nW  |    |    \n\n\njulia> extract(t, :, d->d[:r1] .== :A)\n5 x 2 LabeledArray\n\nr1 |A   |A    \nr2 |m   |n    \n---+----+-----\n   |a b |a b  \n---+----+-----\nX  |a 1 |f 6  \nY  |b 2 |g 7  \nZ  |c 3 |h 8  \nU  |d 4 |i 9  \nV  |e 5 |j 10 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:1399\n\n\n\n\n\n\nMultidimensionalTables.flds2axis \n\u00b6\n\n\nflds2axis(arr::LabeledArray [; axisname=nothing, fieldname=nothing])\n\n\nCreate another dimension using the field values of the data of a LabeledArray.\n\n\nArguments\n\n\n\n\narr\n : a \nLabeledArray\n.\n\n\naxisname\n (optional) : the name of the new axis.\n\n\nfieldname\n (optional) : the name of the new field name. If not specified, the resulting \nLabeledArray\n will have a normal \nAbstractArray\n and not a \nDictArray\n as its data.\n\n\n\n\nReturns\n\n\nA new \nLabeledArray\n which has one higher dimensions than the input \narr\n.\nThe field names become the elements of the new last axis, after wrapped by \nNullable\n.\nIf \naxisname\n is provided, the new axis becomes a \nDictArray\n with that field name.\nOtherwise, the new axis will be a normal array.\nIf \nfieldname\n is provided, the new data of the return \nLabeledArray\n is a \nDictArray\n with that field name.\nOtherwise, the new data will be a normal array.\n\n\nExamples\n\n\njulia> t = larr(a=[1,2,3], b=[:x,:y,:z])\n3 LabeledArray\n\n  |a b \n--+----\n1 |1 x \n2 |2 y \n3 |3 z \n\n\njulia> flds2axis(t, axisname=:newaxis, fieldname=:newfield)\n3 x 2 LabeledArray\n\nnewaxis |a        |b        \n--------+---------+---------\n        |newfield |newfield \n--------+---------+---------\n1       |1        |x        \n2       |2        |y        \n3       |3        |z        \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:509\n\n\n\n\n\n\nMultidimensionalTables.igna \n\u00b6\n\n\nigna(arr [, nareplace])\n\n\nIgnore null elements from \narr\n.\nNull elements will be replaced by \nnareplace\n, if provided.\nIf not, the behavior is implementation specific: depending on the array type, it may give some default value or raise an error.\nMost likely, a nullable element in an array of \nNullable{F}\n element type for some \nAbstractFloat\n \nF\n can be replaced by a version of \nNaN\n.\nBut for other types, it may be better to raise an error.\n\n\n\n\n\n\nigna(arr::AbstractArray{Nullable{T},N} [, na_replace])\n: ignores null elements from \narr\n and return an \nAbstractArray{T,N}\n. A null value is replaced by \nna_replace\n if provided. Otherwise, the result is implementation specific.\n\n\n\n\n\n\nigna(ldict::LDict [, na_replace])\n ignores null values from \nldict\n and replace them with \nna_replace\n if provided. Otherwise, the result is implementation specific.\n\n\n\n\n\n\nExamples\n\n\njulia> igna(@nalift([1,2,NA,4,5]))\nERROR: MultidimensionalTables.NAElementException()\n in anonymous at /Users/changsoonpark/.julia/v0.4/MultidimensionalTables/src/na/na.jl:315\n in map_to! at abstractarray.jl:1289\n in map at abstractarray.jl:1311\n in igna at /Users/changsoonpark/.julia/v0.4/MultidimensionalTables/src/na/na.jl:313\n\njulia> igna(@nalift([1.0,2.0,NA,4.0,5.0]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Float64,1,Array{Float64,1}}:\n   1.0\n   2.0\n NaN  \n   4.0\n   5.0\n\njulia> igna(@nalift([1,2,NA,4,5]), 3)\n5-element MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}}:\n 1\n 2\n 3\n 4\n 5\n\njulia> igna(LDict(:a=>Nullable(3), :b=>Nullable{Int}()), 1)\nMultidimensionalTables.LDict{Symbol,Int64} with 2 entries:\n  :a => 3\n  :b => 1\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/na/na.jl:483\n\n\n\n\n\n\nMultidimensionalTables.ignabool \n\u00b6\n\n\nignabool(arr)\n\n\nIgnore the \nNullable\n part of of either a \nNullable\n array or a \nNullable\n variable.\nIt is mainly used in the condition statement for @select or @update, where it assumes that only Nullable(true) chooses the element.  Nullable(false) or Nullable{T}() will be regarded as false.\n\n\n\n\nignabool(::AbstractArray{Nullable{Bool}}) returns an\nAbstractArray{Bool}\nwhere null and\nNullable(false)\nelements are converted into\nfalse\nand\nNullable(true)\ninto\ntrue`.\n\n\nignabool(::Nullable{Bool})\n converts null and \nNullable(false)\n elements into \nfalse\n and \nNullable(true)\n into true.\n\n\n\n\nExamples\n\n\njulia> ignabool(Nullable{Bool}())\nfalse\n\njulia> ignabool(Nullable(true))\ntrue\n\njulia> ignabool(Nullable(false))\nfalse\n\njulia> ignabool(@nalift([true true NA;false NA true]))\n2x3 MultidimensionalTables.AbstractArrayWrapper{Bool,2,Array{Bool,2}}:\n  true   true  false\n false  false   true\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/na/na.jl:568\n\n\n\n\n\n\nMultidimensionalTables.innerjoin \n\u00b6\n\n\ninnerjoin(base, src, join_axis...)\n\n\nInner join an LabeledArray into another LabeledArray. \ninnerjoin\n is different from \nleftjoin\n in that only elements in the left array that have the corresponding elements in the right array will be kept. Otherwise, the elements will be set to null. If the entire elements along some direction are null, they will be all removed in the output.\nNote that the left array (base) can be multidimensional. The function creates a dictionary from the right array (\nsrc\n).\n\n\nArguments\n\n\n\n\nbase\n : the left \nLabeledArray\n.\n\n\nsrc\n : the right \nLabeledArray\n.\n\n\njoin_axes...\n can be one of the following forms:\n\n\nintegers for the directions in \nsrc\n along which to join.\n\n\na list of integer=>integer or integer=>vector of arrays, each array of the same shape as \nbase\n.\n\n\n\n\n\n\n\n\nUltimately, \njoin_axes...\n produces pairs of direction in \nsrc\n => vector of arrays, each of the shape of \nbase\n. If the value in key=>value is an integer, the axis along that direction in \nbase\n is taken, after broadcast. The field values are combined into a vector of arrays. If the right hand side is missing (i.e. just an integer), the field names in the axis along the integer direction are used to create an array for \nbase\n.\n\n\nReturn\n\n\nAn inner joined \nLabeledArray\n. The join is performed as follows: Given an \ni=>arr\n form as an element in \njoin_axes\n, the keys in \ni\nth direction in \nsrc\n are used as keys and \narr\n are used the keys in the \nbase\n side to inner join. The values will be the sliced subarrays for each value in the \njoin_axes\n. Note that \njoin_axis...\n chooses multiple axes for keys.\nThe output number of dimensions is \nndims(base) + ndims(src) - length(join_axes)\n.\nNote that when \njoin_axis\n is empty, the result is the tensor product of \nbase\n and \nsrc\n from \ntensorprod\n.\n\n\nExamples\n\n\njulia> b = larr(k=[:x :x :y;:z :u :v], axis1=[:x,:u], axis2=darr(r=[:x, :y, :z]))\n2 x 3 LabeledArray\n\nr |x |y |z \n--+--+--+--\n  |k |k |k \n--+--+--+--\nx |x |x |y \nu |z |u |v \n\n\njulia> s = larr(axis1=darr(k=[:x,:y,:z,:m,:n,:p]), b=[1,2,3,4,5,6])\n6 LabeledArray\n\nk |b \n--+--\nx |1 \ny |2 \nz |3 \nm |4 \nn |5 \np |6 \n\n\njulia> innerjoin(b, s, 1)\n2 x 3 LabeledArray\n\nr |x   |y   |z   \n--+----+----+----\n  |k b |k b |k b \n--+----+----+----\nx |x 1 |x 1 |y 2 \nu |z 3 |u   |v   \n\n\njulia> innerjoin(b, s, 1=>1)\n1 x 3 LabeledArray\n\nr |x   |y   |z   \n--+----+----+----\n  |k b |k b |k b \n--+----+----+----\nx |x 1 |x 1 |y 1 \n\n\njulia> innerjoin(b, s, 1=>Any[nalift([:o :x :x;:q :r :y])])\n2 x 2 LabeledArray\n\nr |y   |z   \n--+----+----\n  |k b |k b \n--+----+----\nx |x 1 |y 1 \nu |u   |v 2 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/join.jl:288\n\n\n\n\n\n\nMultidimensionalTables.isna \n\u00b6\n\n\nisna(arr [, coords...])\n\n\nChecks \nNA\n for each element and produces an AbstractArray{Bool} of the same shape as \narr\n.\nIf \ncoords...\n are provided, \nisna\n checks \nNA\n at that position.\n\n\n\n\nIf an input array is \nAbstractArray{Nullable{T}}\n, it checkes whether an element is null.\n\n\nIf an input array is \nDictArray\n, it tests whether all values of the dictionary values for each element are null.\n\n\nIf an input array is \nLabeledArray\n, it applies \nisna\n to the base of \narr\n.\n\n\n\n\nExamples\n\n\njulia> t = @darr(a=[1 NA 3;4 5 NA], b=[NA NA :z;:u :v :w])\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n1   |    |3 z \n4 u |5 v |  w \n\n\njulia> isna(t)\n2x3 MultidimensionalTables.AbstractArrayWrapper{Bool,2,Array{Bool,2}}:\n false   true  false\n false  false  false\n\njulia> isna(t, 2, 2:3)\n1x2 MultidimensionalTables.AbstractArrayWrapper{Bool,2,Array{Bool,2}}:\n false  false\n\njulia> isna(@larr(t, axis1[NA,:Y], axis2[NA,NA,\"W\"]))\n2x3 MultidimensionalTables.AbstractArrayWrapper{Bool,2,Array{Bool,2}}:\n false   true  false\n false  false  false\n\njulia> isna(@nalift([1 2 NA;NA 5 6]))\n2x3 MultidimensionalTables.AbstractArrayWrapper{Bool,2,Array{Bool,2}}:\n false  false   true\n  true  false  false\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/na/na.jl:619\n\n\n\n\n\n\nMultidimensionalTables.larr \n\u00b6\n\n\nlarr(...)\n\n\nCreate a \nLabeledArray\n. The arguments \n...\n can be one of the following:\n\n\nArguments\n\n\n\n\nk=>v\n creates a field using array \nv\n with field name \nk\n for the underlying base \nDictArray\n. \nk\n can be an arbitrary type. If the element type of \nv\n is not \nNullable\n, each element will be wrapped by \nNullable\n. If you want to manually provide a \nNullable\n array with \nNullable{T}()\n elements in it, the macro version \n@larr\n may be more convenient to use. Note that this type of argument precedes the keyword type argument in the return \nLabeledArray\n, as shown in Examples below.\n\n\nk=v\n creates a field using an array \nv\n with field name \n:k\n for the underlying base \nDictArray\n.\n\n\nThe keyword \naxisN=v\n for some integer \nN\n and an array \nv\n is treated specially. This will create the \nN\nth axis using the array \nv\n.\n\n\nThere can be at most one non pair type argument, which will be converted into a \nLabeledArray\n and other pair arguments will update it.\nEspecially, if the non pair type argument is an array of \nLDict\n, it will be converted into a \nDictArray\n.\n\n\n\n\nExamples\n\n\njulia> t = larr(a=[1 2;3 4;5 6],:b=>[1.0 1.5;:sym 'a';\"X\" \"Y\"],c=1,axis1=[:U,:V,:W],axis2=darr(r=['m','n']))\n3 x 2 LabeledArray\n\nr |m       |n       \n--+--------+--------\n  |b   a c |b   a c \n--+--------+--------\nU |1.0 1 1 |1.5 2 1 \nV |sym 3 1 |a   4 1 \nW |X   5 1 |Y   6 1 \n\n\njulia> larr(t, c=[1 2;3 4;5 6], :d=>:X, axis1=darr(k=[\"g\",\"h\",\"i\"]))\n3 x 2 LabeledArray\n\nr |m         |n         \n--+----------+----------\nk |b   a c d |b   a c d \n--+----------+----------\ng |1.0 1 1 X |1.5 2 2 X \nh |sym 3 3 X |a   4 4 X \ni |X   5 5 X |Y   6 6 X \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/labeled_array.jl:1409\n\n\n\n\n\n\nMultidimensionalTables.leftjoin \n\u00b6\n\n\nleftjoin(base, src, join_axis...)\n\n\nLeft join a \nLabeledArray\n into another \nLabeledArray\n.\nNote that the left array (base) can be multidimensional. The function creates a dictionary from the right array (\nsrc\n).\n\n\nArguments\n\n\n\n\nbase\n : the left \nLabeledArray\n.\n\n\nsrc\n : the right \nLabeledArray\n.\n\n\njoin_axes...\n can be one of the following forms:\n\n\nintegers for the directions in \nsrc\n along which to join. In this case, the keys is the \nbase\n side are found by matching the field names in the join directions in \nsrc\n with those in \nbase\n.\n\n\na list of integer=>integer or integer=>vector of arrays, each of the same shape as \nbase\n.\n\n\n\n\n\n\n\n\nUltimately, \njoin_axes...\n produces pairs of direction in \nsrc\n => vector of arrays, each of the shape of \nbase\n. If the value in key=>value is an integer, the axis along that direction in \nbase\n is taken, after broadcast. The field values are combined into a vector of arrays. If the right hand side is missing (i.e. just an integer), the field names in the axis along the integer direction are used to create an array for \nbase\n.\n\n\nReturn\n\n\nA left joined \nLabeledArray\n. The join is performed as follows: Given an \ni=>arr\n form as an element in \njoin_axes\n, the keys in \ni\nth direction in \nsrc\n are used as keys and \narr\n are used the keys in the \nbase\n side to left join. The values will be the sliced subarrays for each value in the \njoin_axes\n. Note that \njoin_axis...\n chooses multiple axes for keys.\nThe output number of dimensions is \nndims(base) + ndims(src) - length(join_axes)\n.\nNote that when \njoin_axis\n is empty, the result is the tensor product of \nbase\n and \nsrc\n from \ntensorprod\n.\n\n\nExamples\n\n\njulia> b = larr(k=[:x :x :y;:z :u :v], axis1=[:x,:y], axis2=darr(r=[:x, :y, :z]))\n2 x 3 LabeledArray\n\nr |x |y |z \n--+--+--+--\n  |k |k |k \n--+--+--+--\nx |x |x |y \ny |z |u |v \n\n\njulia> s = larr(axis1=darr(k=[:x,:y,:z,:m,:n,:p]), b=[1,2,3,4,5,6])\n6 LabeledArray\n\nk |b \n--+--\nx |1 \ny |2 \nz |3 \nm |4 \nn |5 \np |6 \n\n\njulia> leftjoin(b, s, 1)\n2 x 3 LabeledArray\n\nr |x   |y   |z   \n--+----+----+----\n  |k b |k b |k b \n--+----+----+----\nx |x 1 |x 1 |y 2 \ny |z 3 |u   |v   \n\n\njulia> leftjoin(b, s, 1=>1)\n2 x 3 LabeledArray\n\nr |x   |y   |z   \n--+----+----+----\n  |k b |k b |k b \n--+----+----+----\nx |x 1 |x 1 |y 1 \ny |z 2 |u 2 |v 2 \n\n\njulia> leftjoin(b, s, 1=>Any[nalift([:x :z :n;:y :m :p])])\n2 x 3 LabeledArray\n\nr |x   |y   |z   \n--+----+----+----\n  |k b |k b |k b \n--+----+----+----\nx |x 1 |x 3 |y 5 \ny |z 2 |u 4 |v 6 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/join.jl:85\n\n\n\n\n\n\nMultidimensionalTables.mapna \n\u00b6\n\n\nmapna(f::Function, args...)\n\n\nApply \nf\n to the nullable arrays \nargs\n. It works similarly as \nmap(f, args...)\n but unwraps Nullable from \nargs\n. If any of elements are Nullable, \nf\n is Nullable, too.\n\n\nArguments\n\n\n\n\nf::Function\n: a function to apply.\n\n\nargs\n: nullable arrays.\n\n\n\n\nReturns\n\n\nA nullable array after applying \nf\n to elements of \nargs\n for each index. \nf\n maps non-nullable value to either non-nullable or nullable one. If mapped to a non-nullable value, it will be wrapped by \nNullable\n implicitly. If any element of \nargs\n is \nNA\n, then the return value at that position will be \nNA\n, too.\n\n\nExamples\n\n\njulia> mapna((x,y)->x+y+1, @nalift([1 2 3;4 5 NA]), @nalift([NA 2 3;4 NA NA]))\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable{Int64}()  Nullable(5)        Nullable(7)      \n Nullable(9)        Nullable{Int64}()  Nullable{Int64}()\n\njulia> mapna((x,y)->Nullable(x+y+1), @nalift([1 2 3;4 5 NA]), @nalift([NA 2 3;4 NA NA]))\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable{Int64}()  Nullable(5)        Nullable(7)      \n Nullable(9)        Nullable{Int64}()  Nullable{Int64}()\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:1110\n\n\n\n\n\n\nMultidimensionalTables.mapvalues \n\u00b6\n\n\nmapvalues(f::Function, x)\n\n\nApply a function \nf\n to \nx\n, which can be of type \nLDict\n/\nDictArray\n/\nLabeledArray\n.\n\n\nReturns\n\n\n\n\nIf \nx\n is \nLDict\n, \nf\n is applied to each value and the result is again \nLDict\n with the same keys and the new values.\n\n\nIf \nx\n is \nDictArray\n, \nf\n is applied to each field. The return value will be \nDictArray\n if the return value of \nf\n is also an \nAbstractArray\n. Otherwise, an \nLDict\n will be returned.\n\n\nIf \nx\n is \nLabeledArray\n, \nmapvalues(f, _)\n is applied to the base of \nx\n. The return value will be \nLabeledArray\n with the same axes if the return value of \nf\n is also an \nAbstractArray\n. Otherwise, an \nLDict\n will be returned.\n\n\n\n\nExamples\n\n\njulia> mapvalues(x->x+1, LDict(:a=>1, :b=>2))\nMultidimensionalTables.LDict{Symbol,Int64} with 2 entries:\n  :a => 2\n  :b => 3\n\njulia> mapvalues(x->x .+ 1, darr(a=[1,2,3], b=[4,5,6]))\n3 DictArray\n\na b \n----\n2 5 \n3 6 \n4 7 \n\n\njulia> mapvalues(x->x .+ 1, larr(a=[1,2,3], b=[4,5,6], axis1=[:m,:n,:p]))\n3 LabeledArray\n\n  |a b \n--+----\nm |2 5 \nn |3 6 \np |4 7 \n\n\njulia> mapvalues(sum, darr(a=[1,2,3], b=[4,5,6]))\nMultidimensionalTables.LDict{Symbol,Nullable{Int64}} with 2 entries:\n  :a => Nullable(6)\n  :b => Nullable(15)\n\njulia> mapvalues(sum, larr(a=[1,2,3], b=[4,5,6], axis1=[:m,:n,:p]))\nMultidimensionalTables.LDict{Symbol,Nullable{Int64}} with 2 entries:\n  :a => Nullable(6)\n  :b => Nullable(15)\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:706\n\n\n\n\n\n\nMultidimensionalTables.mmaximum \n\u00b6\n\n\nmmaximum(arr, dims... [; rev=false, window=0])\n for \narr\n of type \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n.\n\n\nCalculate moving maximum of \narr\n using the last \nwindow\n elements, or cumulative maximum if \nwindow=0\n.\n\n\nArguments\n\n\n\n\narr\n: \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n, the input array. When applied to \nDictArray\n, \nmmaximum\n is applied to each field. When applied to \nLabeledArray\n, \nmmaximum\n is applied to the base.\n\n\ndims\n: by default \ndims=(1,)\n. That is, moving maximum is performed in the first direction. If \ndims=(n1, n2,...)\n, for each slice spanned along the directions \nn1\n, \nn2\n, ..., moving maximum is taken along the leading dimension in \ndims\n first (i.e. \nminimum(dims)\n), and then the next dimension, and so on.\n\n\nrev\n: If \nrev=true\n, moving maximum is calculated backward starting for the last elements. By default, \nrev=false\n.\n\n\nwindow\n: If \nwindow>0\n, only the last \nwindow\n elements, including the one in consideration, will be used to calculate moving maximum. If \nwindow=0\n, \nmaximum\n calculates the cumulative maximum. \nNA\n will be ignored.\n\n\n\n\nExamples\n\n\njulia> mmaximum(@nalift([11,14,12,11,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(11)\n Nullable(14)\n Nullable(14)\n Nullable(14)\n Nullable(17)\n\njulia> mmaximum(@nalift([11,NA,12,11,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(11)\n Nullable(11)\n Nullable(12)\n Nullable(12)\n Nullable(17)\n\njulia> mmaximum(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2)\n2 x 3 DictArray\n\na  b  |a  b  |a  b  \n------+------+------\n11 10 |14 10 |15 10 \n14 10 |15 10 |16 10 \n\n\njulia> mmaximum(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 2, 1, rev=true)\n2 x 3 LabeledArray\n\n  |1     |2    |3    \n--+------+-----+-----\n  |a  b  |a  b |a  b \n--+------+-----+-----\n1 |16 10 |16 9 |16 8 \n2 |16 9  |16 8 |16 5 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_helper_functions.jl:979\n\n\n\n\n\n\nMultidimensionalTables.mmean \n\u00b6\n\n\nmmean(arr, dims... [; rev=false, window=0])\n for \narr\n of type \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n.\n\n\nCalculate moving mean of \narr\n using the last \nwindow\n elements, or cumulative mean if \nwindow=0\n.\n\n\nArguments\n\n\n\n\narr\n: \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n, the input array. When applied to \nDictArray\n, \nmmean\n is applied to each field. When applied to \nLabeledArray\n, \nmmean\n is applied to the base.\n\n\ndims\n: by default \ndims=(1,)\n. That is, moving mean is performed in the first direction. If \ndims=(n1, n2,...)\n, for each slice spanned along the directions \nn1\n, \nn2\n, ..., moving mean is taken along the leading dimension in \ndims\n first (i.e. \nmean(dims)\n), and then the next dimension, and so on.\n\n\nrev\n: If \nrev=true\n, moving mean is calculated backward starting for the last elements. By default, \nrev=false\n.\n\n\nwindow\n: If \nwindow>0\n, only the last \nwindow\n elements, including the one in consideration, will be used to calculate moving mean. If \nwindow=0\n, \nmean\n calculates the cumulative mean. \nNA\n will be ignored.\n\n\n\n\nExamples\n\n\njulia> mmean(@nalift([10,11,12,14,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},1,Array{Nullable{Float64},1}}:\n Nullable(10.0) \n Nullable(10.5) \n Nullable(11.0) \n Nullable(11.75)\n Nullable(12.8) \n\njulia> mmean(@nalift([10,NA,12,14,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},1,Array{Nullable{Float64},1}}:\n Nullable(10.0) \n Nullable(10.0) \n Nullable(11.0) \n Nullable(12.0) \n Nullable(13.25)\n\njulia> mmean(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2)\n2 x 3 DictArray\n\na    b    |a                  b                 |a    b   \n----------+-------------------------------------+---------\n11.0 10.0 |12.333333333333334 8.666666666666666 |13.0 8.0 \n12.5 8.5  |13.0               8.0               |13.5 7.5 \n\n\njulia> mmean(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 2, 1, rev=true)\n2 x 3 LabeledArray\n\n  |1        |2                                    |3        \n--+---------+-------------------------------------+---------\n  |a    b   |a                  b                 |a    b   \n--+---------+-------------------------------------+---------\n1 |13.5 7.5 |14.0               7.0               |14.5 6.5 \n2 |14.0 7.0 |14.666666666666666 6.333333333333333 |16.0 5.0 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_helper_functions.jl:811\n\n\n\n\n\n\nMultidimensionalTables.mmedian \n\u00b6\n\n\nmmedian(arr, dims... [; rev=false, window=0])\n for \narr\n of type \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n.\n\n\nCalculate moving median of \narr\n using the last \nwindow\n elements, or cumulative median if \nwindow=0\n.\n\n\nArguments\n\n\n\n\narr\n: \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n, the input array. When applied to \nDictArray\n, \nmmedian\n is applied to each field. When applied to \nLabeledArray\n, \nmmedian\n is applied to the base.\n\n\ndims\n: by default \ndims=(1,)\n. That is, moving median is performed in the first direction. If \ndims=(n1, n2,...)\n, for each slice spanned along the directions \nn1\n, \nn2\n, ..., moving median is taken along the leading dimension in \ndims\n first (i.e. \nminimum(dims)\n), and then the next dimension, and so on.\n\n\nrev\n: If \nrev=true\n, moving median is calculated backward starting for the last elements. By default, \nrev=false\n.\n\n\nwindow\n: If \nwindow>0\n, only the last \nwindow\n elements, including the one in consideration, will be used to calculate moving median. If \nwindow=0\n, \nmedian\n calculates the cumulative median. \nNA\n will be ignored.\n\n\n\n\nExamples\n\n\njulia> mmedian(@nalift([11,14,12,11,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},1,Array{Nullable{Float64},1}}:\n Nullable(11.0)\n Nullable(12.5)\n Nullable(12.5)\n Nullable(12.5)\n Nullable(14.0)\n\njulia> mmedian(@nalift([11,NA,12,11,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},1,Array{Nullable{Float64},1}}:\n Nullable(11.0)\n Nullable(11.0)\n Nullable(11.5)\n Nullable(11.5)\n Nullable(12.0)\n\njulia> mmedian(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2)\n2 x 3 DictArray\n\na    b    |a    b   |a    b   \n----------+---------+---------\n11.0 10.0 |12.5 8.5 |14.0 8.5 \n12.5 8.5  |14.0 8.5 |14.5 8.5 \n\n\njulia> mmedian(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 2, 1, rev=true)\n2 x 3 LabeledArray\n\n  |1        |2        |3        \n--+---------+---------+---------\n  |a    b   |a    b   |a    b   \n--+---------+---------+---------\n1 |14.5 8.5 |14.5 8.0 |14.5 6.5 \n2 |14.5 8.0 |14.5 6.5 |16.0 5.0 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_helper_functions.jl:1043\n\n\n\n\n\n\nMultidimensionalTables.mmiddle \n\u00b6\n\n\nmmiddle(arr, dims... [; rev=false, window=0])\n for \narr\n of type \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n.\n\n\nCalculate moving middle of \narr\n using the last \nwindow\n elements, or cumulative middle if \nwindow=0\n.\n\n\nArguments\n\n\n\n\narr\n: \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n, the input array. When applied to \nDictArray\n, \nmmiddle\n is applied to each field. When applied to \nLabeledArray\n, \nmmiddle\n is applied to the base.\n\n\ndims\n: by default \ndims=(1,)\n. That is, moving middle is performed in the first direction. If \ndims=(n1, n2,...)\n, for each slice spanned along the directions \nn1\n, \nn2\n, ..., moving middle is taken along the leading dimension in \ndims\n first (i.e. \nminimum(dims)\n), and then the next dimension, and so on.\n\n\nrev\n: If \nrev=true\n, moving middle is calculated backward starting for the last elements. By default, \nrev=false\n.\n\n\nwindow\n: If \nwindow>0\n, only the last \nwindow\n elements, including the one in consideration, will be used to calculate moving middle. If \nwindow=0\n, \nmiddle\n calculates the cumulative middle. \nNA\n will be ignored.\n\n\n\n\nExamples\n\n\njulia> mmiddle(@nalift([11,14,12,11,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},1,Array{Nullable{Float64},1}}:\n Nullable(11.0)\n Nullable(12.5)\n Nullable(12.5)\n Nullable(12.5)\n Nullable(14.0)\n\njulia> mmiddle(@nalift([11,NA,12,11,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},1,Array{Nullable{Float64},1}}:\n Nullable(11.0)\n Nullable(11.0)\n Nullable(11.5)\n Nullable(11.5)\n Nullable(14.0)\n\njulia> mmiddle(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2)\n2 x 3 DictArray\n\na    b    |a    b   |a    b   \n----------+---------+---------\n11.0 10.0 |12.5 8.5 |13.0 8.0 \n12.5 8.5  |13.0 8.0 |13.5 7.5 \n\n\njulia> mmiddle(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 2, 1, rev=true)\n2 x 3 LabeledArray\n\n  |1        |2        |3        \n--+---------+---------+---------\n  |a    b   |a    b   |a    b   \n--+---------+---------+---------\n1 |13.5 7.5 |14.0 7.0 |14.5 6.5 \n2 |14.0 7.0 |14.5 6.5 |16.0 5.0 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_helper_functions.jl:1108\n\n\n\n\n\n\nMultidimensionalTables.mminimum \n\u00b6\n\n\nmminimum(arr, dims... [; rev=false, window=0])\n for \narr\n of type \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n.\n\n\nCalculate moving minimum of \narr\n using the last \nwindow\n elements, or cumulative minimum if \nwindow=0\n.\n\n\nArguments\n\n\n\n\narr\n: \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n, the input array. When applied to \nDictArray\n, \nmminimum\n is applied to each field. When applied to \nLabeledArray\n, \nmminimum\n is applied to the base.\n\n\ndims\n: by default \ndims=(1,)\n. That is, moving minimum is performed in the first direction. If \ndims=(n1, n2,...)\n, for each slice spanned along the directions \nn1\n, \nn2\n, ..., moving minimum is taken along the leading dimension in \ndims\n first (i.e. \nminimum(dims)\n), and then the next dimension, and so on.\n\n\nrev\n: If \nrev=true\n, moving minimum is calculated backward starting for the last elements. By default, \nrev=false\n.\n\n\nwindow\n: If \nwindow>0\n, only the last \nwindow\n elements, including the one in consideration, will be used to calculate moving minimum. If \nwindow=0\n, \nminimum\n calculates the cumulative minimum. \nNA\n will be ignored.\n\n\n\n\nExamples\n\n\njulia> mminimum(@nalift([15,10,12,11,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(15)\n Nullable(10)\n Nullable(10)\n Nullable(10)\n Nullable(10)\n\njulia> mminimum(@nalift([15,NA,12,11,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(15)\n Nullable(15)\n Nullable(12)\n Nullable(11)\n Nullable(11)\n\njulia> mminimum(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2)\n2 x 3 DictArray\n\na  b  |a  b |a  b \n------+-----+-----\n11 10 |11 7 |11 6 \n11 7  |11 6 |11 5 \n\n\njulia> mminimum(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 2, 1, rev=true)\n2 x 3 LabeledArray\n\n  |1    |2    |3    \n--+-----+-----+-----\n  |a  b |a  b |a  b \n--+-----+-----+-----\n1 |11 5 |12 5 |13 5 \n2 |12 5 |13 5 |16 5 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_helper_functions.jl:915\n\n\n\n\n\n\nMultidimensionalTables.mprod \n\u00b6\n\n\nmprod(arr, dims... [; rev=false, window=0])\n for \narr\n of type \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n.\n\n\nCalculate moving product of \narr\n using the last \nwindow\n elements, or cumulative product if \nwindow=0\n.\n\n\nArguments\n\n\n\n\narr\n: \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n, the input array. When applied to \nDictArray\n, \nmprod\n is applied to each field. When applied to \nLabeledArray\n, \nmprod\n is applied to the base.\n\n\ndims\n: by default \ndims=(1,)\n. That is, moving product is performed in the first direction. If \ndims=(n1, n2,...)\n, for each slice spanned along the directions \nn1\n, \nn2\n, ..., moving product is taken along the leading dimension in \ndims\n first (i.e. \nprod(dims)\n), and then the next dimension, and so on.\n\n\nrev\n: If \nrev=true\n, moving product is calculated backward starting for the last elements. By default, \nrev=false\n.\n\n\nwindow\n: If \nwindow>0\n, only the last \nwindow\n elements, including the one in consideration, will be used to calculate moving product. If \nwindow=0\n, \nprod\n calculates the cumulative product. \nNA\n will be ignored.\n\n\n\n\nExamples\n\n\njulia> mprod(@nalift([10,11,12,14,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(10)    \n Nullable(110)   \n Nullable(1320)  \n Nullable(18480) \n Nullable(314160)\n\njulia> mprod(@nalift([10,NA,12,14,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(10)   \n Nullable(10)   \n Nullable(120)  \n Nullable(1680) \n Nullable(28560)\n\njulia> mprod(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2)\n2 x 3 DictArray\n\na   b  |a     b    |a       b      \n-------+-----------+---------------\n11  10 |1848  630  |360360  30240  \n154 70 |27720 3780 |5765760 151200 \n\n\njulia> mprod(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 2, 1, rev=true)\n2 x 3 LabeledArray\n\n  |1              |2          |3      \n--+---------------+-----------+-------\n  |a       b      |a     b    |a   b  \n--+---------------+-----------+-------\n1 |5765760 151200 |37440 2160 |208 40 \n2 |524160  15120  |3120  240  |16  5  \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_helper_functions.jl:727\n\n\n\n\n\n\nMultidimensionalTables.mquantile \n\u00b6\n\n\nmquantile(arr, quantile, dims... [; rev=false, window=0])\n for \narr\n of type \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n.\n\n\nCalculate moving quantile of \narr\n using the last \nwindow\n elements, or cumulative quantile if \nwindow=0\n.\n\n\nArguments\n\n\n\n\narr\n: \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n, the input array. When applied to \nDictArray\n, \nmquantile\n is applied to each field. When applied to \nLabeledArray\n, \nmquantile\n is applied to the base.\n\n\nquantile\n: a number between 0 and 1 for the quantile to calculate.\n\n\ndims\n: by default \ndims=(1,)\n. That is, moving quantile is performed in the first direction. If \ndims=(n1, n2,...)\n, for each slice spanned along the directions \nn1\n, \nn2\n, ..., moving quantile is taken along the leading dimension in \ndims\n first (i.e. \nminimum(dims)\n), and then the next dimension, and so on.\n\n\nrev\n: If \nrev=true\n, moving quantile is calculated backward starting for the last elements. By default, \nrev=false\n.\n\n\nwindow\n: If \nwindow>0\n, only the last \nwindow\n elements, including the one in consideration, will be used to calculate moving quantile. If \nwindow=0\n, \nquantile\n calculates the cumulative quantile. \nNA\n will be ignored.\n\n\n\n\nExamples\n\n\njulia> mquantile(@nalift([11,14,12,11,17]), 0.25)\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},1,Array{Nullable{Float64},1}}:\n Nullable(11.0) \n Nullable(11.75)\n Nullable(11.75)\n Nullable(11.75)\n Nullable(12.5) \n\njulia> mquantile(@nalift([11,NA,12,11,17]), 0.25)\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},1,Array{Nullable{Float64},1}}:\n Nullable(11.0) \n Nullable(11.0) \n Nullable(11.25)\n Nullable(11.25)\n Nullable(11.5) \n\njulia> mquantile(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 0.25, 1, 2)\n2 x 3 DictArray\n\na     b    |a     b    |a     b    \n-----------+-----------+-----------\n11.0  10.0 |11.75 7.75 |12.5  7.75 \n11.75 7.75 |12.5  7.75 |13.25 7.75 \n\n\njulia> mquantile(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 0.25, 2, 1, rev=true)\n2 x 3 LabeledArray\n\n  |1          |2          |3          \n--+-----------+-----------+-----------\n  |a     b    |a     b    |a     b    \n--+-----------+-----------+-----------\n1 |13.75 7.25 |13.75 6.5  |13.75 5.75 \n2 |13.75 6.5  |13.75 5.75 |16.0  5.0  \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_helper_functions.jl:1174\n\n\n\n\n\n\nMultidimensionalTables.msum \n\u00b6\n\n\nmsum(arr, dims... [; rev=false, window=0])\n for \narr\n of type \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n.\n\n\nCalculate moving sum of \narr\n using the last \nwindow\n elements, or cumulative sum if \nwindow=0\n.\n\n\nArguments\n\n\n\n\narr\n: \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n, the input array. When applied to \nDictArray\n, \nmsum\n is applied to each field. When applied to \nLabeledArray\n, \nmsum\n is applied to the base.\n\n\ndims\n: by default \ndims=(1,)\n. That is, moving sum is performed in the first direction. If \ndims=(n1, n2,...)\n, for each slice spanned along the directions \nn1\n, \nn2\n, ..., moving sum is taken along the leading dimension in \ndims\n first (i.e. \nsum(dims)\n), and then the next dimension, and so on.\n\n\nrev\n: If \nrev=true\n, moving sum is calculated backward starting for the last elements. By default, \nrev=false\n.\n\n\nwindow\n: If \nwindow>0\n, only the last \nwindow\n elements, including the one in consideration, will be used to calculate moving sum. If \nwindow=0\n, \nsum\n calculates the cumulative sum. \nNA\n will be ignored.\n\n\n\n\nExamples\n\n\njulia> msum(@nalift([10,11,12,14,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(10)\n Nullable(21)\n Nullable(33)\n Nullable(47)\n Nullable(64)\n\njulia> msum(@nalift([10,NA,12,14,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(10)\n Nullable(10)\n Nullable(22)\n Nullable(36)\n Nullable(53)\n\njulia> msum(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2)\n2 x 3 DictArray\n\na  b  |a  b  |a  b  \n------+------+------\n11 10 |37 26 |65 40 \n25 17 |52 32 |81 45 \n\n\njulia> msum(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 2, 1, rev=true)\n2 x 3 LabeledArray\n\n  |1     |2     |3     \n--+------+------+------\n  |a  b  |a  b  |a  b  \n--+------+------+------\n1 |81 45 |56 28 |29 13 \n2 |70 35 |44 19 |16 5  \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_helper_functions.jl:642\n\n\n\n\n\n\nMultidimensionalTables.nafill \n\u00b6\n\n\nnafill(arr, dims... [; rev=false, window=0])\n for \narr\n of type \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n.\n\n\nFill forward (backward if \nrev=true\n) \narr\n using non-null values from the last \nwindow\n elements, or latest non-null value from the beginning if \nwindow=0\n.\n\n\nArguments\n\n\n\n\narr\n: \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n, the input array. When applied to \nDictArray\n, \nnafill\n is applied to each field. When applied to \nLabeledArray\n, \nnafill\n is applied to the base.\n\n\ndims\n: by default \ndims=(1,)\n. That is, the fill forward is performed along the first direction. If \ndims=(n1, n2,...)\n, for each slice spanned along the directions \nn1\n, \nn2\n, ..., the fill forward is taken along the leading dimension in \ndims\n first (i.e. \nsum(dims)\n), and then the next dimension, and so on.\n\n\nrev\n: If \nrev=true\n, the backward filling is calculated instead, starting for the last elements. By default, \nrev=false\n.\n\n\nwindow\n: If \nwindow>0\n, only the last \nwindow\n elements, including the one in consideration, will be used to fill forward. If \nwindow=0\n, \nnafill\n fills forward \narr\n using all the elements so far. \nNA\n will be ignored.\n\n\n\n\nExamples\n\n\njulia> t = @nalift([1 NA;NA 4;NA NA])\n3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)        Nullable{Int64}()\n Nullable{Int64}()  Nullable(4)      \n Nullable{Int64}()  Nullable{Int64}()\n\njulia> nafill(t)\n3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable{Int64}()\n Nullable(1)  Nullable(4)      \n Nullable(1)  Nullable(4)      \n\njulia> nafill(t,2)\n3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)        Nullable(1)      \n Nullable{Int64}()  Nullable(4)      \n Nullable{Int64}()  Nullable{Int64}()\n\njulia> nafill(t,2,1)\n3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(1)\n Nullable(1)  Nullable(4)\n Nullable(1)  Nullable(4)\n\njulia> nafill(t, rev=true)\n3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)        Nullable(4)      \n Nullable{Int64}()  Nullable(4)      \n Nullable{Int64}()  Nullable{Int64}()\n\njulia> nafill(t, window=2)\n3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)        Nullable{Int64}()\n Nullable(1)        Nullable(4)      \n Nullable{Int64}()  Nullable(4)      \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_helper_functions.jl:491\n\n\n\n\n\n\nMultidimensionalTables.nalift \n\u00b6\n\n\nnalift(arr)\n\n\nLift each element in an array \narr\n to \nNullable\n if it is not already so.\nUnlike \n@nalift\n, it does not perform lifting recursively.\nIt returns \narr\n itself when applied to a \nDictArray\n/\nLabeledArray\n.\n\n\nExamples\n\n\njulia> nalift(Any[[1,2,3],[4,5]])\n2-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Array{Int64,1}},1,Array{Nullable{Array{Int64,1}},1}}:\n Nullable([1,2,3])\n Nullable([4,5])  \n\njulia> nalift([1,2,3])\n3-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(1)\n Nullable(2)\n Nullable(3)\n\njulia> nalift(Any[[1,2,3],[4,5]])\n2-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Array{Int64,1}},1,Array{Nullable{Array{Int64,1}},1}}:\n Nullable([1,2,3])\n Nullable([4,5])  \n\njulia> nalift(darr(a=[1 2;3 4;5 6], b=[:x :y;:z :w;:u :v]))\n3 x 2 DictArray\n\na b |a b \n----+----\n1 x |2 y \n3 z |4 w \n5 u |6 v \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/na/na.jl:224\n\n\n\n\n\n\nMultidimensionalTables.namerge \n\u00b6\n\n\nnamerge(xs...)\n\n\nCombine \nNullable\n arrays and \nNullable\n elements, having the later arguments override the preceding ones if the new element is not null.\n\n\nArguments\n\n\nxs...\n consists of either a \nAbstractArrayWrapper\n with \nNullable\n element type, or a \nNullable\n variable. If an element is neither \nAbstractArray\n or \nNullable\n, it will be wrapped by \nNullable\n.\n\n\nReturn\n\n\n\n\nWhen there is no argument, an error will raise.\n\n\nIf there is only one argument, that argument will be returned.\n\n\nIf there are two arguments and if the two are not \nAbstractArray\n, the second argument will be returned only if it is not null. Otherwise, the first argument will be returned.\n\n\nIf there are two arguments, and the two are \nNullable\n arrays, the element at each position will be the one from the first argument if the second argument element is null. Otherwise, the element from the second argument will be used. If any argument is not \nAbstractArray\n, it will be promoted to a \nNullable\n array.\n\n\n\n\nExamples\n\n\n\njulia> namerge(10, @nalift([1 2 NA;4 NA NA]))\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)   Nullable(10)\n Nullable(4)  Nullable(10)  Nullable(10)\n\njulia> namerge(@nalift([1 2 NA;4 NA NA]), 10)\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(10)  Nullable(10)  Nullable(10)\n Nullable(10)  Nullable(10)  Nullable(10)\n\njulia> namerge(10, @nalift([1 2 NA;4 NA NA]))\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)   Nullable(10)\n Nullable(4)  Nullable(10)  Nullable(10)\n\njulia> namerge(@nalift([1 2 NA;4 NA NA]), @nalift([11 NA NA;14 15 NA]))\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(11)  Nullable(2)   Nullable{Int64}()\n Nullable(14)  Nullable(15)  Nullable{Int64}()\n\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:2162\n\n\n\n\n\n\nMultidimensionalTables.peel \n\u00b6\n\n\nPeel off a variable to see its underlying data.\n\n\n\n\n\n\npeel(arr::DictArray)\n: returns an \nLDict\n consisting of field name => field values array pairs.\n\n\n\n\n\n\npeel(arr::LabeledArray)\n: returns the underlying data, which can be a \nDictArray\n but can also be any \nAbstractArray\n.\n\n\n\n\n\n\nExamples\n\n\njulia> peel(darr(a=[1,2,3], b=[:m,:n,:p]))\nMultidimensionalTables.LDict{Symbol,MultidimensionalTables.AbstractArrayWrapper{T,1,A<:AbstractArray{T,N}}} with 2 entries:\n  :a => [Nullable(1),Nullable(2),Nullable(3)]\n  :b => [Nullable(:m),Nullable(:n),Nullable(:p)]\n\njulia> peel(larr(a=[1,2,3], b=[:m,:n,:p], axis1=[\"X\",\"Y\",\"Z\"]))\n3 DictArray\n\na b \n----\n1 m \n2 n \n3 p \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:763\n\n\n\n\n\n\nMultidimensionalTables.pick \n\u00b6\n\n\nPick fields from a \nDictArray\n or a \nLabeledArray\n.\n\n\n\n\npick(arr::DictArray, fieldname)\n: returns the field value array corresponding to \nfieldname\n.\n\n\npick(arr::DictArray, fieldnames::AbstractArray)\n: returns a \nDictArray\n whose field names are \nfieldnames\n.\n\n\npick(arr::DictArray, fieldnames::Tuple)\n: returns a vector of field value arrays corresponding to \nfieldnames\n.\n\n\npick(arr::DictArray, fieldnames::...)\n if there are more than 1 field name in \nfieldnames\n: returns a vector of field value arrays corresponding to the \nfieldnames\n.\n\n\npick(arr::LabeledArray, fieldname)\n: returns the field value array corresponding to \nfieldname\n. If \nfieldname\n corresponds to a field in an axis, the field value array is broadcast appropriately.\n\n\npick(arr::LabeledArray, fieldnames::AbstractArray)\n: returns a \nDictArray\n whose field names are \nfieldnames\n.\n\n\npick(arr::LabeledArray, fieldnames::Tuple)\n: returns a vector of field value arrays corresponding to \nfieldnames\n.\n\n\npick(arr::LabeledArray, fieldnames::...)\n if there are more than 1 field name in \nfieldnames\n: returns a vector of field value arrays corresponding to the \nfieldnames\n.\n\n\n\n\nExamples\n\n\njulia> pick(darr(a=[1,2,3], b=[:m,:n,:p]), :a)\n3-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(1)\n Nullable(2)\n Nullable(3)\n\njulia> pick(darr(a=[1,2,3], b=[:m,:n,:p]), (:a,))\n1-element Array{MultidimensionalTables.AbstractArrayWrapper{T,1,A<:AbstractArray{T,N}},1}:\n [Nullable(1),Nullable(2),Nullable(3)]\n\njulia> pick(darr(a=[1,2,3], b=[:m,:n,:p]), :a, :b)\n2-element Array{MultidimensionalTables.AbstractArrayWrapper{T,1,A<:AbstractArray{T,N}},1}:\n [Nullable(1),Nullable(2),Nullable(3)]   \n [Nullable(:m),Nullable(:n),Nullable(:p)]\n\njulia> pick(darr(a=[1,2,3], b=[:m,:n,:p]), (:a, :b))\n2-element Array{MultidimensionalTables.AbstractArrayWrapper{T,1,A<:AbstractArray{T,N}},1}:\n [Nullable(1),Nullable(2),Nullable(3)]   \n [Nullable(:m),Nullable(:n),Nullable(:p)]\n\njulia> t = larr(a=[1 2;3 4;5 6], b=[:x :y;:z :u;:v :w], axis1=darr(k=[\"X\",\"Y\",\"Z\"]), axis2=[:A,:B])\n3 x 2 LabeledArray\n\n  |A   |B   \n--+----+----\nk |a b |a b \n--+----+----\nX |1 x |2 y \nY |3 z |4 u \nZ |5 v |6 w \n\n\njulia> pick(t, :a)\npic3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)\n Nullable(3)  Nullable(4)\n Nullable(5)  Nullable(6)\n\njulia> pick(t, :a, :k)\n2-element Array{MultidimensionalTables.AbstractArrayWrapper{T,N,A<:AbstractArray{T,N}},1}:\n 3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)\n Nullable(3)  Nullable(4)\n Nullable(5)  Nullable(6)                                                                                                                                                                                                                                                     \n 3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{ASCIIString},2,MultidimensionalTables.BroadcastAxis{Nullable{ASCIIString},2,MultidimensionalTables.AbstractArrayWrapper{Nullable{ASCIIString},1,Array{Nullable{ASCIIString},1}},MultidimensionalTables.DictArray{Symbol,2,MultidimensionalTables.AbstractArrayWrapper{T,2,A<:AbstractArray{T,N}},Nullable{T}}}}:\n Nullable(\"X\")  Nullable(\"X\")\n Nullable(\"Y\")  Nullable(\"Y\")\n Nullable(\"Z\")  Nullable(\"Z\")\n\njulia> pick(t, (:a, :k))\n2-element Array{MultidimensionalTables.AbstractArrayWrapper{T,N,A<:AbstractArray{T,N}},1}:\n 3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)\n Nullable(3)  Nullable(4)\n Nullable(5)  Nullable(6)                                                                                                                                                                                                                                                     \n 3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{ASCIIString},2,MultidimensionalTables.BroadcastAxis{Nullable{ASCIIString},2,MultidimensionalTables.AbstractArrayWrapper{Nullable{ASCIIString},1,Array{Nullable{ASCIIString},1}},MultidimensionalTables.DictArray{Symbol,2,MultidimensionalTables.AbstractArrayWrapper{T,2,A<:AbstractArray{T,N}},Nullable{T}}}}:\n Nullable(\"X\")  Nullable(\"X\")\n Nullable(\"Y\")  Nullable(\"Y\")\n Nullable(\"Z\")  Nullable(\"Z\")\n\njulia> pick(t, [:a, :k])\n3 x 2 DictArray\n\na k |a k \n----+----\n1 X |2 X \n3 Y |4 Y \n5 Z |6 Z \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:855\n\n\n\n\n\n\nMultidimensionalTables.pickaxis \n\u00b6\n\n\nPick axes from a \nLabeledArray\n.\n\n\n\n\npickaxis(arr::LabeledArray)\n picks a tuple of axes of \narr\n.\n\n\npickaxis(arr::LabeledArray, index::Integer)\n picks the axis along the \nindex\n direction.\n\n\npickaxis(arr::LabeledArray, index::Integer, fields...)\n picks the fields \nfields\n from the \nindex\nth axis in \narr\n. It is the same as \npick(pickaxis(arr, index), fields...)\n.\n\n\n\n\nExamples\n\n\njulia> t = larr(a=[1 2;3 4;5 6], b=[:x :y;:z :u;:v :w], axis1=darr(k=[\"X\",\"Y\",\"Z\"]), axis2=[:A,:B])\n3 x 2 LabeledArray\n\n  |A   |B   \n--+----+----\nk |a b |a b \n--+----+----\nX |1 x |2 y \nY |3 z |4 u \nZ |5 v |6 w \n\n\njulia> pickaxis(t)\n(3 DictArray\n\nk \n--\nX \nY \nZ \n,[Nullable(:A),Nullable(:B)])\n\njulia> pickaxis(t, 1)\n3 DictArray\n\nk \n--\nX \nY \nZ \n\n\njulia> pickaxis(t, 1, :k)\n3-element MultidimensionalTables.AbstractArrayWrapper{Nullable{ASCIIString},1,Array{Nullable{ASCIIString},1}}:\n Nullable(\"X\")\n Nullable(\"Y\")\n Nullable(\"Z\")\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:923\n\n\n\n\n\n\nMultidimensionalTables.providenames \n\u00b6\n\n\nprovidenames(arr::LabeledArray, create_fieldname::Funcion)\n\n\nAdd generic field names for fields without field names in a \nLabeledArray\n.\nThis makes the data and all the axes components \nDictArray\ns.\nThis is useful when you want to apply \nselct\n/\nupdate\n/\nleftjoin\n/\ninnerjoin\n whose interface is friendlier to \nDictArray\ns than general \nAbstractArray\ns.\nThe reverse operation, removing generic field names, is done by \nwithdrawnames\n.\nAn optional argument \ncreate_fieldname\n is a function that gives a symbol that will be used as a new field name given an integer index.\nBy default, it generates \n:xN\n for an index integer \nN\n.\n\n\nExamples\n\n\njulia> t = larr([1 2 3;4 5 6], axis1=[:X,:Y], axis2=darr(k=[\"A\",\"B\",\"C\"]))\n2 x 3 LabeledArray\n\nk |A |B |C \n--+--+--+--\n  |  |  |  \n--+--+--+--\nX |1 |2 |3 \nY |4 |5 |6 \n\n\njulia> providenames(t)\n2 x 3 LabeledArray\n\nk  |A  |B  |C  \n---+---+---+---\nx2 |x1 |x1 |x1 \n---+---+---+---\nX  |1  |2  |3  \nY  |4  |5  |6  \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:1996\n\n\n\n\n\n\nMultidimensionalTables.rename \n\u00b6\n\n\nDescription\n\n\nrenames the fields such that the first field names are \nnames\n.\nThe rest field names remain the same.\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/labeled_array.jl:1230\n\n\n\n\n\n\nMultidimensionalTables.reorder \n\u00b6\n\n\nDescription\n\n\nreorders the fields such that the first field names are \nnames\n.\nThe rest field names are placed sequentially after that.\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/labeled_array.jl:1220\n\n\n\n\n\n\nMultidimensionalTables.replace_axes \n\u00b6\n\n\nDescription\n\n\nReplace axes with another fields.\nThe args are a list of pairs of the form (integer for the axis index) => new axes fields for this axis.\nOnly the first elements (\narr[:,...,:,1,:,...,:]\n) will be taken. That is, if the underlying data array is 2 dimensional, and\nyou want to use the field \ncolumn1\n as a new key for the 1st axis, \ncolumn1[:,1]\n will be used as the new axis.\ne.g. \nreplace_axes(labeled_array, 1=>[:c1,:c2], 3=>[:c3])\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:353\n\n\n\n\n\n\nMultidimensionalTables.selct \n\u00b6\n\n\nselct(t, agg... [; by=[...]..., where=[...]...])\n\n\nSelect a \nLabeledArray\n or \nDictArray\n into another by choosing / grouping / aggregating.\n\n\nArguments\n\n\nBelow \nt'\n is an object such that \nt'[k]\n for a field name \nk\n gives the corresponding array\nfor the field \nk\n in the table \nt\n at the coordinates selected so far.\n\n\n\n\nt\n : a \nLabeledArray\n or \nDictArray\n.\n\n\nagg...\n : each argument can be field names, fieldname=>(t'->nullable array function) pair, \nby[...]\n or \nwhere[...]\n. A fieldname=function can be used instead of the pair notation if the fieldname is a symbol.\n\n\nby=[...]\n: the first \nby=[...]\n has an array of similar expressions and determines the 1st axis. The second \nby=[...]\n similarly determines the 2nd axis. The output \nLabeledArray\n will have dimensions of the number of \nby[...]\n clauses, or the original dimensions if no \nby[...]\n is provided.\n\n\nwhere=[...]\n: has (\nt'\n->nullable boolean array) functions inside and chooses the appropriate portion of the original array. Multiple \nwhere=[...]\n will simply be combined.\n\n\n\n\nReturn\n\n\nA \nLabeledArray\n transformed by \nargs...\n if \nt\n is a \nLabeledArray\n.\nIf \nt\n is \nDictArray\n and the transformed \nLabeledArray\n has \nDefaultAxis\n along each direction, the return value is also a \nDictArray\n. Otherwise it is a \nLabeledArray\n.\n\n\nExamples\n\n\njulia> t = @larr(a=1:10, b=[1,2,3,NA,NA,NA,1,1,2,3], c=[:x,:x,:x,:x,:y,:y,:y,:z,:z,:z])\n10 LabeledArray\n\n   |a  b c \n---+-------\n1  |1  1 x \n2  |2  2 x \n3  |3  3 x \n4  |4    x \n5  |5    y \n6  |6    y \n7  |7  1 y \n8  |8  1 z \n9  |9  2 z \n10 |10 3 z \n\n\njulia> selct(t, :a, :b=>d->d[:b] .* 2)\n10 LabeledArray\n\n   |a  b \n---+-----\n1  |1  2 \n2  |2  4 \n3  |3  6 \n4  |4    \n5  |5    \n6  |6    \n7  |7  2 \n8  |8  2 \n9  |9  4 \n10 |10 6 \n\n\njulia> selct(t, :a, :b=>d->d[:b] .* 2, where=[d->d[:c] .!= :z], where=[d->d[:a] .> 2])\n5 LabeledArray\n\n  |a b \n--+----\n1 |3 6 \n2 |4   \n3 |5   \n4 |6   \n5 |7 2 \n\n\njulia> selct(t, a=d->mean(d[:a]), b=d->sum(d[:b] .* 2), by=Any[:d=>d->d[:b] .* 2], by=[:c])\n4 x 3 LabeledArray\n\nc |x     |y     |z      \n--+------+------+-------\nd |a   b |a   b |a    b \n--+------+------+-------\n  |4.0 0 |5.5 0 |       \n2 |1.0 2 |7.0 2 |8.0  2 \n4 |2.0 4 |      |9.0  4 \n6 |3.0 6 |      |10.0 6 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/select.jl:823\n\n\n\n\n\n\nMultidimensionalTables.shift \n\u00b6\n\n\nshift(arr, offsets... [; isbound=false])\n\n\nParallel shift the input array \narr\n so that the element at \n[1,...,1]\n in \narr\n shows up at \n[1,...,1]+offsets\n in the return array.\n\n\nArguments\n\n\n\n\narr\n: \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n, the input array. When applied to \nDictArray\n, \nshift\n is applied to each field. When applied to \nLabeledArray\n, \nshift\n is applied to the base.\n\n\noffsets\n: integers to denote the amount of offset for each direction. It is assumed that there is no shift in the missing direcitons.\n\n\nisbound\n: default \nfalse\n. If \ntrue\n, the index is floored and capped between 1 and the maximum possible index along that direction. If \nfalse\n, any out of bound index due to shifting results in a nullable element.\n\n\n\n\nExamples\n\n\njulia> shift(nalift([1 2 3;4 5 6;7 8 9]), 1, 1)\n3x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(5)        Nullable(6)        Nullable{Int64}()\n Nullable(8)        Nullable(9)        Nullable{Int64}()\n Nullable{Int64}()  Nullable{Int64}()  Nullable{Int64}()\n\njulia> shift(nalift([1 2 3;4 5 6;7 8 9]), 1, 01)\n3x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(5)        Nullable(6)        Nullable{Int64}()\n Nullable(8)        Nullable(9)        Nullable{Int64}()\n Nullable{Int64}()  Nullable{Int64}()  Nullable{Int64}()\n\njulia> shift(nalift([1 2 3;4 5 6;7 8 9]), 1, 1)\n3x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(5)        Nullable(6)        Nullable{Int64}()\n Nullable(8)        Nullable(9)        Nullable{Int64}()\n Nullable{Int64}()  Nullable{Int64}()  Nullable{Int64}()\n\njulia> shift(nalift([1 2 3;4 5 6;7 8 9]), 1, -1)\n3x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable{Int64}()  Nullable(4)        Nullable(5)      \n Nullable{Int64}()  Nullable(7)        Nullable(8)      \n Nullable{Int64}()  Nullable{Int64}()  Nullable{Int64}()\n\njulia> shift(darr(a=[1 2 3;4 5 6;7 8 9]), 1, -1)\n3 x 3 DictArray\n\na |a |a \n--+--+--\n  |4 |5 \n  |7 |8 \n  |  |  \n\n\njulia> shift(larr(a=[1 2 3;4 5 6;7 8 9], axis2=[:X,:Y,:Z]), 1, -1)\n3 x 3 LabeledArray\n\n  |X |Y |Z \n--+--+--+--\n  |a |a |a \n--+--+--+--\n1 |  |4 |5 \n2 |  |7 |8 \n3 |  |  |  \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_helper_functions.jl:1408\n\n\n\n\n\n\nMultidimensionalTables.tensorprod \n\u00b6\n\n\ntensorprod(arrs...)\n\n\nCalculate the tensor product of \narrs\n.\n\n\n\n\ntensorprod(::AbstractArray...)\n calculates the tensor product where the product operation creates a tuple of the input elements at each position, if every input element at that position is not \nNA\n. Otherwise, the result will be \nNA\n.\n\n\ntensorprod(::DictArray...)\n calculates the tensor product where the product operation creates a merged \nLDict\n of the input \nLDict\ns at each position.\n\n\ntensorprod(::LabeledArray...)\n calculates the tensor product of the bases of the inputs, which will be used as the base of the return \nLabeledArray\n. The axes of the return value will be appropriately extended version of the inputs.\n\n\n\n\nExamples\n\n\njulia> tensorprod(@nalift([1,2,NA]), @nalift([3,NA]))\n3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Tuple{Int64,Int64}},2,Array{Nullable{Tuple{Int64,Int64}},2}}:\n Nullable((1,3))                 Nullable{Tuple{Int64,Int64}}()\n Nullable((2,3))                 Nullable{Tuple{Int64,Int64}}()\n Nullable{Tuple{Int64,Int64}}()  Nullable{Tuple{Int64,Int64}}()\n\njulia> tensorprod(@darr(a=[1,2,NA]), @darr(b=[3,NA]))\n3 x 2 DictArray\n\na b |a b \n----+----\n1 3 |1   \n2 3 |2   \n  3 |    \n\n\njulia> tensorprod(@larr(a=[1,2,NA], axis1[:m,:n,:p]), @larr(b=[3,NA], axis1[:X,:Y]))\n3 x 2 LabeledArray\n\n  |X   |Y   \n--+----+----\n  |a b |a b \n--+----+----\nm |1 3 |1   \nn |2 3 |2   \np |  3 |    \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:1198\n\n\n\n\n\n\nMultidimensionalTables.ungroup \n\u00b6\n\n\nungroup(arr, ...)\n\n\nUngroup array elements in an array into scalar elements along some direction.\n\n\nArguments\n\n\n\n\narr\n : an array.\n\n\n...\n can be \naxis\n, \nindices\n, or \nref_field\n : either an axis index along which to ungroup, a range tuple coordinates of the form \n(i_1,...,i_k,:,i_{k+1},...,i_n)\n for some integer i's, or the selected elements of \narr\n after applying those types of tuples.\n\n\n\n\nReturn\n\n\nAn ungrouped array of the same type as \narr\n. If \narr\n is \nLabeledArray\n, the axis along the ungrouping direction will become a new field (a generic field name is provided if it was not a \nDictArray\n axis.\n\n\nExamples\n\n\njulia> t = larr(a=Any[[1,2,3],[4,5]], b=[:x,:x], c=Any[[11,12,13],[14,15]], axis1=[:X,:Y])\n2 LabeledArray\n\n  |a       b c          \n--+---------------------\nX |[1,2,3] x [11,12,13] \nY |[4,5]   x [14,15]    \n\n\njulia> ungroup(t, 1)\n5 LabeledArray\n\n  |x1 a b c  \n--+----------\n1 |X  1 x 11 \n2 |X  2 x 12 \n3 |X  3 x 13 \n4 |Y  4 x 14 \n5 |Y  5 x 15 \n\n\njulia> ungroup(t, (:,1))\n5 LabeledArray\n\n  |x1 a b c  \n--+----------\n1 |X  1 x 11 \n2 |X  2 x 12 \n3 |X  3 x 13 \n4 |Y  4 x 14 \n5 |Y  5 x 15 \n\n\njulia> m = nalift(reshape(Any[[1,2],[3,4],[5,6,7],[8,9,10]],2,2))\n2x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Array{Int64,1}},2,Array{Nullable{Array{Int64,1}},2}}:\n Nullable([1,2])  Nullable([5,6,7]) \n Nullable([3,4])  Nullable([8,9,10])\n\njulia> ungroup(m, 2)\n2x5 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)  Nullable(5)  Nullable(6)  Nullable(7) \n Nullable(3)  Nullable(4)  Nullable(8)  Nullable(9)  Nullable(10)\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/ungroup.jl:64\n\n\n\n\n\n\nMultidimensionalTables.update \n\u00b6\n\n\nupdate(t, agg... [; by=[...]..., where=[...]...])\n\n\nSimilar to \nselct\n, but is used to update and create a new \nLabeledArray\n or \nDictArray\n from the original one.\nThe main difference from the \nselct\n function is that it keeps the original fields intact, unless\ndirected otherwise, whereas the \nselect\n macro only chooses the fields that are explicitly specified.\n\n\nArguments\n\n\nBelow \nt'\n is an object such that \nt'[k]\n for a field name \nk\n gives the corresponding array\nfor the field \nk\n in the table \nt\n at the coordinates selected so far.\n\n\n\n\nt\n : a LabeledArray or \nDictArray\n.\n\n\nagg...\n : each argument can be field names, fieldname=>(t'->nullable array function) pair, \nby[...]\n or \nwhere[...]\n. A fieldname=function can be used instead of the pair notation if the fieldname is a symbol.\n\n\nby=[...]\n: \nby[...]\n has (\nt'\n->nullable array) as its elements and used as in grouping when updateing. Multiple \nby[...]\n are simply combined.\n\n\nwhere=[...]\n: has (\nt'\n->nullable boolean array) functions inside and chooses the appropriate portion of the original array. Multiple \nwhere=[...]\n will simply be combined.\n\n\n\n\nReturn\n\n\nAn updated array of the same type as \nt\n.\n\n\nExamples\n\n\njulia> t = @larr(a=1:10, b=[1,2,3,NA,NA,NA,1,1,2,3], c=[:x,:x,:x,:x,:y,:y,:y,:z,:z,:z])\n10 LabeledArray\n\n   |a  b c \n---+-------\n1  |1  1 x \n2  |2  2 x \n3  |3  3 x \n4  |4    x \n5  |5    y \n6  |6    y \n7  |7  1 y \n8  |8  1 z \n9  |9  2 z \n10 |10 3 z \n\n\njulia> update(t, a=d->d[:a] .+ 100, d=d->d[:a] .* d[:b])\n10 LabeledArray\n\n   |a   b c d  \n---+-----------\n1  |101 1 x 1  \n2  |102 2 x 4  \n3  |103 3 x 9  \n4  |104   x    \n5  |105   y    \n6  |106   y    \n7  |107 1 y 7  \n8  |108 1 z 8  \n9  |109 2 z 18 \n10 |110 3 z 30 \n\n\njulia> update(t, a=d->d[:a] .+ 100, d=d->d[:a] .* d[:b], where=[d-> ~isna(d[:b])])\n10 LabeledArray\n\n   |a   b c d  \n---+-----------\n1  |101 1 x 1  \n2  |102 2 x 4  \n3  |103 3 x 9  \n4  |4     x    \n5  |5     y    \n6  |6     y    \n7  |107 1 y 7  \n8  |108 1 z 8  \n9  |109 2 z 18 \n10 |110 3 z 30 \n\n\njulia> update(t, a=d->sum(d[:a]), d=d->reverse(d[:a] .* d[:b]), where=[d-> ~isna(d[:b])], by=[:b])\n10 LabeledArray\n\n   |a  b c d  \n---+----------\n1  |16 1 x 8  \n2  |11 2 x 18 \n3  |13 3 x 30 \n4  |4    x    \n5  |5    y    \n6  |6    y    \n7  |16 1 y 7  \n8  |16 1 z 1  \n9  |11 2 z 4  \n10 |13 3 z 9  \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/select.jl:1042\n\n\n\n\n\n\nMultidimensionalTables.withdrawnames \n\u00b6\n\n\nwithdrawnames(arr::LabeledArray, check_fieldname::Function)\n\n\nRemove generic field names from a \nLabeledArray\n if possible.\n\n\nArguments\n\n\n\n\narr\n is an input \nLabeledArray\n.\n\n\ncheck_fieldname\n is a function that returns whether an input field name is a generic name. By default, a field name is generic if it is a symbol of the form \n:xN\n for some integer \nN\n.\n\n\n\n\nReturn\n\n\nIf a field name in \nLabeledArray\n gives \ntrue\n when applied to \ncheck_fieldname\n, and the field name can be removed, it is removed in the return \nLabeledArray\n. A field name can be removed if it is a part of a \nDictArray\n with only one field.\n\n\nExamples\n\n\njulia> t = larr([1 2 3;4 5 6], axis1=[:X,:Y], axis2=darr(k=[\"A\",\"B\",\"C\"]))\n2 x 3 LabeledArray\n\nk |A |B |C \n--+--+--+--\n  |  |  |  \n--+--+--+--\nX |1 |2 |3 \nY |4 |5 |6 \n\n\njulia> providenames(t)\n2 x 3 LabeledArray\n\nk  |A  |B  |C  \n---+---+---+---\nx2 |x1 |x1 |x1 \n---+---+---+---\nX  |1  |2  |3  \nY  |4  |5  |6  \n\n\njulia> withdrawnames(providenames(t))\n2 x 3 LabeledArray\n\nk |A |B |C \n--+--+--+--\n  |  |  |  \n--+--+--+--\nX |1 |2 |3 \nY |4 |5 |6 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:2068\n\n\n\n\n\n\nrename(arr::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  ks...) \n\u00b6\n\n\nrename(arr::LabeledArray, ks...)\n\n\nRename the field names of the base of \narr\n so that the first few field names are \nks\n.\n\n\nReturn\n\n\nA new \nLabeledArray\n whose first few field names of the base of \narr\n are \nks\n.\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/labeled_array.jl:1256\n\n\n\n\n\n\nrename(ldict::MultidimensionalTables.LDict{K, V},  ks...) \n\u00b6\n\n\nrename(ldict::LDict, ks...)\n\n\nRenames the first few keys using \nks\n.\n\n\nExamples\n\n\njulia> rename(LDict(:a=>1, :b=>2, :c=>3), :b, 'x')\nMultidimensionalTables.LDict{Any,Int64} with 3 entries:\n  :b  => 1\n  'x' => 2\n  :c  => 3\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/ldict.jl:300\n\n\n\n\n\n\nreorder(arr::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  ks...) \n\u00b6\n\n\nreorder(arr::LabeledArray, ks...)\n\n\nReorder the field names of the base of \narr\n so that the first few field names are \nks\n.\nThe base of \narr\n is expected to be a \nDictArray\n.\n\n\nReturn\n\n\nA new \nLabeledArray\n whose base fields are shuffled from \narr\n so that the first few field names are \nks\n.\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/labeled_array.jl:1244\n\n\n\n\n\n\nreorder(ldict::MultidimensionalTables.LDict{K, V},  ks...) \n\u00b6\n\n\nreorder(ldict::LDict, ks...)\n\n\nReorder the keys so that the first few keys are \nks\n.\n\n\nExamples\n\n\njulia> reorder(LDict(:a=>1, :b=>2, :c=>3), :b, :c)\nMultidimensionalTables.LDict{Symbol,Int64} with 3 entries:\n  :b => 2\n  :c => 3\n  :a => 1\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/ldict.jl:281\n\n\n\n\n\n\nreplace_axes(arr::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  args...) \n\u00b6\n\n\nreplace_axes(arr::LabeledArray, args...)\n\n\nArguments\n\n\n\n\narr\n: an input \nLabeledArray\n. Note the data part of \narr\n and the axis to replace need to be \nDictArray\ns.\n\n\nargs...\n: arguments in \nargs\n are of the form \ni=>[f1,f2,...]\n for some integer \ni\n and field names \nf*\n.\n\n\n\n\nReturns\n\n\nFor each \ni=>[f1,f2,...]\n in \nargs\n, the \ni\nth axis is replaced by the fields \nf1\n, \nf2\n, ....\nOnly the first elements will be taken. For example, if the underlying data array is 2 dimensional, and if you want to use some field for the 1st axis, \n[:,1]\n components will be used.\nThe original axis becomes the data part of \nLabeledArray\n after properly broadcast.\nIf the field name array is null for an argument in \nargs\n (\ni=>[]\n), the corresponding axis will be \nDefaultAxis\n.\n\n\nExamples\n\n\njulia> t = larr(a=[1 2 3;4 5 6], b=['a' 'b' 'c';'d' 'e' 'f'], axis1=darr(k=[:x,:y]), axis2=[\"A\",\"B\",\"C\"])\n2 x 3 LabeledArray\n\n  |A   |B   |C   \n--+----+----+----\nk |a b |a b |a b \n--+----+----+----\nx |1 a |2 b |3 c \ny |4 d |5 e |6 f \n\n\njulia> replace_axes(t, 1=>[:a])\n2 x 3 LabeledArray\n\n  |A   |B   |C   \n--+----+----+----\na |b k |b k |b k \n--+----+----+----\n1 |a x |b x |c x \n4 |d y |e y |f y \n\n\njulia> replace_axes(t, 1=>[:a, :b])\n2 x 3 LabeledArray\n\n    |A |B |C \n----+--+--+--\na b |k |k |k \n----+--+--+--\n1 a |x |x |x \n4 d |y |y |y \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:407\n\n\n\n\n\n\nMultidimensionalTables.DictArray{K, N, VS, SV} \n\u00b6\n\n\nA multidimensional array whose elements are ordered dictionaries with common keys.\nInternally, it is represented as an ordered dictionary from keys to multidimensional arrays.\nNote that most functions return a new \nDictArray\n rather than modify the existing one.\nHowever, the new \nDictArray\n just shallow copies the key vector and the value vector\nof the underlying \nLDict\n. Therefore, creating a new \nDictArray\n is cheap, but you have to be\ncareful when you modify the underlying array elements directly.\n\n\nBecause a \nDictArray\n can be multidimensional we will call the keys in the key vector of the underlying \nLDict\n the \nfield names\n.\nThe values in the value vector will be called \nfields\n. With a slight bit of abuse of notation, we sometimes call a field name and a field tuple collectively just a field.\n\n\nUse the function \ndarr\n to construct a \nDictArray\n.\n\n\nConstructors\n\n\nDictArraay is internally just a wrapper of \nLDict\n. Therefore, the constructors takes the same kind of arguments:\n\n\nDictArray(data::LDict{K,V})\nDictArray{K,V}(dict::Dict{K,V})\nDictArray{K,V}(dict::Dict{K,V}, ks)\nDictArray{K}(ks::Vector{K}, vs::Vector)\nDictArray(ps::Pair...)\nDictArray(tuples::Tuple...)\nDictArray(;kwargs...)\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:31\n\n\n\n\n\n\nMultidimensionalTables.EnumerationArray{T, N, V, R<:Integer} \n\u00b6\n\n\nAn array type to store elements that have only a few choices.\nThat is, it is a pooled array.\nUse \nenumeration\n to create an \nEnumerationArray\n.\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/enumeration_array.jl:8\n\n\n\n\n\n\nMultidimensionalTables.LDict{K, V} \n\u00b6\n\n\nLDict is an ordered dictionary. It is assumed to be used in the field name => field mapping. In practice, the number of columns is not that long, and it is more efficient to implement LDict as 2 vectors, one for keys and one for values.\n\n\nConstructors\n\n\nLDict{K,V}(dict::Associative{K, V}) # LDict from a dictionary dict. The result order is undetermined.\nLDict{K,V}(dict::Associative{K, V}, ks) # LDict from a dictionary dict. ks is a vector of keys, and the keys in the result are ordered in that way. An error is thrown if one of ks is not found in dict.\nLDict{K,V}(ks::Vector{K}, vs::Vector{V})\nLDict(ps::Pair...)\nLDict(ps::Tuple...)\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/ldict.jl:18\n\n\n\n\n\n\nMultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN} \n\u00b6\n\n\nA multidimensional array together with additional axes attached to it.\nEach axis is a one dimensional array, possibly a \nDictArray\n.\nUse the function \nlarr\n or a macro version \n@larr\n to create \nLabeledArray\ns, rather than call the constructor directly.\n\n\nA \nLabeledArray\n consists of one main array, which we call the \nbase\n array, and an axis array for each direction.\n\n\nConstructors\n\n\n\n\nLabeledArray(arr, axes)\n creates a \nLabeledArray\n from a \nbase\n array \narr\n and a tuple \naxes\n of one dimensional arrays for axes.\n\n\nLabeledArray(arr; kwargs...)\n creates a \nLabeledArray\n from a \nbase\n array \narr\n and a keyword argument of the form \naxisN=V\n for some integer \nN\n for the axis direction and a one dimensional array \nV\n.\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/labeled_array.jl:16\n\n\n\n\n\n\n@darr(args...) \n\u00b6\n\n\n@darr(...)\n\n\nCreate a \nDictArray\n. The arguments \n...\n can be one of the following:\n\n\nArguments\n\n\n\n\nk=>v\n creates a field using an array \nv\n with field name \nk\n. \nk\n can be an arbitrary type. If the element type of \nv\n is not \nNullable\n, each element will be wrapped by \nNullable\n. If \nNA\n is provided as an element, it is translated as \nNullable{T}()\n for an appropriate type \nT\n.\n\n\nk=v\n creates a field using an array \nv\n with field name \n:k\n.\n\n\nThere can be at most one non pair type argument, which will be converted into a \nDictArray\n and other pair arguments will update it.\n\n\n\n\nExamples\n\n\njulia> t = @darr(a=[1 2;NA 4;5 NA],b=[\"abc\" NA;1 2;:m \"xyz\"],:c=>[NA 1.5;:sym 'a';\"X\" \"Y\"])\n3 x 2 DictArray\n\na b   c   |a b   c   \n----------+----------\n1 abc     |2     1.5 \n  1   sym |4 2   a   \n5 m   X   |  xyz Y   \n\n\njulia> @darr(t, c=[1 2;3 4;5 6], \"d\"=>map(Nullable, [1 2;3 4;5 6]))\n3 x 2 DictArray\n\na b   c d |a b   c d \n----------+----------\n1 abc 1 1 |2     2 2 \n  1   3 3 |4 2   4 4 \n5 m   5 5 |  xyz 6 6 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:1209\n\n\n\n\n\n\n@enumeration(args...) \n\u00b6\n\n\n@enumeration(arr [, poolorder])\n\n\nCreate an \nEnumerationArray\n. Similar to the \nenumeration\n function, but you can type in a null element using \nNA\n.\n\n\nArguments\n\n\n\n\narr\n: an input array of \nNullable\n element type. It is assumed that there are only a few possible values in \narr\n and each value is converted into an integer when creating an \nEnumerationArray\n. \nNA\n is translated into a null element of appropriate type.\n\n\npoolorder\n: a vector to fix some of the integer values in the mapping from the values in \narr\n to integers. If there are \nn\n elements in \npoolorder\n, those \nn\n elements in \narr\n will be assigned 1...\nn\n when creating an \nEnumerationArray\n. All the others are assigned integers in order of their appearance.\n\n\n\n\nExamples\n\n\njulia> @enumeration([:A,:A,:B,NA,NA])\n5-element MultidimensionalTables.EnumerationArray{Symbol,1,MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}},Int64}:\n Nullable(:A)      \n Nullable(:A)      \n Nullable(:B)      \n Nullable{Symbol}()\n Nullable{Symbol}()\n\njulia> @enumeration([:A,:A,:B,NA,NA]).pool\n2-element Array{Symbol,1}:\n :A\n :B\n\njulia> @enumeration([:A,:A,:B,NA,NA]).elems\n5-element MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}}:\n 1\n 1\n 2\n 0\n 0\n\njulia> @enumeration([:A,:A,:B,NA,NA], [:B,:A])\n5-element MultidimensionalTables.EnumerationArray{Symbol,1,MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}},Int64}:\n Nullable(:A)      \n Nullable(:A)      \n Nullable(:B)      \n Nullable{Symbol}()\n Nullable{Symbol}()\n\njulia> @enumeration([:A,:A,:B,NA,NA], [:B,:A]).pool\n2-element Array{Symbol,1}:\n :B\n :A\n\njulia> @enumeration([:A,:A,:B,NA,NA], [:B,:A]).elems\n5-element MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}}:\n 2\n 2\n 1\n 0\n 0\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/enumeration_array.jl:247\n\n\n\n\n\n\n@larr(args...) \n\u00b6\n\n\n@larr(...)\n\n\nCreate a \nLabeledArray\n. The arguments \n...\n can be one of the following:\n\n\nArguments\n\n\n\n\nk=>v\n creates a field using array \nv\n with field name \nk\n for the base of the return \nLabeledArray\n. \nk\n can be an arbitrary type. If the element type of \nv\n is not \nNullable\n, each element will be wrapped by \nNullable\n. If \nNA\n is provided as an element, it is translated as \nNullable{T}()\n for an appropriate type \nT\n.\n\n\nk=v\n creates a field using array \nv\n of the base with field name \n:k\n.\n\n\nThere can be at most one non pair type argument, which will be converted into a \nLabeledArray\n and other pair arguments will update it.\n\n\naxisN[...]\n for some integer \nN\n: this creates an axis along the \nN\nth direction. If \n...\n are either keywords or pairs, those are used to create a \nDictArray\n. Otherwise, an array will be created using \n...\n.\n\n\n\n\nExamples\n\n\njulia> t = @larr(a=[1 NA;3 4;NA NA],:b=>[1.0 1.5;:sym 'a';\"X\" \"Y\"],c=1,axis1[:U,NA,:W],axis2[r=['m','n']])\n3 x 2 LabeledArray\n\nr |m       |n       \n--+--------+--------\n  |a b   c |a b   c \n--+--------+--------\nU |1 1.0 1 |  1.5 1 \n  |3 sym 1 |4 a   1 \nW |  X   1 |  Y   1 \n\n\njulia> @larr(t, c=[NA NA;3 4;5 6], :d=>:X, axis1[k=[\"g\",\"h\",\"i\"]])\n3 x 2 LabeledArray\n\nr |m         |n         \n--+----------+----------\nk |a b   c d |a b   c d \n--+----------+----------\ng |1 1.0   X |  1.5   X \nh |3 sym 3 X |4 a   4 X \ni |  X   5 X |  Y   6 X \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/labeled_array.jl:1299\n\n\n\n\n\n\n@nalift(expr) \n\u00b6\n\n\n@nalift(arr)\n\n\nLift each element in an array \narr\n to \nNullable\n if it is not already so.\nIt is mainly used to translate a manually typed array expression such as \n[1,2,3,NA,5]\n into a \nNullable\n array.\nUnlike \nnalift\n, it performs lifting recursively.\nIt returns \narr\n itself when applied to a \nDictArray\n/\nLabeledArray\n.\n\n\nExamples\n\n\njulia> @nalift([1,2,3])\n3-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(1)\n Nullable(2)\n Nullable(3)\n\njulia> @nalift([1,2,NA])\n3-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(1)      \n Nullable(2)      \n Nullable{Int64}()\n\njulia> @nalift(Any[[1,2,3],[NA,5]])\n2-element MultidimensionalTables.AbstractArrayWrapper{Nullable{MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}},1,Array{Nullable{MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}},1}}:\n Nullable([Nullable(1),Nullable(2),Nullable(3)])\n Nullable([Nullable{Int64}(),Nullable(5)])      \n\njulia> @nalift(larr(a=[1 2;3 4;5 6], b=[:x :y;:z :w;:u :v]))\n3 x 2 LabeledArray\n\n  |1   |2   \n--+----+----\n  |a b |a b \n--+----+----\n1 |1 x |2 y \n2 |3 z |4 w \n3 |5 u |6 v \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/na/na.jl:335\n\n\n\n\n\n\n@rap(args...) \n\u00b6\n\n\n@rap(args...)\n\n\nApply right-to-left evaluation order to the arguments.\nAn argument having an underscore symbol except the last one is translated into the function \nx\n->(that expression replacing _ by \nx\n).\n\n\nExamples\n\n\njulia> @rap _+3 5\n8\n\njulia> @rap _*2 x->x+1 10\n22\n\njulia> @rap (_ .* 2) reverse @nalift [1,2,NA,4,5]\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(10)     \n Nullable(8)      \n Nullable{Int64}()\n Nullable(4)      \n Nullable(2)      \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:282\n\n\n\n\n\n\n@select(t, args...) \n\u00b6\n\n\n@select(t, args...)\n\n\nSelect macro transforms a \nLabeledArray\n or \nDictArray\n into another by choosing / grouping / aggregating.\n\n\nArguments\n\n\nBelow \nt'\n is an object such that \nt'[k]\n for a field name \nk\n gives the corresponding array\nfor the field \nk\n in the table \nt\n at the coordinates selected so far.\n\n\n\n\nt\n : a \nLabeledArray\n or \nDictArray\n.\n\n\nargs...\n : each argument can be field names, fieldname=>(t'->nullable array function) pair, \nby[...]\n or \nwhere[...]\n. A fieldname=function can be used instead of the pair notation if the fieldname is a symbol. The first \nby[...]\n has an array of similar expressions and determines the 1st axis. The second \nby[...]\n similarly determines the 2nd axis. The output \nLabeledArray\n will have dimensions of the number of \nby[...]\n clauses, or the original dimensions if no \nby[...]\n is provided. \nwhere[...]\n has (\nt'\n->nullable boolean array) functions inside and chooses the appropriate portion of the original array. Multiple \nwhere[...]\n will simply be combined.\n\n\n\n\nFunction Specification\n\n\nNote that a function (\nt'\n->nullable array) is expressed by some \nexpression\n with variable names with underscores. The \nexpression\n is converted into `t''->\nexpression\n. Symbols with underscores are converted in the following way:\n\n\n\n\n_k\n : translates to \nt'[k]\n. The field name \nk\n should be a symbol.\n\n\n_!k\n : translates to \nisna(t')[k]\n. It gives a boolean array to denote whether an element is null. The field name \nk\n should be a symbol.\n\n\n_\n : translates to \nt'\n if none of the above is applicable. It is useful when the field name is not a symbol.\n\n\n\n\nReturn\n\n\nA \nLabeledArray\n transformed by \nargs...\n if \nt\n is a \nLabeledArray\n.\nIf \nt\n is \nDictArray\n and the transformed \nLabeledArray\n has \nDefaultAxis\n along each direction, the return value is also a \nDictArray\n. Otherwise it is a \nLabeledArray\n.\n\n\nExamples\n\n\njulia> t = @larr(a=1:10, b=[1,2,3,NA,NA,NA,1,1,2,3], c=[:x,:x,:x,:x,:y,:y,:y,:z,:z,:z])\n10 LabeledArray\n\n   |a  b c \n---+-------\n1  |1  1 x \n2  |2  2 x \n3  |3  3 x \n4  |4    x \n5  |5    y \n6  |6    y \n7  |7  1 y \n8  |8  1 z \n9  |9  2 z \n10 |10 3 z \n\n\njulia> @select(t, :a, :b=>_b .* 2)\n10 LabeledArray\n\n   |a  b \n---+-----\n1  |1  2 \n2  |2  4 \n3  |3  6 \n4  |4    \n5  |5    \n6  |6    \n7  |7  2 \n8  |8  2 \n9  |9  4 \n10 |10 6 \n\n\njulia> @select(t, :a, :b=>_b .* 2, where[_c .!= :z], where[_a .> 2])\n5 LabeledArray\n\n  |a b \n--+----\n1 |3 6 \n2 |4   \n3 |5   \n4 |6   \n5 |7 2 \n\n\njulia> @select(t, a=mean(_a), b=sum(_b .* 2), by[d=_b .* 2], by[:c])\n4 x 3 LabeledArray\n\nc |x     |y     |z      \n--+------+------+-------\nd |a   b |a   b |a    b \n--+------+------+-------\n  |4.0 0 |5.5 0 |       \n2 |1.0 2 |7.0 2 |8.0  2 \n4 |2.0 4 |      |9.0  4 \n6 |3.0 6 |      |10.0 6 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/select.jl:734\n\n\n\n\n\n\n@update(t, args...) \n\u00b6\n\n\n@update(t, args...)\n\n\nSimilar to \nselect\n macro, but is used to update and create a new \nLabeledArray\n or \nDictArray\n from the original one.\nThe main difference from the \nselect\n macro is that it keeps the original fields intact, unless\ndirected otherwise, whereas the \nselect\n macro only chooses the fields that are explicitly specified.\n\n\nArguments\n\n\nBelow \nt'\n is an object such that \nt'[k]\n for a field name k gives the corresponding array\nfor the field \nk\n in the table \nt\n at the coordinates selected so far.\n\n\n\n\nt\n : a \nLabeledArray\n or \nDictArray\n.\n\n\nargs...\n : each argument can be field names, fieldname=>(\nt'\n->nullable array function) pair or \nwhere[...]\n. A fieldname=function can be used instead of the pair notation if the fieldname is a symbol. \nby[...]\n has (\nt'\n->nullable array) as its elements and used as in grouping when updateing. Multiple \nby[...]\n are simply combined. \nwhere[...]\n has\n(\nt'\n->nullable boolean array) functions inside and chooses the appropriate portion of the original array. Multiple \nwhere[...]\n will simply be combined.\n\n\n\n\nFunction Specification\n\n\nNote that a function (\nt'\n->nullable array) is expressed by some \nexpression\n with variable names with underscores. The \nexpression\n is converted into `t''->\nexpression\n. Symbols with underscores are converted in the following way:\n\n\n\n\n_k\n : translates to \nt'[k]\n. The field name \nk\n should be a symbol.\n\n\n_!k\n : translates to \nisna(t')[k]\n. It gives a boolean array to denote whether an element is null. The field name \nk\n should be a symbol.\n\n\n_\n : translates to \nt'\n if none of the above is applicable. It is useful when the field name is not a symbol.\n\n\n\n\nReturn\n\n\nAn updated array of the same type as \nt\n.\n\n\nExamples\n\n\njulia> t = @larr(a=1:10, b=[1,2,3,NA,NA,NA,1,1,2,3], c=[:x,:x,:x,:x,:y,:y,:y,:z,:z,:z])\n10 LabeledArray\n\n   |a  b c \n---+-------\n1  |1  1 x \n2  |2  2 x \n3  |3  3 x \n4  |4    x \n5  |5    y \n6  |6    y \n7  |7  1 y \n8  |8  1 z \n9  |9  2 z \n10 |10 3 z \n\n\njulia> @update(t, a=_a .+ 100, d=_a .* _b)\n10 LabeledArray\n\n   |a   b c d  \n---+-----------\n1  |101 1 x 1  \n2  |102 2 x 4  \n3  |103 3 x 9  \n4  |104   x    \n5  |105   y    \n6  |106   y    \n7  |107 1 y 7  \n8  |108 1 z 8  \n9  |109 2 z 18 \n10 |110 3 z 30 \n\n\njulia> @update(t, a=_a .+ 100, d=_a .* _b, where[~isna(_b)])\n10 LabeledArray\n\n   |a   b c d  \n---+-----------\n1  |101 1 x 1  \n2  |102 2 x 4  \n3  |103 3 x 9  \n4  |4     x    \n5  |5     y    \n6  |6     y    \n7  |107 1 y 7  \n8  |108 1 z 8  \n9  |109 2 z 18 \n10 |110 3 z 30 \n\n\njulia> @update(t, a=sum(_a), d=reverse(_a .* _b), where[~isna(_b)], by[:b])\n10 LabeledArray\n\n   |a  b c d  \n---+----------\n1  |16 1 x 8  \n2  |11 2 x 18 \n3  |13 3 x 30 \n4  |4    x    \n5  |5    y    \n6  |6    y    \n7  |16 1 y 7  \n8  |16 1 z 1  \n9  |11 2 z 4  \n10 |13 3 z 9  \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/select.jl:943\n\n\nInternal\n\n\n\n\n\n\nMultidimensionalTables.create_dict \n\u00b6\n\n\ncreate_dict(::LabeledArray)\n\n\nCreate a nested \nDict\n from a \nLabeledArray\n.\n\n\nExamples\n\n\njulia> t = larr(a=[1 2;3 4], axis1=[:x,:y], axis2=[\"A\",\"B\"])\n2 x 2 LabeledArray\n\n  |  |A B \n--+--+----\nx |a |1 2 \n--+--+----\ny |a |3 4 \n\n\njulia> create_dict(t)\nDict{Nullable{Symbol},Dict{Nullable{ASCIIString},MultidimensionalTables.LDict{Symbol,Nullable{Int64}}}} with 2 entries:\n  Nullable(:y) => Dict(Nullable(\"B\")=>MultidimensionalTables.LDict(:a=>Nullable(4)),Nullable(\"A\")=>MultidimensionalTables.LDict(:a=>Nullable(3)))\n  Nullable(:x) => Dict(Nullable(\"B\")=>MultidimensionalTables.LDict(:a=>Nullable(2)),Nullable(\"A\")=>MultidimensionalTables.LDict(:a=>Nullable(1)))\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/labeled_array.jl:1063\n\n\n\n\n\n\nMultidimensionalTables.gdrop \n\u00b6\n\n\ngdrop(arr, N1, N2, ...)\n\n\nDrop a block of an array. similar to \ndrop\n in one dimensional case, but is slightly different and more general.\nIt can also be applied to an \nLDict\n.\nIt drops the first \nN1\n elements along direction 1, and similarly for other directions. Drops from rear if \nN*\n is negative.\n\n\nExamples\n\n\njulia> t = larr(a=rand(5,3), b=reshape(1:15,5,3), axis1=[:X,:Y,:Z,:U,:V])\n5 x 3 LabeledArray\n\n  |1                     |2                      |3                      \n--+----------------------+-----------------------+-----------------------\n  |a                   b |a                   b  |a                   b  \n--+----------------------+-----------------------+-----------------------\nX |0.27289790581491746 1 |0.8493197848353495  6  |0.8370920536703472  11 \nY |0.8424940964507834  2 |0.21518951524950136 7  |0.9290437789813346  12 \nZ |0.9498541774517255  3 |0.942687447396005   8  |0.1341678643795654  13 \nU |0.7356663426240728  4 |0.7662948222160162  9  |0.24109069576951692 14 \nV |0.8716491751450759  5 |0.27472373001295436 10 |0.08909928028262804 15 \n\n\njulia> gdrop(t, 3, 2)\n2 x 1 LabeledArray\n\n  |1                      \n--+-----------------------\n  |a                   b  \n--+-----------------------\nU |0.24109069576951692 14 \nV |0.08909928028262804 15 \n\n\njulia> gdrop(t, 5)\n0 x 3 LabeledArray\n\n |1   |2   |3   \n-+----+----+----\n |a b |a b |a b \n\n\njulia> gdrop(t, -3, -2)\n2 x 1 LabeledArray\n\n  |1                     \n--+----------------------\n  |a                   b \n--+----------------------\nX |0.27289790581491746 1 \nY |0.8424940964507834  2 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:1516\n\n\n\n\n\n\nMultidimensionalTables.gtake \n\u00b6\n\n\ngtake(arr, N1, N2, ...)\n\n\nTake a block of an array. similar to \ntake\n in one dimensional case, but is slightly different and more general.\nIt can also be applied to an \nLDict\n.\nIt takes first \nN1\n elements along direction 1, and similarly for other directions. Repeats if the number of elements are less than \nN*\n. Picks from rear if \nN*\n is negative.\n\n\nExamples\n\n\njulia> t = larr(a=rand(5,3), b=reshape(1:15,5,3), axis1=[:X,:Y,:Z,:U,:V])\n5 x 3 LabeledArray\n\n  |1                     |2                      |3                      \n--+----------------------+-----------------------+-----------------------\n  |a                   b |a                   b  |a                   b  \n--+----------------------+-----------------------+-----------------------\nX |0.3219487839233375  1 |0.4863723989946185  6  |0.8784616074632225  11 \nY |0.04069063166302023 2 |0.06614308437642014 7  |0.31870618693881947 12 \nZ |0.7855545407740521  3 |0.5208010912357377  8  |0.4421485355996708  13 \nU |0.8134241459627629  4 |0.8256022894268482  9  |0.3127049127123851  14 \nV |0.8536688845922342  5 |0.7263660648355621  10 |0.9315379228053462  15 \n\n\njulia> gtake(t, 3, 2)\n3 x 2 LabeledArray\n\n  |1                     |2                     \n--+----------------------+----------------------\n  |a                   b |a                   b \n--+----------------------+----------------------\nX |0.3219487839233375  1 |0.4863723989946185  6 \nY |0.04069063166302023 2 |0.06614308437642014 7 \nZ |0.7855545407740521  3 |0.5208010912357377  8 \n\n\njulia> gtake(t, 3, 4)\n3 x 4 LabeledArray\n\n  |1                     |2                     |3                      |4                     \n--+----------------------+----------------------+-----------------------+----------------------\n  |a                   b |a                   b |a                   b  |a                   b \n--+----------------------+----------------------+-----------------------+----------------------\nX |0.3219487839233375  1 |0.4863723989946185  6 |0.8784616074632225  11 |0.3219487839233375  1 \nY |0.04069063166302023 2 |0.06614308437642014 7 |0.31870618693881947 12 |0.04069063166302023 2 \nZ |0.7855545407740521  3 |0.5208010912357377  8 |0.4421485355996708  13 |0.7855545407740521  3 \n\n\njulia> gtake(t, -2, -1)\n2 x 1 LabeledArray\n\n  |1                     \n--+----------------------\n  |a                  b  \n--+----------------------\nU |0.3127049127123851 14 \nV |0.9315379228053462 15 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:1303\n\n\n\n\n\n\nMultidimensionalTables.selectfield \n\u00b6\n\n\nselectfield(t, fld, inds)\n : select a field whose name is \nfld\n at cartesian coordinates \ninds\n in a LabeledArray \nt\n.\nIf \ninds\n is \nnothing\n, it chooses an entire \nfld\n from \nt\n.\n\n\nsource:\n\n\nMultidimensionalTables/src/util/select.jl:502\n\n\n\n\n\n\nMultidimensionalTables.setna! \n\u00b6\n\n\nsetna!(arr, args...)\n\n\nSet the element of an array \narr\n at \nargs\n to \nNA\n.\nIf \nargs...\n is omitted, all elements are set to \nNA\n.\n\n\n\n\nIf \narr\n is an array of element type \nNullable{T}\n, \nNA\n means \nNullable{T}()\n.\n\n\nIf \narr\n is a \nDictArray\n, \nNA\n means all fields at that position are \nNA\n.\n\n\nIf \narr\n is a \nLabeledArray\n, \nNA\n means the base of \narr\n at that position is \nNA\n.\n\n\n\n\nExamples\n\n\njulia> setna!(@nalift([1,2,NA,4,5]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable{Int64}()\n Nullable{Int64}()\n Nullable{Int64}()\n Nullable{Int64}()\n Nullable{Int64}()\n\njulia> setna!(@nalift([1,2,NA,4,5]), 2)\n5-element Array{Nullable{Int64},1}:\n Nullable(1)      \n Nullable{Int64}()\n Nullable{Int64}()\n Nullable(4)      \n Nullable(5)      \n\njulia> setna!(@darr(a=[1 2 NA;4 5 6], b=[:x :y :z;:u :v :w]), 1:2, 1)\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n    |2 y |  z \n    |5 v |6 w \n\n\njulia> setna!(larr(a=[1 2 3;4 5 6], b=[:x :y :z;:u :v :w], axis1=[:X,:Y]), 1, 2:3)\n2 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nX |1 x |    |    \nY |4 u |5 v |6 w \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/na/na.jl:414\n\n\n\n\n\n\nMultidimensionalTables.type_array \n\u00b6\n\n\ntype_array(arr)\n\n\ntype_array\n finds the most constraining type of the elements of an array \narr\n, and converts the array element type.\nSometimes, an array is given type \nArray{Any}\n, even though the components are all Float64, for example.\n\ntype_array\n will convert the type into the most constraining one.\n\n\nArguments\n\n\n\n\narr::AbstractArray\n: an abstract array whose element type will be constrained by \ntype_array\n.\n\n\n\n\nReturns\n\n\nAn array with the same elements as in \narr\n, but the element type has been constrained just enough to contain all elements.\n\n\nExamples\n\n\njulia> type_array(Any[1, 3.0, 2])\n3-element Array{Float64,1}:\n 1.0\n 3.0\n 2.0\n\njulia> type_array(Any[1, 3.0, 'x'])\n3-element Array{Any,1}:\n 1   \n 3.0 \n  'x'\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_util.jl:34\n\n\n\n\n\n\ndiff \n\u00b6\n\n\ndiff(arr, dims... [; rev=false])\n for \narr\n of type \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n.\n\n\nTake the difference between adjacent elements of \narr\n along the directions belonging to the integers \ndims\n.\nNote that \ndiff\n applied to \nAbstractArrayWrapper\n (or to \nLabeledArray\n or \nDictArray\n by extension) will have the same shape as the original array. The first elements will be the first elements of the input array. This will ensure cumsum(diff(arr)) == diff(cumsum(arr)) == arr if there is no \nNullable\n element.\n\n\nArguments\n\n\n\n\narr\n: \nAbstractArrayWrapper\n/\nLabeledArray\n/\nDictArray\n, the input array. When applied to \nDictArray\n, \ndiff\n is applied to each field. When applied to \nLabeledArray\n, \ndiff\n is applied to the base.\n\n\ndims\n: by default \ndims=(1,)\n. That is, difference is calculated along the first direction. If \ndims=(n1, n2,...)\n, for each slice spanned along the directions \nn1\n, \nn2\n, ..., difference is taken along the leading dimension in \ndims\n first (i.e. \nsum(dims)\n), and then the next dimension, and so on.\n\n\nrev\n: If \nrev=true\n, difference is taken backward starting for the last elements. By default, \nrev=false\n.\n\n\n\n\nExamples\n\n\njulia> diff(@nalift([10,NA,12,14,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(10)     \n Nullable{Int64}()\n Nullable{Int64}()\n Nullable(2)      \n Nullable(3)      \n\njulia> diff(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2)\n2 x 3 DictArray\n\na  b  |a  b  |a  b  \n------+------+------\n11 10 |-2 2  |-2 2  \n3  -3 |3  -3 |3  -3 \n\n\njulia> diff(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2, rev=true)\n2 x 3 DictArray\n\na  b  |a  b  |a  b \n------+------+-----\n-3 3  |-3 3  |-3 3 \n2  -2 |2  -2 |16 5 \n\n\njulia> diff(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2, rev=true)\n2 x 3 LabeledArray\n\n  |1     |2     |3    \n--+------+------+-----\n  |a  b  |a  b  |a  b \n--+------+------+-----\n1 |-3 3  |-3 3  |-3 3 \n2 |2  -2 |2  -2 |16 5 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_helper_functions.jl:574\n\n\n\n\n\n\nallfieldnames(arr::MultidimensionalTables.DictArray{K, N, VS, SV}) \n\u00b6\n\n\nallfieldnames(::DictArray)\n\n\nReturn all field names in the input \nDictArray\n, which are just the keys in the underlying \nLDict\n.\n\n\nExamples\n\n\njulia> allfieldnames(darr(a=reshape(1:6,3,2),b=rand(3,2)))\n2-element Array{Symbol,1}:\n :a\n :b\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:535\n\n\n\n\n\n\nallfieldnames(table::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN}) \n\u00b6\n\n\nreturns all field names for LabeledArray or DictArray. Returns an empty array for other types of arrays.\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/labeled_array.jl:754\n\n\n\n\n\n\ncat(catdim::Integer,  arr1::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  arrs::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN}...) \n\u00b6\n\n\ncat(catdim::Integer, arrs::LabeledArray...)\n\n\nConcatenate \nLabeledArray\ns \narrs\n along the \ncatdim\n direction.\nThe base of each element of \narrs\n are concatenated and become the new base of the return \nLabeledArray\n.\nThe axes of each of \narrs\n not along the \ncatdim\n direction should be identical. Otherwise, there will be an error.\nThe axis along the \ncatdim\n direction will be the concatenation of the axis of each of \narrs\n along that direction.\n\n\njulia> t1 = larr(a=[1 2 3;4 5 6], axis1=[:x,:y], axis2=[\"A\",\"B\",\"C\"])\nt2 x 3 LabeledArray\n\n  |  |A B C \n--+--+------\nx |a |1 2 3 \n--+--+------\ny |a |4 5 6 \n\n\njulia> t2 = larr(a=[11 12 13;14 15 16], axis1=[:x,:y], axis2=[\"D\",\"E\",\"F\"])\n2 x 3 LabeledArray\n\n  |  |D  E  F  \n--+--+---------\nx |a |11 12 13 \n--+--+---------\ny |a |14 15 16 \n\n\njulia> cat(2, t1, t2)\n2 x 6 LabeledArray\n\n  |  |A B C D  E  F  \n--+--+---------------\nx |a |1 2 3 11 12 13 \n--+--+---------------\ny |a |4 5 6 14 15 16 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/labeled_array.jl:804\n\n\n\n\n\n\ncat(catdim::Integer,  arrs::MultidimensionalTables.DictArray{K, N, VS, SV}...) \n\u00b6\n\n\ncat(catdim::Integer, arrs::DictArray...)\n\n\nConcatenate the \nDictArray\ns \narrs\n along the \ncatdim\n direction.\nThe common fields are concatenated field by field.\nIf a field name does not exist in all of \narrs\n, a null field with that field name will be added to those \nDictArray\ns with that missing field name, and then the arrays will be concatenated field by field.\n\n\nExamples\n\n\njulia> cat(1, darr(a=[1 2 3], b=[:x :y :z]),\n              darr(c=[3 2 1], b=[:m :n :p]))\n2 x 3 DictArray\n\na b c |a b c |a b c \n------+------+------\n1 x   |2 y   |3 z   \n  m 3 |  n 2 |  p 1 \n\njulia> cat(2, darr(a=[1 2 3], b=[:x :y :z]),\n              darr(c=[3 2 1], b=[:m :n :p]))\n1 x 6 DictArray\n\na b c |a b c |a b c |a b c |a b c |a b c \n------+------+------+------+------+------\n1 x   |2 y   |3 z   |  m 3 |  n 2 |  p 1 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:613\n\n\n\n\n\n\nconvert(::Type{DataFrames.DataFrame},  arr::MultidimensionalTables.DictArray{K, N, VS, SV}) \n\u00b6\n\n\nconvert(::Type{DataFrame}, arr::DictArray)\n converts a \nDictArray\n into a \nDataFrame\n. If the dimensions of \narr\n are greater than 1, \narr\n is first flattend into 1 dimension using \ncollapse_axes\n, and then converted into a \nDataFrame\n.\n\n\nsource:\n\n\nMultidimensionalTables/src/util/dataframe_interface.jl:96\n\n\n\n\n\n\nconvert(::Type{DataFrames.DataFrame},  arr::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN}) \n\u00b6\n\n\nconvert(::Type{DataFrame}, arr::LabeledArray)\n converts a \nLabeledArray\n into a \nDataFrame\n by first creating a \nDictArray\n by broadcasting all axes, and then convert that \nDictArray\n into a \nDataFrame\n.\n\n\nsource:\n\n\nMultidimensionalTables/src/util/dataframe_interface.jl:102\n\n\n\n\n\n\nconvert(::Type{MultidimensionalTables.DictArray{K, N, VS, SV}},  df::DataFrames.DataFrame) \n\u00b6\n\n\nconvert(::Type{DictArray}, df::DataFrame)\n converts a \nDataFrame\n into \nDictArray\n.\n\n\nsource:\n\n\nMultidimensionalTables/src/util/dataframe_interface.jl:84\n\n\n\n\n\n\nconvert(::Type{MultidimensionalTables.EnumerationArray{T, N, V, R<:Integer}},  arr::DataArrays.PooledDataArray{T, R<:Integer, N}) \n\u00b6\n\n\nconvert(::Type{EnumerationArray}, arr::PooledDataArray)\n converts a \nPooledDataArray\n into an \nEnumerationArray\n.\n\n\nsource:\n\n\nMultidimensionalTables/src/util/dataframe_interface.jl:108\n\n\n\n\n\n\nconvert(::Type{MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN}},  df::DataFrames.DataFrame) \n\u00b6\n\n\nconvert(::Type{LabeledArray}, df::DataFrame)\n converts a \nDataFrame\n into \nLabeledArray\n simply by wrapping \nconvert(DictArray, df)\n by \nLabeledArray\n.\n\n\nsource:\n\n\nMultidimensionalTables/src/util/dataframe_interface.jl:90\n\n\n\n\n\n\ndeletekeys{K, V}(dict::MultidimensionalTables.LDict{K, V},  keys...) \n\u00b6\n\n\ndeletekeys(dict::LDict, keys...)\n\n\nDelete \nkeys\n keys from \ndict\n. A missing key will be silently ignored.\n\n\njulia> deletekeys(LDict(:a=>3, :b=>5, :c=>10), :a, :b, :x)\nMultidimensionalTables.LDict{Symbol,Int64} with 1 entry:\n  :c => 10\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/ldict.jl:155\n\n\n\n\n\n\ndropnaiter{T, N}(arr::AbstractArray{Nullable{T}, N}) \n\u00b6\n\n\ndropnaiter(arr)\n\n\nGenerate an iterator from a nullable array \narr\n, which iterates over only non-null elements.\n\n\nExamples\n\n\njulia> for x in dropnaiter(@nalift([1,2,NA,4,5]))\n         println(x)\n       end\n1\n2\n4\n5\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_helper_functions.jl:24\n\n\n\n\n\n\nenum_dropnaiter{T, N}(arr::AbstractArray{Nullable{T}, N}) \n\u00b6\n\n\nenum_dropnaiter(arr)\n\n\nGenerate an iterator from a nullable array \narr\n, which yields (index, elem) for an integer \nindex\n for non-null element positions of \narr\n and a non-null element \nelem\n.\n\n\nExamples\n\n\njulia> for x in enum_dropnaiter(@nalift([:A,:B,NA,NA,:C]))\n         println(x)\n       end\n(1,:A)\n(2,:B)\n(5,:C)\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_helper_functions.jl:44\n\n\n\n\n\n\nfill(ldict::MultidimensionalTables.LDict{K, V},  dims::Integer...) \n\u00b6\n\n\nfill(ldict::LDict, dims...)\n\n\nFill a \nDictArray\n with \nldict\n.\n\n\nReturn\n\n\nA new \nDictArray\n whose elements are \nldict\n and whose dimensions are \ndims...\n.\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:1141\n\n\n\n\n\n\nflipdim(arr::MultidimensionalTables.DictArray{K, N, VS, SV},  dims::Integer...) \n\u00b6\n\n\nflipdim(arr::DictArray, dims...)\n\n\nFlip a \nDictArray\n \narr\n using an iterable variable \ndims\n. The same method as \nreverse(arr::DictArray, dims)\n.\n\n\nArguments\n\n\n\n\narr\n is an input \nDictArray\n.\n\n\ndims\n is an iterable variable of \nInt\ns.\n\n\n\n\nReturn\n\n\nA \nDictArray\n whose elements along any directions belonging to \ndims\n are fliped.\n\n\nExamples\n\n\njulia> t = darr(a=[1 2 3;4 5 6], b=[:x :y :z;:u :v :w])\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n1 x |2 y |3 z \n4 u |5 v |6 w \n\n\njulia> flipdim(t, 1)\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n4 u |5 v |6 w \n1 x |2 y |3 z \n\n\njulia> flipdim(t, 1, 2)\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n6 w |5 v |4 u \n3 z |2 y |1 x \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:1129\n\n\n\n\n\n\ngetindexvalue(arr::AbstractArray{T, N},  args...) \n\u00b6\n\n\ngetindexvalue(arr::AbstractArray, args...)\n\n\nReturn \narr[args...]\n.\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:190\n\n\n\n\n\n\ngetindexvalue(arr::MultidimensionalTables.DictArray{K, N, VS, SV},  args...) \n\u00b6\n\n\ngetindexvalue(arr::DictArray, args...)\n\n\nReturn the value tuple of \narr\n at index \nargs\n.\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:180\n\n\n\n\n\n\nintersect(dim::Integer,  arr0::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  arr_rest::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN}...) \n\u00b6\n\n\nintersect(dim, arrs...)\n\n\nTake intersection of arrays of type \nLabeledArray\n/\nDictArray\n/\nAbstractArrayWrapper\n. The order is preserved.\n\n\nArguments\n\n\n\n\ndim\n : direction along which to intersect.\n\n\narrs...\n : arrays to intersect.\n\n\n\n\nExamples\n\n\njulia> intersect(1, nalift([1 2 3;4 5 6]), nalift([1 2 3;5 5 6]))\n1x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)  Nullable(3)\n\njulia> intersect(2, nalift([1 2 3;4 5 6]), nalift([1 2 3;5 5 6]))\n2x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(2)  Nullable(3)\n Nullable(5)  Nullable(6)\n\njulia> intersect(1, darr(a=[:x,:y,:z]), darr(a=[:x,:x,:y]), darr(a=[:y,:y,:y]))\n1 DictArray\n\na \n--\ny \n\n\njulia> intersect(1, larr(a=[1 2 3;4 5 6], axis1=[:X,:Y]), larr(a=[1 2 3;4 3 2], axis1=[:X,:Y]))\n1 x 3 LabeledArray\n\n  |1 |2 |3 \n--+--+--+--\n  |a |a |a \n--+--+--+--\nX |1 |2 |3 \n\n\njulia> intersect(1, larr(a=[1 2 3;4 5 6], axis1=[:X,:Y]), larr(a=[1 2 3;4 3 2], axis1=[:Z,:Y]))\n0 x 3 LabeledArray\n\n |1 |2 |3 \n-+--+--+--\n |a |a |a \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/intersect.jl:53\n\n\n\n\n\n\nkeys(arr::MultidimensionalTables.DictArray{K, N, VS, SV}) \n\u00b6\n\n\nkeys(::DictArray)\n\n\nReturn the field name vector of the input \nDictArray\n, which are the keys of the underlying \nLDict\n.\n\n\nExamples\n\n\njulia> keys(darr(a=[1,2,3], b=[:x,:y,:z]))\n2-element Array{Symbol,1}:\n :a\n :b\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:1001\n\n\n\n\n\n\nmap(f::Function,  arr::MultidimensionalTables.DictArray{K, N, VS, SV}) \n\u00b6\n\n\nmap(f::Function, arr::DictArray)\n\n\nApply the function \nf\n to each element of \narr\n.\n\nf\n will take an \nLDict\n and produces a value of type, say \nT\n.\nThe return value will have the same size as \narr\n and its elements have type \nT\n.\nIf the return element type \nT\n is not nullable, the result elements are wrapped by \nNullable\n.\nIf the return element type \nT\n is \nLDict\n, the result will be again a \nDictArray\n.\nHowever, in this case, the \nLDict\n should be of the type \nLDict{K,Nullable{V}}\n.\n\n\nExamples\n\n\njulia> map(x->x[:a].value + x[:b].value, darr(a=[1 2;3 4], b=[1.0 2.0;3.0 4.0]))\n2x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},2,MultidimensionalTables.FloatNAArray{Float64,2,Array{Float64,2}}}:\n Nullable(2.0)  Nullable(4.0)\n Nullable(6.0)  Nullable(8.0)\n\njulia> map(x->LDict(:c=>Nullable(x[:a].value + x[:b].value)), darr(a=[1 2;3 4], b=[1.0 2.0;3.0 4.0]))\n2 x 2 DictArray\n\nc   |c   \n----+----\n2.0 |4.0 \n6.0 |8.0 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:719\n\n\n\n\n\n\nmapslices(f::Function,  arr::MultidimensionalTables.DictArray{K, N, VS, SV},  dims::AbstractArray{T, 1}) \n\u00b6\n\n\nmapslices(f::Function, arr::DictArray, dims)\n\n\nApply the function \nf\n to each slice of \narr\n specified by \ndims\n. \ndims\n is a vector of integers along which direction to reduce.\n\n\n\n\nIf \ndims\n includes all dimensions, \nf\n will be applied to the whole \narr\n.\n\n\nIf \ndims\n is empty, \nmapslices\n is the same as \nmap\n.\n\n\nOtherwise, \nf\n is applied to each slice spanned by the directions.\n\n\n\n\nReturn\n\n\nReturn a dimensionally reduced array along the directions in \ndims\n.\nIf the return value of \nf\n is an \nLDict\n, the return value of the corresponding \nmapslices\n is a \nDictArray\n.\nOtherwise, the return value is an \nArray\n.\n\n\njulia> mapslices(d->d[:a] .* 2, darr(a=[1 2 3;4 5 6], b=[10 11 12;13 14 15]), [1])\n3-element MultidimensionalTables.AbstractArrayWrapper{Nullable{MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}}},1,Array{Nullable{MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}}},1}}:\n Nullable([Nullable(2),Nullable(8)]) \n Nullable([Nullable(4),Nullable(10)])\n Nullable([Nullable(6),Nullable(12)])\n\njulia> mapslices(d->d[:a] .* 2, darr(a=[1 2 3;4 5 6], b=[10 11 12;13 14 15]), [2])\n2-element MultidimensionalTables.AbstractArrayWrapper{Nullable{MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}}},1,Array{Nullable{MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}}},1}}:\n Nullable([Nullable(2),Nullable(4),Nullable(6)])  \n Nullable([Nullable(8),Nullable(10),Nullable(12)])\n\njulia> mapslices(d->LDict(:c=>sum(d[:a]), :d=>sum(d[:b] .* 3)), darr(a=[1 2 3;4 5 6], b=[10 11 12;13 14 15]), [2])\n2 DictArray\n\nc  d   \n-------\n6  99  \n15 126 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:797\n\n\n\n\n\n\nmerge(arr1::MultidimensionalTables.DictArray{K, N, VS, SV},  args...) \n\u00b6\n\n\nmerge(::DictArray, args...)\n\n\nConstruct a \nDictArray\n using \nargs...\n, and merges the two \nDictArray\ns together.\n\n\nExample\n\n\njulia> merge(darr(a=[1,2,3], b=[4,5,6]), b=[:x,:y,:z], :c=>[\"A\",\"B\",\"C\"])\n3 DictArray\n\na b c \n------\n1 x A \n2 y B \n3 z C \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:338\n\n\n\n\n\n\nmerge(arr1::MultidimensionalTables.DictArray{K, N, VS, SV},  arr2::MultidimensionalTables.DictArray{K, N, VS, SV}) \n\u00b6\n\n\nmerge(::DictArray, ::DictArray)\n\n\nMerge the two \nDictArray\ns. A duplicate field in the second \nDictArray\n will override that in the first one. Otherwise, the new field in the second \nDictArray\n will be appened after the first \nDictArray\n fields.\nIf the first is \nDictArray\n and the remaining arguments are used to construct a \nDictArray\n and then the two are merged.\n\n\nExample\n\n\njulia> merge(darr(a=[1,2,3], b=[4,5,6]), darr(b=[:x,:y,:z], c=[\"A\",\"B\",\"C\"]))\n3 DictArray\n\na b c \n------\n1 x A \n2 y B \n3 z C \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:317\n\n\n\n\n\n\nmerge(arr1::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  args::MultidimensionalTables.DictArray{K, N, VS, SV}...) \n\u00b6\n\n\nmerge(::LabeledArray, ::DictArray...)\n\n\nMerge the base of the \nLabeledArray\n and the rest \nDictArray\ns.\nTogether with the axes set of the input \nLabeledArray\n, return a new \nLabeledArray\n.\n\n\nExamples\n\n\njulia> merge(larr(a=[1,2,3],b=[:x,:y,:z],axis1=[:a,:b,:c]),darr(c=[4,5,6],b=[:m,:n,:p]),darr(a=[\"X\",\"Y\",\"Z\"]))\n3 LabeledArray\n\n  |a b c \n--+------\na |X m 4 \nb |Y n 5 \nc |Z p 6 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/labeled_array.jl:1530\n\n\n\n\n\n\nmerge(arr1::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  arr2::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN}) \n\u00b6\n\n\nmerge(::LabeledArray, ::LabeledArray)\n\n\nMerge two \nLabeledArrays\n. The axes set of the two should be identical.\nThe bases are merged together and the common axes set is used.\n\n\nExamples\n\n\njulia> merge(larr(a=[1,2,3],b=[:x,:y,:z],axis1=[:a,:b,:c]),larr(c=[4,5,6],b=[:m,:n,:p],axis1=[:a,:b,:c]))\n3 LabeledArray\n\n  |a b c \n--+------\na |1 m 4 \nb |2 n 5 \nc |3 p 6 \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/labeled_array.jl:1504\n\n\n\n\n\n\nmerge(dict::MultidimensionalTables.LDict{K, V},  ds::Associative{K, V}...) \n\u00b6\n\n\nmerge(dict::LDict, ds...)\n\n\nCombine an \nLDict\n \ndict\n with \nAssociative\n \nds\n's.\nThe subsequent elements in ds will either update the preceding one, or append the key-value pair.\n\n\nExamples\n\n\njulia> merge(LDict(:a=>3, :b=>5), Dict(:b=>\"X\", :c=>\"Y\"), LDict(:c=>'x', 'd'=>'y'))\nMultidimensionalTables.LDict{Any,Any} with 4 entries:\n  :a  => 3\n  :b  => \"X\"\n  :c  => 'x'\n  'd' => 'y'\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/ldict.jl:98\n\n\n\n\n\n\nreducedim(f::Function,  arr::MultidimensionalTables.DictArray{K, N, VS, SV},  dims,  initial) \n\u00b6\n\n\nreducedim(f::Function, arr::DictArray, dims [, initial])\n\n\nReduce a two argument function \nf\n along dimensions of \narr\n. \ndims\n is a vector specifying the dimensions to reduce, and \ninitial\n is the initial value to use in the reduction.\n* If \ndims\n includes all dimensions, \nreduce\n will be applied to the whole \narr\n with initial value \ninitial.\n* Otherwise,\nreduce\nis applied with the function\nf\nto each slice spanned by the directions with initial value\ninitial\n.\ninitial\ncan be omitted if the underlying\nreduce` does not require it.\n\n\njulia> reducedim((acc,d)->acc+d[:a].value, darr(a=[1 2 3;4 5 6]), [1], 0)\n3-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(5)\n Nullable(7)\n Nullable(9)\n\njulia> reducedim((acc,d)->acc+d[:a].value, darr(a=[1 2 3;4 5 6]), [2], 0)\n2-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(6) \n Nullable(15)\n\njulia> reducedim((acc,d)->acc+d[:a].value, darr(a=[1 2 3;4 5 6]), [1,2], 0)\nNullable(21)\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:747\n\n\n\n\n\n\nrepeat(arr::MultidimensionalTables.DictArray{K, N, VS, SV}) \n\u00b6\n\n\nrepeat(arr::DictArray [; inner=..., outer=...])\n\n\nApply \nrepeat\n field by field to the \nDictArray\n \narr\n.\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:640\n\n\n\n\n\n\nreplace_expr(expr) \n\u00b6\n\n\nreplace_expr(expr)\n\n\nCreate a function expression from a domain expression.\n\n\nExpressions\n\n\nBelow t' is an object such that t'[k] for a field name k gives the corresponding array\nfor the field k in the table t at the coordinates selected so far.\n\n\n\n\n_k\n : translates to \nt'[k]\n. The field name \nk\n should be a symbol.\n\n\n__k\n : translates to \nigna(t')[k]\n. It ignores the null elements. The null elements are replaced with arbitrary values, so make sure there is no null value in the array if you want to use it. The field name \nk\n should be a symbol.\n\n\n_!k\n : translates to \nisna(t')[k]\n. It gives a boolean array to denote whether an element is null. The field name \nk\n should be a symbol.\n\n\n_\n : translates to \nt'\n if none of the above is applicable. It is useful when the field name is not a symbol.\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/select.jl:1118\n\n\n\n\n\n\nreshape(arr::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  dims::Int64...) \n\u00b6\n\n\nreshape(arr::LabeledArray, dims...)\n\n\nReshape \narr\n into different sizes, if there is no ambiguity.\nThis means you can collapse several contiguous directions into one direction,\nin which case all axes belonging to collapsing direction will be concatenated.\nFor other case, sometimes it is possible to disambiguate the axis position.\nBut in general, the result is either an error or an undetermined result\nas long as the axis positions are concerned.\n\n\nExamples\n\n\njulia> t = larr(a=[1 2 3;4 5 6], axis1=[:x,:y], axis2=[\"A\",\"B\",\"C\"])\n2 x 3 LabeledArray\n\n  |A |B |C \n--+--+--+--\n  |a |a |a \n--+--+--+--\nx |1 |2 |3 \ny |4 |5 |6 \n\n\n1 x 6 LabeledArray\n\nx1 |x |y |x |y |x |y \nx2 |A |A |B |B |C |C \n---+--+--+--+--+--+--\n   |a |a |a |a |a |a \n---+--+--+--+--+--+--\n1  |1 |4 |2 |5 |3 |6 \n\n\njulia> reshape(t, 6, 1)\n6 x 1 LabeledArray\n\n      |1 \n------+--\nx1 x2 |a \n------+--\nx  A  |1 \ny  A  |4 \nx  B  |2 \ny  B  |5 \nx  C  |3 \ny  C  |6 \n\n\njulia> reshape(t, 6)\n6 LabeledArray\n\nx1 x2 |a \n------+--\nx  A  |1 \ny  A  |4 \nx  B  |2 \ny  B  |5 \nx  C  |3 \ny  C  |6 \n\n\njulia> reshape(t, 3,2)\nERROR: ArgumentError: dims (3,2) are inconsistent.\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/labeled_array.jl:1177\n\n\n\n\n\n\nreverse(arr::MultidimensionalTables.DictArray{K, N, VS, SV},  dims) \n\u00b6\n\n\nreverse(arr::DictArray, dims)\n\n\nReverse a \nDictArray\n \narr\n using an iterable variable \ndims\n.\n\n\nArguments\n\n\n\n\narr\n is an input \nDictArray\n.\n\n\ndims\n is an iterable variable of \nInt\ns.\n\n\n\n\nReturn\n\n\nA \nDictArray\n whose elements along any directions belonging to \ndims\n are reversed.\n\n\nExamples\n\n\njulia> t = darr(a=[1 2 3;4 5 6], b=[:x :y :z;:u :v :w])\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n1 x |2 y |3 z \n4 u |5 v |6 w \n\n\njulia> reverse(t, [1])\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n4 u |5 v |6 w \n1 x |2 y |3 z \n\n\njulia> reverse(t, 1:2)\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n6 w |5 v |4 u \n3 z |2 y |1 x \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:1072\n\n\n\n\n\n\nsel(func,  t) \n\u00b6\n\n\nsel(func, t [; c=[], b=[], a=[]])\n\n\nan intermediate \nselect\n/\nupdate\n function to connect \nselectfunc\n/\nupdatefunc\n and \n@select\n(\nselct\n)/\n@update\n(\nupdate\n).\n\n\nArguments\n\n\nBelow \nt'\n is an object such that \nt'[k]\n for a field name \nk\n gives the corresponding array\nfor the field \nk\n in the table \nt\n at the coordinates selected so far.\n\n \nfunc\n : selectfunc or updatefunc.\n\n \nt\n : a LabeledArray.\n\n \nc\n : an array of conditions of type \nt'\n -> nullable boolean array.\n\n \nb\n : an array of arrays of pairs from field names to by functions specified as \nt'\n -> a nullable array.\n* \na\n : an array of pairs from field names to aggregate functions specified as \nt'\n -> a nullable array.\n\n\nsource:\n\n\nMultidimensionalTables/src/util/select.jl:597\n\n\n\n\n\n\nselectfunc{N}(t::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  c,  b,  a) \n\u00b6\n\n\nselectfunc(t::LabeledArray, c, b, a)\n\n\nmain select function. This function is internal and is meant to be used via \nselct\n.\n\nselectfunc\n takes a table \nt\n, condition \nc\n, aggreagtion by rule \nb\n, aggregate function \na\n.\n\n\n\n\nt : a LabeledArray\n\n\nc : an array of functions \n(t, inds)\n -> boolean array. \nt\n is a LabeledArray and inds is either \nnothing\n to choose the entire \nt\n or an array of Cartesian indices.\n\n\nb : an array of arrays of pairs of field name => function \n(t, inds)\n -> array. \nt\n is a LabeledArray and inds is either \nnothing\n to choose the entire \nt\n or an array of Cartesian indices.\n\n\nc : an array of pairs of field name => function \n(t, inds)\n -> array. \nt\n is a LabeledArray and inds is either \nnothing\n to choose the entire \nt\n or an array of Cartesian indices.\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/select.jl:34\n\n\n\n\n\n\nselectkeys{K, V}(dict::MultidimensionalTables.LDict{K, V},  keys...) \n\u00b6\n\n\nselectkeys(dict::LDict, keys...)\n\n\nSelect \nkeys\n keys from \ndict\n. A missing key will raise an error.\n\n\nExamples\n\n\njulia> selectkeys(LDict(:a=>3, :b=>5, :c=>10), :a, :b)\nMultidimensionalTables.LDict{Symbol,Int64} with 2 entries:\n  :a => 3\n  :b => 5\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/ldict.jl:186\n\n\n\n\n\n\nshow{N}(io::IO,  arr::MultidimensionalTables.DictArray{K, N, VS, SV}) \n\u00b6\n\n\nshow(io::IO, arr::DictArray [; height::Int=..., width::Int=..., alongorow::Bool=true])\n\n\nShow a \nDictArray\n in \nio\n in a square box of given \nheight\n and \nwidth\n. If not provided, the current terminal's size is used to get the default \nheight\n and \nweight\n. \nalongrow\n determines whether to display field names along row or columns.\n\n\nExamples\n\n\njulia> show(STDOUT, darr(a=[1,2,3], b=[:x,:y,:z]))\n3 DictArray\n\na b \n----\n1 x \n2 y \n3 z \n\njulia> show(STDOUT, darr(a=[1,2,3], b=[:x,:y,:z]), alongrow=false)\n3 DictArray\n\na |1 \nb |x \n--+--\na |2 \nb |y \n--+--\na |3 \nb |z \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:376\n\n\n\n\n\n\nshow{N}(io::IO,  arr::MultidimensionalTables.DictArray{K, N, VS, SV},  indent) \n\u00b6\n\n\nshow(io::IO, arr::DictArray [; height::Int=..., width::Int=..., alongorow::Bool=true])\n\n\nShow a \nDictArray\n in \nio\n in a square box of given \nheight\n and \nwidth\n. If not provided, the current terminal's size is used to get the default \nheight\n and \nweight\n. \nalongrow\n determines whether to display field names along row or columns.\n\n\nExamples\n\n\njulia> show(STDOUT, darr(a=[1,2,3], b=[:x,:y,:z]))\n3 DictArray\n\na b \n----\n1 x \n2 y \n3 z \n\njulia> show(STDOUT, darr(a=[1,2,3], b=[:x,:y,:z]), alongrow=false)\n3 DictArray\n\na |1 \nb |x \n--+--\na |2 \nb |y \n--+--\na |3 \nb |z \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:376\n\n\n\n\n\n\nshow{N}(io::IO,  table::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN}) \n\u00b6\n\n\nshow(io::IO, table::LabeledArray [, indent=0; height=..., width=...])\n\n\nShow a LabeledArray.\n\n\nArguments\n\n\n\n\nheight\n and \nwidth\n(optional, default set by show_size()): sets the maximum height and width to draw, beyond which the table will be cut.\n\n\nalongrow\n(optional, default set by \nset_dispalongrow!!\n. \ntru\n by default): if \ntrue\n, the fields in the array will be displayed along the row in each cell. Otherwise, they will be stacked on top of each other.\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/labeled_array.jl:244\n\n\n\n\n\n\nshow{N}(io::IO,  table::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  indent) \n\u00b6\n\n\nshow(io::IO, table::LabeledArray [, indent=0; height=..., width=...])\n\n\nShow a LabeledArray.\n\n\nArguments\n\n\n\n\nheight\n and \nwidth\n(optional, default set by show_size()): sets the maximum height and width to draw, beyond which the table will be cut.\n\n\nalongrow\n(optional, default set by \nset_dispalongrow!!\n. \ntru\n by default): if \ntrue\n, the fields in the array will be displayed along the row in each cell. Otherwise, they will be stacked on top of each other.\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/labeled_array.jl:244\n\n\n\n\n\n\nsort(arr::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  axis::Integer,  fields...) \n\u00b6\n\n\nsort(arr, axis fields... [; alg=..., ...])\n\n\nSort a \nDictArray\n or \nLabeledArray\n along some axis.\n\n\nArguments\n\n\n\n\narr\n : either a \nDictArray\n or a \nLabeledArray\n.\n\n\naxis\n : an axis direction integer to denote which direction to sort along.\n\n\nfields...\n : the names of fields to determine the order. The preceding ones have precedence over the later ones. Note only the components [1,...,1,:,1,...1], where : is placed at the axis position, will be used out of each field.\n\n\noptionally, \nalg=algorithm\n determines the sorting algorithm. \nfieldname_lt=ltfunc\n sets the less-than function for the field fieldname, and similarly for \nby\n/\nrev\n/\nord\n.\n\n\n\n\nExamples\n\n\njulia> t = larr(a=[3 3 2;7 5 3], b=[:b :a :c;:d :e :f], axis1=[\"X\",\"Y\"])\n2 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nX |3 b |3 a |2 c \nY |7 d |5 e |3 f \n\n\njulia> sort(t, 1, :a)\n2 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nX |3 b |3 a |2 c \nY |7 d |5 e |3 f \n\n\njulia> sort(t, 2, :a)\n2 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nX |2 c |3 b |3 a \nY |3 f |7 d |5 e \n\n\njulia> sort(t, 2, :a, :b)\n2 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nX |2 c |3 a |3 b \nY |3 f |5 e |7 d \n\n\njulia> sort(t, 2, :a, :b, a_rev=true)\n2 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nX |3 a |3 b |2 c \nY |5 e |7 d |3 f \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/sort.jl:132\n\n\n\n\n\n\nunique{T}(arr::MultidimensionalTables.AbstractArrayWrapper{Nullable{T}, N, A<:AbstractArray{T, N}}) \n\u00b6\n\n\nunique(arr, dims...)\n\n\nReturn unique elements of an array \narr\n of type \nLabeledArray\n/\nDictArray\n/\nNullable AbstractArrayWrapper\n.\n\n\nArguments\n\n\n\n\narr\n : an array\n\n\ndims...\n : either an integer or, if an array is a DictArray or a LabeledArray, a list of integers. It specifies the directions along which to traverse. Any duplicate elements will be replaced by Nullable{T}(). If all components along some direction are missing, those components will be removed and the whole array size will shrink.\nIf \ndims...\n is missing, unique elements along the whole directions will be found. It is equivalent to \nunique(arr, 1, 2, ..., ndims(arr))\n.\nNote that it compares each slice spanned by directions orthogonal to \ndims...\n.\n\n\n\n\nExamples\n\n\njulia> unique(nalift([1 2 3;3 4 1]))\n2x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)\n Nullable(3)  Nullable(4)\n\njulia> unique(nalift([1 2 3;3 4 1]), 1)\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)  Nullable(3)\n Nullable(3)  Nullable(4)  Nullable(1)\n\njulia> unique(nalift([1 2 3;3 4 1]), 2)\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)  Nullable(3)\n Nullable(3)  Nullable(4)  Nullable(1)\n\njulia> unique(nalift([1 2 3;1 2 3;4 5 6]), 1)\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)  Nullable(3)\n Nullable(4)  Nullable(5)  Nullable(6)\n\njulia> t = darr(a=[1 2 1;1 5 1;1 2 1], b=[:a :b :a;:a :c :a;:a :b :a])\n3 x 3 DictArray\n\na b |a b |a b \n----+----+----\n1 a |2 b |1 a \n1 a |5 c |1 a \n1 a |2 b |1 a \n\n\njulia> unique(t, 1)\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n1 a |2 b |1 a \n1 a |5 c |1 a \n\n\njulia> unique(t, 2)\n3 x 2 DictArray\n\na b |a b \n----+----\n1 a |2 b \n1 a |5 c \n1 a |2 b \n\n\njulia> m = larr(a=[1 2 1;1 5 1;1 2 1], b=[:a :b :a;:a :c :a;:a :b :a], axis1=[\"X\",\"Y\",\"Z\"])\n3 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nX |1 a |2 b |1 a \nY |1 a |5 c |1 a \nZ |1 a |2 b |1 a \n\n\njulia> unique(m, 1)\n2 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nX |1 a |2 b |1 a \nY |1 a |5 c |1 a \n\n\njulia> unique(m, 2)\n3 x 2 LabeledArray\n\n  |1   |2   \n--+----+----\n  |a b |a b \n--+----+----\nX |1 a |2 b \nY |1 a |5 c \nZ |1 a |2 b \n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/unique.jl:102\n\n\n\n\n\n\nupdatefunc{N}(t::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  c,  b,  a) \n\u00b6\n\n\nupdatefunc(t::LabeledArray, c, b, a)\n\n\nmain update function. This function is internal and is meant to be used via \nupdate\n.\n\nupdatefunc\n takes a table \nt\n, condition \nc\n, aggreagtion by rule \nb\n, aggregate function \na\n.\n\n\n\n\nt\n : a LabeledArray\n\n\nc\n : an array of functions \n(t, inds)\n -> boolean array. \nt\n is a LabeledArray and inds is either \nnothing\n to choose the entire \nt\n or an array of Cartesian indices.\n\n\nb\n : an array of arrays of pairs of field name => function \n(t, inds)\n -> array. \nt\n is a LabeledArray and inds is either \nnothing\n to choose the entire \nt\n or an array of Cartesian indices.\n\n\nc\n : an array of pairs of field name => function \n(t, inds)\n -> array. \nt\n is a LabeledArray and inds is either \nnothing\n to choose the entire \nt\n or an array of Cartesian indices.\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/select.jl:111\n\n\n\n\n\n\nvalues(arr::MultidimensionalTables.DictArray{K, N, VS, SV}) \n\u00b6\n\n\nvalues(::DictArray)\n\n\nReturn the vector of field arrays of the input \nDictArray\n, which are the values of the underlying \nLDict\n.\n\n\nExamples\n\n\njulia> values(darr(a=[1,2,3], b=[:x,:y,:z]))\n2-element Array{MultidimensionalTables.AbstractArrayWrapper{T,1,A<:AbstractArray{T,N}},1}:\n [Nullable(1),Nullable(2),Nullable(3)]   \n [Nullable(:x),Nullable(:y),Nullable(:z)]\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/dict_array.jl:1019\n\n\n\n\n\n\nwrap_array(arr::MultidimensionalTables.AbstractArrayWrapper{T, N, A<:AbstractArray{T, N}}) \n\u00b6\n\n\nwrap_array(arr)\n\n\nWrap an array by \nAbstractArrayWrapper\n if it is not \nDictArray\n or \nlabeledArray\n, and not already \nAbstractArrayWrapper\n.\n\n\nsource:\n\n\nMultidimensionalTables/src/na/naarray_operators.jl:11\n\n\n\n\n\n\nzip_dropnaiter{N}(arrs::MultidimensionalTables.AbstractArrayWrapper{T, N, A<:AbstractArray{T, N}}...) \n\u00b6\n\n\nzip_dropnaiter(arrs...)\n\n\nGenerate a zipped iterator from nullable arrays \narrs...\n. If any element in \narrs...\n is null, the iterator will skip it and move to the next element tuple.\n\n\nExamples\n\n\njulia> for x in zip_dropnaiter(@nalift([11,12,NA,NA,15]),\n                               @nalift([:X,NA,:Z,NA,:V]),\n                               @nalift([71,72,73,NA,75]))\n         println(x)\n       end\n(11,:X,71)\n(15,:V,75)\n\n\n\n\nsource:\n\n\nMultidimensionalTables/src/util/array_helper_functions.jl:132\n\n\n\n\n\n\nMultidimensionalTables.AbstractArrayWrapper{T, N, A<:AbstractArray{T, N}} \n\u00b6\n\n\nA thin wrapper around AbstractArray. The reason to introduce this wrapper is to redefine\nthe dotted operators such as .+, .-. Those operators will be mapped to arrays, elementwise just as before,\nbut, if each element is null, those operators will be applied to the one inside the Nullable.\nFor example,\n\n\njulia> AbstractArrayWrapper([Nullable(1), Nullable(2)]) .+ AbstractArrayWrapper([Nullable{Int}(), Nullable(3)])\n2-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable{Int64}()\n Nullable(5)      \n\n\n\n\nNote that this means lifting those dotted operators via the list(AbstractArray) and maybe(Nullable) functors.\n\n\nIt is possible to redefine those operators for AbstractArray, but concerning about compatibility, it may be\nbest to introduce a new wrapper class for that.\n\n\nsource:\n\n\nMultidimensionalTables/src/na/na.jl:25\n\n\n\n\n\n\nMultidimensionalTables.DefaultAxis \n\u00b6\n\n\nDefault axis used when no axis is specified for a \nLabeledArray\n.\nIt behaves mostly as an array \n[Nullable(1), Nullable(2), ...]\n.\nHowever, one notable exception is when using \n@select\n/\nselct\n/\nextract\n/\ndiscard\n/\ngetindex\n/etc to choose, set or drop specific elements of a \nLabeledArray\n.\nIn this case, the result array of reduced size will again have a \nDefaultAxis\n of an appropriate size.\n\n\nsource:\n\n\nMultidimensionalTables/src/datatypes/labeled_array.jl:47",
            "title": "API"
        },
        {
            "location": "/api/#multidimensionaltables",
            "text": "",
            "title": "MultidimensionalTables"
        },
        {
            "location": "/api/#exported",
            "text": "MultidimensionalTables.axis2flds  \u00b6  axis2flds(arr::LabeledArray (; name_collapse_function=..., default_axis_value=nothing)  Collapse a dimension of a  LabeledArray , making the axis along that direction as field names.  Arguments   larr  : a LabeledArray.  name_collapse_function  (optional keyword) : a function to combine the axis label and the column name. By default, it concatenates the names with '_' inserted in between.  default_axis_value  (optional keyword) : a default value to be used when an axis element is null. If  nothing  (by default), an exception will raise.   Examples  julia> t = larr(reshape(1:10,5,2), axis1=darr(k=['a','b','c','d','e']), axis2=darr(r1=[:M,:N],r2=[\"A\",\"A\"]))\n5 x 2 LabeledArray\n\nr1 |M |N  \nr2 |A |A  \n---+--+---\nk  |  |   \n---+--+---\na  |1 |6  \nb  |2 |7  \nc  |3 |8  \nd  |4 |9  \ne  |5 |10 \n\n\njulia> axis2flds(t)\n5 LabeledArray\n\nk |M_A N_A \n--+--------\na |1   6   \nb |2   7   \nc |3   8   \nd |4   9   \ne |5   10  \n\n\njulia> axis2flds(t, name_collapse_function=x->join(x, \"*\"))\n5 LabeledArray\n\nk |M*A N*A \n--+--------\na |1   6   \nb |2   7   \nc |3   8   \nd |4   9   \ne |5   10  \n\n\njulia> m = @larr(reshape(1:10,5,2), axis1[k=['a','b','c','d','e']], axis2[:M,NA])\n5 x 2 LabeledArray\n\n  |M |   \n--+--+---\nk |  |   \n--+--+---\na |1 |6  \nb |2 |7  \nc |3 |8  \nd |4 |9  \ne |5 |10 \n\n\njulia> axis2flds(m, default_axis_value=\"N/A\")\n5 LabeledArray\n\nk |M N/A \n--+------\na |1 6   \nb |2 7   \nc |3 8   \nd |4 9   \ne |5 10    source:  MultidimensionalTables/src/util/array_util.jl:614    MultidimensionalTables.collapse_axes  \u00b6  collapse_axes(arr::AbstractArray, front_dim::Integer, back_end::Integer)  Collapse front_dim to back_dim dimensions into one.  Arguments   arr  : an array  front_dims  : the starting direction to collapse.  back_dims  : the end direction to collapse.   The result is an array whose elements along front_dims to back_dims are all flattened into one dimension.\nIf  arr  is a LabeledArray, all the labels along the flattened direction are combined together.  Examples  julia> collapse_axes(darr(a=reshape(1:40, 2,4,5), b=reshape(11:50, 2,4,5)), 1, 2)\n8 x 5 DictArray\n\na b  |a  b  |a  b  |a  b  |a  b  \n-----+------+------+------+------\n1 11 |9  19 |17 27 |25 35 |33 43 \n2 12 |10 20 |18 28 |26 36 |34 44 \n3 13 |11 21 |19 29 |27 37 |35 45 \n4 14 |12 22 |20 30 |28 38 |36 46 \n5 15 |13 23 |21 31 |29 39 |37 47 \n6 16 |14 24 |22 32 |30 40 |38 48 \n7 17 |15 25 |23 33 |31 41 |39 49 \n8 18 |16 26 |24 34 |32 42 |40 50   source:  MultidimensionalTables/src/util/array_util.jl:203    MultidimensionalTables.darr  \u00b6  darr(...)  Create a  DictArray . The arguments  ...  can be one of the following:  Arguments   k=>v  creates a field using an array  v  with field name  k .  k  can be an arbitrary type. If the element type of  v  is not  Nullable , each element will be wrapped by  Nullable . If you want to manually provide a  Nullable  array with  Nullable{T}()  elements in it, the macro version  @darr  may be more convenient to use. Note that this type of argument precedes the keyword type argument in the return  DictArray , as shown in Examples below.  k=v  creates a field using an array  v  with field name  :k .  There can be at most one non pair type argument, which will be converted into a  DictArray  and other pair arguments will update it.\nEspecially, if the non pair type argument is an array of  LDict , it will be converted into a  DictArray .   Examples  julia> t = darr(a=[1 2;3 4;5 6],b=[\"abc\" 'a';1 2;:m \"xyz\"],:c=>[1.0 1.5;:sym 'a';\"X\" \"Y\"])\n3 x 2 DictArray\n\nc   a b   |c   a b   \n----------+----------\n1.0 1 abc |1.5 2 a   \nsym 3 1   |a   4 2   \nX   5 m   |Y   6 xyz \n\n\njulia> darr(t, c=[1 2;3 4;5 6], :d=>map(Nullable, [1 2;3 4;5 6]))\n3 x 2 DictArray\n\nc a b   d |c a b   d \n----------+----------\n1 1 abc 1 |2 2 a   2 \n3 3 1   3 |4 4 2   4 \n5 5 m   5 |6 6 xyz 6 \n\njulia> darr(Any[LDict(:a => Nullable(1),:b => Nullable{Int}()),LDict(:a => Nullable(3),:b => Nullable(4))])\n2 DictArray\n\na b \n----\n1   \n3 4   source:  MultidimensionalTables/src/datatypes/dict_array.jl:1288    MultidimensionalTables.delete  \u00b6  Delete keys or fields from  LDict ,  DictArray , or  LabeledArray .   delete(dict::LDict, keys...)  deletes the keys  keys  from  dict  and returns a new  LDict .  delete(arr::DictArray, fieldnames...)  deletes the fields for  fieldnames  from  arr  and returns a new  DictArray .  delete(arr::LabeledArray, fieldnames...)  deletes the fields for  fieldnames  from  arr , either from the base or axes, and returns a new  LabeledArray .   Examples  julia> delete(LDict(:a=>1, :b=>2, :c=>3), :a, :c)\nMultidimensionalTables.LDict{Symbol,Int64} with 1 entry:\n  :b => 2\n\njulia> delete(darr(a=[1,2,3], b=[:m,:n,:p]), :b)\n3 DictArray\n\na \n--\n1 \n2 \n3 \n\n\njulia> t = larr(a=[1 2;3 4;5 6], b=[:x :y;:z :u;:v :w], axis1=darr(k=[\"X\",\"Y\",\"Z\"]), axis2=[:A,:B])\n3 x 2 LabeledArray\n\n  |A   |B   \n--+----+----\nk |a b |a b \n--+----+----\nX |1 x |2 y \nY |3 z |4 u \nZ |5 v |6 w \n\n\njulia> delete(t, :k, :b)\n3 x 2 LabeledArray\n\n  |A |B \n--+--+--\n  |a |a \n--+--+--\n1 |1 |2 \n2 |3 |4 \n3 |5 |6   source:  MultidimensionalTables/src/util/array_util.jl:979    MultidimensionalTables.describe  \u00b6  describe(arr)  Generate a  LabeledArray  showing the overall statistics of the input.\nIf the input is a  Nullable  array, its summary statistics is calculated and the return value is of type  LDict .\nIf the input is a  DictArray , the summary is calculated for each field and the result is a  DictArray .\nIf the input is a  LabeledArray ,  describe  returns the summary of its base.  Examples  julia> describe(@nalift([1,2,3,4,NA]))\nMultidimensionalTables.LDict{Symbol,Any} with 10 entries:\n  :min     => [Nullable(1)]\n  :q1      => Nullable(1.75)\n  :med     => Nullable(2.5)\n  :q3      => Nullable(3.25)\n  :max     => Nullable(4)\n  :mean    => Nullable(2.5)\n  :std     => Nullable(1.2909944487358056)\n  :count   => Nullable(5)\n  :nacount => Nullable(1)\n  :naratio => Nullable(0.2)\n\njulia> describe(@darr(a=[1,2,3,4,NA],b=[1,2,3,4,5]))\n2 LabeledArray\n\n  |min q1   med q3   max mean std                count nacount naratio \n--+--------------------------------------------------------------------\na |1   1.75 2.5 3.25 4   2.5  1.2909944487358056 5     1       0.2     \nb |1   2.0  3.0 4.0  5   3.0  1.5811388300841898 5     0       0.0     \n\n\njulia> describe(@larr(a=[1,2,3,4,NA],b=[1,2,3,4,5],axis1[:m,:n,:p,:q,:r]))\n2 LabeledArray\n\n  |min q1   med q3   max mean std                count nacount naratio \n--+--------------------------------------------------------------------\na |1   1.75 2.5 3.25 4   2.5  1.2909944487358056 5     1       0.2     \nb |1   2.0  3.0 4.0  5   3.0  1.5811388300841898 5     0       0.0       source:  MultidimensionalTables/src/util/array_helper_functions.jl:1312    MultidimensionalTables.discard  \u00b6  discard(arr, ns...)  Discard a block of array discarding all elements specified by  ns ..., using labels for  LabeledArray s, indices for other types of arrays or  LDict s.  Arguments   arr : an  AbstractArray  or  LDict .  ns... : each element in  ns  chooses specific elements along that direction. The element can be  Colon()  ( : ): the entire range will be removed and the return value will be empty.  a label or array of labels along that direction to discard.  a boolean array of the same size as the axis along that direction to denote which position to discard.  a function that takes the axis along that direction and generates either an array of integers or a boolean array for the deleted positions.   Return  An array or  LDict  of the same type as  arr , which is selected based on  ns .... All indices will be chosen for the rest of the directions not specified in  ns .... If any label is missing or the integer range is out of bound, it will be ignored.  Examples  julia> t = larr(a=map(x->'a'+x,reshape(0:14,5,3)), b=reshape(1:15,5,3), axis1=[:X,:Y,:Z,:U,:V], axis2=darr(r1=[:A,:A,:B],r2=[:m,:n,:n]))\n5 x 3 LabeledArray\n\nr1 |A   |A    |B    \nr2 |m   |n    |n    \n---+----+-----+-----\n   |a b |a b  |a b  \n---+----+-----+-----\nX  |a 1 |f 6  |k 11 \nY  |b 2 |g 7  |l 12 \nZ  |c 3 |h 8  |m 13 \nU  |d 4 |i 9  |n 14 \nV  |e 5 |j 10 |o 15 \n\n\njulia> discard(t, [:X,:V,:W], map(Nullable,(:A,:m)))\n3 x 2 LabeledArray\n\nr1 |A   |B    \nr2 |n   |n    \n---+----+-----\n   |a b |a b  \n---+----+-----\nY  |g 7 |l 12 \nZ  |h 8 |m 13 \nU  |i 9 |n 14 \n\n\njulia> discard(t, [:X,:V,:W], darr(r1=[:A,:B],r2=[:m,:m]))\n3 x 2 LabeledArray\n\nr1 |A   |B    \nr2 |n   |n    \n---+----+-----\n   |a b |a b  \n---+----+-----\nY  |g 7 |l 12 \nZ  |h 8 |m 13 \nU  |i 9 |n 14 \n\n\njulia> discard(t, [], d->d[:r1] .== :A)\n5 x 1 LabeledArray\n\nr1 |B    \nr2 |n    \n---+-----\n   |a b  \n---+-----\nX  |k 11 \nY  |l 12 \nZ  |m 13 \nU  |n 14 \nV  |o 15   source:  MultidimensionalTables/src/util/array_util.jl:1611    MultidimensionalTables.dropna  \u00b6  Remove any  NA  entries. If all elements are  NA  along some slice, that slice will be removed and the array size will shrink.  Examples  julia> t = @darr(a=[1 2 NA;NA 5 NA], b=[NA :n NA;:x NA NA])\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n1   |2 n |    \n  x |5   |    \n\n\njulia> dropna(t)\n2 x 2 DictArray\n\na b |a b \n----+----\n1   |2 n \n  x |5   \n\n\njulia> m = @larr(a=[1 2 NA;NA 5 NA], b=[NA :n NA;:x NA NA], axis1[:M,:N])\nd2 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nM |1   |2 n |    \nN |  x |5   |    \n\n\njulia> dropna(m)\n2 x 2 LabeledArray\n\n  |1   |2   \n--+----+----\n  |a b |a b \n--+----+----\nM |1   |2 n \nN |  x |5     source:  MultidimensionalTables/src/util/array_util.jl:1067    MultidimensionalTables.enumeration  \u00b6  enumeration(arr [, poolorder])  Create an  EnumerationArray .  Arguments   arr : an input array of  Nullable  element type. It is assumed that there are only a few possible values in  arr  and each value is converted into an integer when creating an  EnumerationArray .  poolorder : a vector to fix some of the integer values in the mapping from the values in  arr  to integers. If there are  n  elements in  poolorder , those  n  elements in  arr  will be assigned 1... n  when creating an  EnumerationArray . All the others are assigned integers in order of their appearance.   Examples  julia> enumeration([:A,:A,:B,:B,:C])\n5-element MultidimensionalTables.EnumerationArray{Symbol,1,MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}},Int64}:\n Nullable(:A)\n Nullable(:A)\n Nullable(:B)\n Nullable(:B)\n Nullable(:C)\n\njulia> enumeration([:A,:A,:B,:B,:C]).pool\n3-element Array{Symbol,1}:\n :A\n :B\n :C\n\njulia> enumeration([:A,:A,:B,:B,:C]).elems\n5-element MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}}:\n 1\n 1\n 2\n 2\n 3\n\njulia> enumeration([:A,:A,:B,:B,:C], [:C,:B])\n5-element MultidimensionalTables.EnumerationArray{Symbol,1,MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}},Int64}:\n Nullable(:A)\n Nullable(:A)\n Nullable(:B)\n Nullable(:B)\n Nullable(:C)\n\njulia> enumeration([:A,:A,:B,:B,:C], [:C,:B]).pool\n3-element Array{Symbol,1}:\n :C\n :B\n :A\n\njulia> enumeration([:A,:A,:B,:B,:C], [:C,:B]).elems\n5-element MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}}:\n 3\n 3\n 2\n 2\n 1  source:  MultidimensionalTables/src/datatypes/enumeration_array.jl:178    MultidimensionalTables.extract  \u00b6  extract(arr, ns...)  Extract a block of array using labels for  LabeledArray s, indices for other types of arrays or  LDict s.  Arguments   arr : an  AbstractArray  or  LDict .  ns... : each element in  ns  chooses specific elements along that direction. The element can be  Colon()  ( : ): the entire range.  a label along that direction. If the axis along the direction is  DictArray , the label can be either an  LDict  for its element or a tuple to denote the values of  LDict .  array of labels along that direction.  a boolean array of the same size as the axis along that direction to denote which position to choose.  a function that takes the axis along that direction and generates either an array of integers or a boolean array for the selected positions.   Return  An array or  LDict  of the same type as  arr , which is selected based on  ns .... All indices will be chosen for the rest of the directions not specified in  ns .... If any label is missing or the integer range is out of bound,  NA  will be used for that element in the return value. If an element in  ns  is scalar, the dimension along that direction will be collapsed just as in  slice .  Examples  julia> t = larr(a=map(x->'a'+x,reshape(0:14,5,3)), b=reshape(1:15,5,3), axis1=[:X,:Y,:Z,:U,:V], axis2=darr(r1=[:A,:A,:B],r2=[:m,:n,:n]))\n5 x 3 LabeledArray\n\nr1 |A   |A    |B    \nr2 |m   |n    |n    \n---+----+-----+-----\n   |a b |a b  |a b  \n---+----+-----+-----\nX  |a 1 |f 6  |k 11 \nY  |b 2 |g 7  |l 12 \nZ  |c 3 |h 8  |m 13 \nU  |d 4 |i 9  |n 14 \nV  |e 5 |j 10 |o 15 \n\n\njulia> extract(t, [:X,:V,:W], map(Nullable,(:A,:m)))\n3 LabeledArray\n\n  |a b \n--+----\nX |a 1 \nV |e 5 \nW |    \n\n\njulia> extract(t, [:X,:V,:W], darr(r1=[:A,:B],r2=[:m,:m]))\n3 x 2 LabeledArray\n\nr1 |A   |B   \nr2 |m   |m   \n---+----+----\n   |a b |a b \n---+----+----\nX  |a 1 |    \nV  |e 5 |    \nW  |    |    \n\n\njulia> extract(t, :, d->d[:r1] .== :A)\n5 x 2 LabeledArray\n\nr1 |A   |A    \nr2 |m   |n    \n---+----+-----\n   |a b |a b  \n---+----+-----\nX  |a 1 |f 6  \nY  |b 2 |g 7  \nZ  |c 3 |h 8  \nU  |d 4 |i 9  \nV  |e 5 |j 10   source:  MultidimensionalTables/src/util/array_util.jl:1399    MultidimensionalTables.flds2axis  \u00b6  flds2axis(arr::LabeledArray [; axisname=nothing, fieldname=nothing])  Create another dimension using the field values of the data of a LabeledArray.  Arguments   arr  : a  LabeledArray .  axisname  (optional) : the name of the new axis.  fieldname  (optional) : the name of the new field name. If not specified, the resulting  LabeledArray  will have a normal  AbstractArray  and not a  DictArray  as its data.   Returns  A new  LabeledArray  which has one higher dimensions than the input  arr .\nThe field names become the elements of the new last axis, after wrapped by  Nullable .\nIf  axisname  is provided, the new axis becomes a  DictArray  with that field name.\nOtherwise, the new axis will be a normal array.\nIf  fieldname  is provided, the new data of the return  LabeledArray  is a  DictArray  with that field name.\nOtherwise, the new data will be a normal array.  Examples  julia> t = larr(a=[1,2,3], b=[:x,:y,:z])\n3 LabeledArray\n\n  |a b \n--+----\n1 |1 x \n2 |2 y \n3 |3 z \n\n\njulia> flds2axis(t, axisname=:newaxis, fieldname=:newfield)\n3 x 2 LabeledArray\n\nnewaxis |a        |b        \n--------+---------+---------\n        |newfield |newfield \n--------+---------+---------\n1       |1        |x        \n2       |2        |y        \n3       |3        |z          source:  MultidimensionalTables/src/util/array_util.jl:509    MultidimensionalTables.igna  \u00b6  igna(arr [, nareplace])  Ignore null elements from  arr .\nNull elements will be replaced by  nareplace , if provided.\nIf not, the behavior is implementation specific: depending on the array type, it may give some default value or raise an error.\nMost likely, a nullable element in an array of  Nullable{F}  element type for some  AbstractFloat   F  can be replaced by a version of  NaN .\nBut for other types, it may be better to raise an error.    igna(arr::AbstractArray{Nullable{T},N} [, na_replace]) : ignores null elements from  arr  and return an  AbstractArray{T,N} . A null value is replaced by  na_replace  if provided. Otherwise, the result is implementation specific.    igna(ldict::LDict [, na_replace])  ignores null values from  ldict  and replace them with  na_replace  if provided. Otherwise, the result is implementation specific.    Examples  julia> igna(@nalift([1,2,NA,4,5]))\nERROR: MultidimensionalTables.NAElementException()\n in anonymous at /Users/changsoonpark/.julia/v0.4/MultidimensionalTables/src/na/na.jl:315\n in map_to! at abstractarray.jl:1289\n in map at abstractarray.jl:1311\n in igna at /Users/changsoonpark/.julia/v0.4/MultidimensionalTables/src/na/na.jl:313\n\njulia> igna(@nalift([1.0,2.0,NA,4.0,5.0]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Float64,1,Array{Float64,1}}:\n   1.0\n   2.0\n NaN  \n   4.0\n   5.0\n\njulia> igna(@nalift([1,2,NA,4,5]), 3)\n5-element MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}}:\n 1\n 2\n 3\n 4\n 5\n\njulia> igna(LDict(:a=>Nullable(3), :b=>Nullable{Int}()), 1)\nMultidimensionalTables.LDict{Symbol,Int64} with 2 entries:\n  :a => 3\n  :b => 1  source:  MultidimensionalTables/src/na/na.jl:483    MultidimensionalTables.ignabool  \u00b6  ignabool(arr)  Ignore the  Nullable  part of of either a  Nullable  array or a  Nullable  variable.\nIt is mainly used in the condition statement for @select or @update, where it assumes that only Nullable(true) chooses the element.  Nullable(false) or Nullable{T}() will be regarded as false.   ignabool(::AbstractArray{Nullable{Bool}}) returns an AbstractArray{Bool} where null and Nullable(false) elements are converted into false and Nullable(true) into true`.  ignabool(::Nullable{Bool})  converts null and  Nullable(false)  elements into  false  and  Nullable(true)  into true.   Examples  julia> ignabool(Nullable{Bool}())\nfalse\n\njulia> ignabool(Nullable(true))\ntrue\n\njulia> ignabool(Nullable(false))\nfalse\n\njulia> ignabool(@nalift([true true NA;false NA true]))\n2x3 MultidimensionalTables.AbstractArrayWrapper{Bool,2,Array{Bool,2}}:\n  true   true  false\n false  false   true  source:  MultidimensionalTables/src/na/na.jl:568    MultidimensionalTables.innerjoin  \u00b6  innerjoin(base, src, join_axis...)  Inner join an LabeledArray into another LabeledArray.  innerjoin  is different from  leftjoin  in that only elements in the left array that have the corresponding elements in the right array will be kept. Otherwise, the elements will be set to null. If the entire elements along some direction are null, they will be all removed in the output.\nNote that the left array (base) can be multidimensional. The function creates a dictionary from the right array ( src ).  Arguments   base  : the left  LabeledArray .  src  : the right  LabeledArray .  join_axes...  can be one of the following forms:  integers for the directions in  src  along which to join.  a list of integer=>integer or integer=>vector of arrays, each array of the same shape as  base .     Ultimately,  join_axes...  produces pairs of direction in  src  => vector of arrays, each of the shape of  base . If the value in key=>value is an integer, the axis along that direction in  base  is taken, after broadcast. The field values are combined into a vector of arrays. If the right hand side is missing (i.e. just an integer), the field names in the axis along the integer direction are used to create an array for  base .  Return  An inner joined  LabeledArray . The join is performed as follows: Given an  i=>arr  form as an element in  join_axes , the keys in  i th direction in  src  are used as keys and  arr  are used the keys in the  base  side to inner join. The values will be the sliced subarrays for each value in the  join_axes . Note that  join_axis...  chooses multiple axes for keys.\nThe output number of dimensions is  ndims(base) + ndims(src) - length(join_axes) .\nNote that when  join_axis  is empty, the result is the tensor product of  base  and  src  from  tensorprod .  Examples  julia> b = larr(k=[:x :x :y;:z :u :v], axis1=[:x,:u], axis2=darr(r=[:x, :y, :z]))\n2 x 3 LabeledArray\n\nr |x |y |z \n--+--+--+--\n  |k |k |k \n--+--+--+--\nx |x |x |y \nu |z |u |v \n\n\njulia> s = larr(axis1=darr(k=[:x,:y,:z,:m,:n,:p]), b=[1,2,3,4,5,6])\n6 LabeledArray\n\nk |b \n--+--\nx |1 \ny |2 \nz |3 \nm |4 \nn |5 \np |6 \n\n\njulia> innerjoin(b, s, 1)\n2 x 3 LabeledArray\n\nr |x   |y   |z   \n--+----+----+----\n  |k b |k b |k b \n--+----+----+----\nx |x 1 |x 1 |y 2 \nu |z 3 |u   |v   \n\n\njulia> innerjoin(b, s, 1=>1)\n1 x 3 LabeledArray\n\nr |x   |y   |z   \n--+----+----+----\n  |k b |k b |k b \n--+----+----+----\nx |x 1 |x 1 |y 1 \n\n\njulia> innerjoin(b, s, 1=>Any[nalift([:o :x :x;:q :r :y])])\n2 x 2 LabeledArray\n\nr |y   |z   \n--+----+----\n  |k b |k b \n--+----+----\nx |x 1 |y 1 \nu |u   |v 2   source:  MultidimensionalTables/src/util/join.jl:288    MultidimensionalTables.isna  \u00b6  isna(arr [, coords...])  Checks  NA  for each element and produces an AbstractArray{Bool} of the same shape as  arr .\nIf  coords...  are provided,  isna  checks  NA  at that position.   If an input array is  AbstractArray{Nullable{T}} , it checkes whether an element is null.  If an input array is  DictArray , it tests whether all values of the dictionary values for each element are null.  If an input array is  LabeledArray , it applies  isna  to the base of  arr .   Examples  julia> t = @darr(a=[1 NA 3;4 5 NA], b=[NA NA :z;:u :v :w])\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n1   |    |3 z \n4 u |5 v |  w \n\n\njulia> isna(t)\n2x3 MultidimensionalTables.AbstractArrayWrapper{Bool,2,Array{Bool,2}}:\n false   true  false\n false  false  false\n\njulia> isna(t, 2, 2:3)\n1x2 MultidimensionalTables.AbstractArrayWrapper{Bool,2,Array{Bool,2}}:\n false  false\n\njulia> isna(@larr(t, axis1[NA,:Y], axis2[NA,NA,\"W\"]))\n2x3 MultidimensionalTables.AbstractArrayWrapper{Bool,2,Array{Bool,2}}:\n false   true  false\n false  false  false\n\njulia> isna(@nalift([1 2 NA;NA 5 6]))\n2x3 MultidimensionalTables.AbstractArrayWrapper{Bool,2,Array{Bool,2}}:\n false  false   true\n  true  false  false  source:  MultidimensionalTables/src/na/na.jl:619    MultidimensionalTables.larr  \u00b6  larr(...)  Create a  LabeledArray . The arguments  ...  can be one of the following:  Arguments   k=>v  creates a field using array  v  with field name  k  for the underlying base  DictArray .  k  can be an arbitrary type. If the element type of  v  is not  Nullable , each element will be wrapped by  Nullable . If you want to manually provide a  Nullable  array with  Nullable{T}()  elements in it, the macro version  @larr  may be more convenient to use. Note that this type of argument precedes the keyword type argument in the return  LabeledArray , as shown in Examples below.  k=v  creates a field using an array  v  with field name  :k  for the underlying base  DictArray .  The keyword  axisN=v  for some integer  N  and an array  v  is treated specially. This will create the  N th axis using the array  v .  There can be at most one non pair type argument, which will be converted into a  LabeledArray  and other pair arguments will update it.\nEspecially, if the non pair type argument is an array of  LDict , it will be converted into a  DictArray .   Examples  julia> t = larr(a=[1 2;3 4;5 6],:b=>[1.0 1.5;:sym 'a';\"X\" \"Y\"],c=1,axis1=[:U,:V,:W],axis2=darr(r=['m','n']))\n3 x 2 LabeledArray\n\nr |m       |n       \n--+--------+--------\n  |b   a c |b   a c \n--+--------+--------\nU |1.0 1 1 |1.5 2 1 \nV |sym 3 1 |a   4 1 \nW |X   5 1 |Y   6 1 \n\n\njulia> larr(t, c=[1 2;3 4;5 6], :d=>:X, axis1=darr(k=[\"g\",\"h\",\"i\"]))\n3 x 2 LabeledArray\n\nr |m         |n         \n--+----------+----------\nk |b   a c d |b   a c d \n--+----------+----------\ng |1.0 1 1 X |1.5 2 2 X \nh |sym 3 3 X |a   4 4 X \ni |X   5 5 X |Y   6 6 X   source:  MultidimensionalTables/src/datatypes/labeled_array.jl:1409    MultidimensionalTables.leftjoin  \u00b6  leftjoin(base, src, join_axis...)  Left join a  LabeledArray  into another  LabeledArray .\nNote that the left array (base) can be multidimensional. The function creates a dictionary from the right array ( src ).  Arguments   base  : the left  LabeledArray .  src  : the right  LabeledArray .  join_axes...  can be one of the following forms:  integers for the directions in  src  along which to join. In this case, the keys is the  base  side are found by matching the field names in the join directions in  src  with those in  base .  a list of integer=>integer or integer=>vector of arrays, each of the same shape as  base .     Ultimately,  join_axes...  produces pairs of direction in  src  => vector of arrays, each of the shape of  base . If the value in key=>value is an integer, the axis along that direction in  base  is taken, after broadcast. The field values are combined into a vector of arrays. If the right hand side is missing (i.e. just an integer), the field names in the axis along the integer direction are used to create an array for  base .  Return  A left joined  LabeledArray . The join is performed as follows: Given an  i=>arr  form as an element in  join_axes , the keys in  i th direction in  src  are used as keys and  arr  are used the keys in the  base  side to left join. The values will be the sliced subarrays for each value in the  join_axes . Note that  join_axis...  chooses multiple axes for keys.\nThe output number of dimensions is  ndims(base) + ndims(src) - length(join_axes) .\nNote that when  join_axis  is empty, the result is the tensor product of  base  and  src  from  tensorprod .  Examples  julia> b = larr(k=[:x :x :y;:z :u :v], axis1=[:x,:y], axis2=darr(r=[:x, :y, :z]))\n2 x 3 LabeledArray\n\nr |x |y |z \n--+--+--+--\n  |k |k |k \n--+--+--+--\nx |x |x |y \ny |z |u |v \n\n\njulia> s = larr(axis1=darr(k=[:x,:y,:z,:m,:n,:p]), b=[1,2,3,4,5,6])\n6 LabeledArray\n\nk |b \n--+--\nx |1 \ny |2 \nz |3 \nm |4 \nn |5 \np |6 \n\n\njulia> leftjoin(b, s, 1)\n2 x 3 LabeledArray\n\nr |x   |y   |z   \n--+----+----+----\n  |k b |k b |k b \n--+----+----+----\nx |x 1 |x 1 |y 2 \ny |z 3 |u   |v   \n\n\njulia> leftjoin(b, s, 1=>1)\n2 x 3 LabeledArray\n\nr |x   |y   |z   \n--+----+----+----\n  |k b |k b |k b \n--+----+----+----\nx |x 1 |x 1 |y 1 \ny |z 2 |u 2 |v 2 \n\n\njulia> leftjoin(b, s, 1=>Any[nalift([:x :z :n;:y :m :p])])\n2 x 3 LabeledArray\n\nr |x   |y   |z   \n--+----+----+----\n  |k b |k b |k b \n--+----+----+----\nx |x 1 |x 3 |y 5 \ny |z 2 |u 4 |v 6   source:  MultidimensionalTables/src/util/join.jl:85    MultidimensionalTables.mapna  \u00b6  mapna(f::Function, args...)  Apply  f  to the nullable arrays  args . It works similarly as  map(f, args...)  but unwraps Nullable from  args . If any of elements are Nullable,  f  is Nullable, too.  Arguments   f::Function : a function to apply.  args : nullable arrays.   Returns  A nullable array after applying  f  to elements of  args  for each index.  f  maps non-nullable value to either non-nullable or nullable one. If mapped to a non-nullable value, it will be wrapped by  Nullable  implicitly. If any element of  args  is  NA , then the return value at that position will be  NA , too.  Examples  julia> mapna((x,y)->x+y+1, @nalift([1 2 3;4 5 NA]), @nalift([NA 2 3;4 NA NA]))\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable{Int64}()  Nullable(5)        Nullable(7)      \n Nullable(9)        Nullable{Int64}()  Nullable{Int64}()\n\njulia> mapna((x,y)->Nullable(x+y+1), @nalift([1 2 3;4 5 NA]), @nalift([NA 2 3;4 NA NA]))\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable{Int64}()  Nullable(5)        Nullable(7)      \n Nullable(9)        Nullable{Int64}()  Nullable{Int64}()  source:  MultidimensionalTables/src/util/array_util.jl:1110    MultidimensionalTables.mapvalues  \u00b6  mapvalues(f::Function, x)  Apply a function  f  to  x , which can be of type  LDict / DictArray / LabeledArray .  Returns   If  x  is  LDict ,  f  is applied to each value and the result is again  LDict  with the same keys and the new values.  If  x  is  DictArray ,  f  is applied to each field. The return value will be  DictArray  if the return value of  f  is also an  AbstractArray . Otherwise, an  LDict  will be returned.  If  x  is  LabeledArray ,  mapvalues(f, _)  is applied to the base of  x . The return value will be  LabeledArray  with the same axes if the return value of  f  is also an  AbstractArray . Otherwise, an  LDict  will be returned.   Examples  julia> mapvalues(x->x+1, LDict(:a=>1, :b=>2))\nMultidimensionalTables.LDict{Symbol,Int64} with 2 entries:\n  :a => 2\n  :b => 3\n\njulia> mapvalues(x->x .+ 1, darr(a=[1,2,3], b=[4,5,6]))\n3 DictArray\n\na b \n----\n2 5 \n3 6 \n4 7 \n\n\njulia> mapvalues(x->x .+ 1, larr(a=[1,2,3], b=[4,5,6], axis1=[:m,:n,:p]))\n3 LabeledArray\n\n  |a b \n--+----\nm |2 5 \nn |3 6 \np |4 7 \n\n\njulia> mapvalues(sum, darr(a=[1,2,3], b=[4,5,6]))\nMultidimensionalTables.LDict{Symbol,Nullable{Int64}} with 2 entries:\n  :a => Nullable(6)\n  :b => Nullable(15)\n\njulia> mapvalues(sum, larr(a=[1,2,3], b=[4,5,6], axis1=[:m,:n,:p]))\nMultidimensionalTables.LDict{Symbol,Nullable{Int64}} with 2 entries:\n  :a => Nullable(6)\n  :b => Nullable(15)  source:  MultidimensionalTables/src/util/array_util.jl:706    MultidimensionalTables.mmaximum  \u00b6  mmaximum(arr, dims... [; rev=false, window=0])  for  arr  of type  AbstractArrayWrapper / LabeledArray / DictArray .  Calculate moving maximum of  arr  using the last  window  elements, or cumulative maximum if  window=0 .  Arguments   arr :  AbstractArrayWrapper / LabeledArray / DictArray , the input array. When applied to  DictArray ,  mmaximum  is applied to each field. When applied to  LabeledArray ,  mmaximum  is applied to the base.  dims : by default  dims=(1,) . That is, moving maximum is performed in the first direction. If  dims=(n1, n2,...) , for each slice spanned along the directions  n1 ,  n2 , ..., moving maximum is taken along the leading dimension in  dims  first (i.e.  minimum(dims) ), and then the next dimension, and so on.  rev : If  rev=true , moving maximum is calculated backward starting for the last elements. By default,  rev=false .  window : If  window>0 , only the last  window  elements, including the one in consideration, will be used to calculate moving maximum. If  window=0 ,  maximum  calculates the cumulative maximum.  NA  will be ignored.   Examples  julia> mmaximum(@nalift([11,14,12,11,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(11)\n Nullable(14)\n Nullable(14)\n Nullable(14)\n Nullable(17)\n\njulia> mmaximum(@nalift([11,NA,12,11,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(11)\n Nullable(11)\n Nullable(12)\n Nullable(12)\n Nullable(17)\n\njulia> mmaximum(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2)\n2 x 3 DictArray\n\na  b  |a  b  |a  b  \n------+------+------\n11 10 |14 10 |15 10 \n14 10 |15 10 |16 10 \n\n\njulia> mmaximum(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 2, 1, rev=true)\n2 x 3 LabeledArray\n\n  |1     |2    |3    \n--+------+-----+-----\n  |a  b  |a  b |a  b \n--+------+-----+-----\n1 |16 10 |16 9 |16 8 \n2 |16 9  |16 8 |16 5   source:  MultidimensionalTables/src/util/array_helper_functions.jl:979    MultidimensionalTables.mmean  \u00b6  mmean(arr, dims... [; rev=false, window=0])  for  arr  of type  AbstractArrayWrapper / LabeledArray / DictArray .  Calculate moving mean of  arr  using the last  window  elements, or cumulative mean if  window=0 .  Arguments   arr :  AbstractArrayWrapper / LabeledArray / DictArray , the input array. When applied to  DictArray ,  mmean  is applied to each field. When applied to  LabeledArray ,  mmean  is applied to the base.  dims : by default  dims=(1,) . That is, moving mean is performed in the first direction. If  dims=(n1, n2,...) , for each slice spanned along the directions  n1 ,  n2 , ..., moving mean is taken along the leading dimension in  dims  first (i.e.  mean(dims) ), and then the next dimension, and so on.  rev : If  rev=true , moving mean is calculated backward starting for the last elements. By default,  rev=false .  window : If  window>0 , only the last  window  elements, including the one in consideration, will be used to calculate moving mean. If  window=0 ,  mean  calculates the cumulative mean.  NA  will be ignored.   Examples  julia> mmean(@nalift([10,11,12,14,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},1,Array{Nullable{Float64},1}}:\n Nullable(10.0) \n Nullable(10.5) \n Nullable(11.0) \n Nullable(11.75)\n Nullable(12.8) \n\njulia> mmean(@nalift([10,NA,12,14,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},1,Array{Nullable{Float64},1}}:\n Nullable(10.0) \n Nullable(10.0) \n Nullable(11.0) \n Nullable(12.0) \n Nullable(13.25)\n\njulia> mmean(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2)\n2 x 3 DictArray\n\na    b    |a                  b                 |a    b   \n----------+-------------------------------------+---------\n11.0 10.0 |12.333333333333334 8.666666666666666 |13.0 8.0 \n12.5 8.5  |13.0               8.0               |13.5 7.5 \n\n\njulia> mmean(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 2, 1, rev=true)\n2 x 3 LabeledArray\n\n  |1        |2                                    |3        \n--+---------+-------------------------------------+---------\n  |a    b   |a                  b                 |a    b   \n--+---------+-------------------------------------+---------\n1 |13.5 7.5 |14.0               7.0               |14.5 6.5 \n2 |14.0 7.0 |14.666666666666666 6.333333333333333 |16.0 5.0   source:  MultidimensionalTables/src/util/array_helper_functions.jl:811    MultidimensionalTables.mmedian  \u00b6  mmedian(arr, dims... [; rev=false, window=0])  for  arr  of type  AbstractArrayWrapper / LabeledArray / DictArray .  Calculate moving median of  arr  using the last  window  elements, or cumulative median if  window=0 .  Arguments   arr :  AbstractArrayWrapper / LabeledArray / DictArray , the input array. When applied to  DictArray ,  mmedian  is applied to each field. When applied to  LabeledArray ,  mmedian  is applied to the base.  dims : by default  dims=(1,) . That is, moving median is performed in the first direction. If  dims=(n1, n2,...) , for each slice spanned along the directions  n1 ,  n2 , ..., moving median is taken along the leading dimension in  dims  first (i.e.  minimum(dims) ), and then the next dimension, and so on.  rev : If  rev=true , moving median is calculated backward starting for the last elements. By default,  rev=false .  window : If  window>0 , only the last  window  elements, including the one in consideration, will be used to calculate moving median. If  window=0 ,  median  calculates the cumulative median.  NA  will be ignored.   Examples  julia> mmedian(@nalift([11,14,12,11,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},1,Array{Nullable{Float64},1}}:\n Nullable(11.0)\n Nullable(12.5)\n Nullable(12.5)\n Nullable(12.5)\n Nullable(14.0)\n\njulia> mmedian(@nalift([11,NA,12,11,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},1,Array{Nullable{Float64},1}}:\n Nullable(11.0)\n Nullable(11.0)\n Nullable(11.5)\n Nullable(11.5)\n Nullable(12.0)\n\njulia> mmedian(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2)\n2 x 3 DictArray\n\na    b    |a    b   |a    b   \n----------+---------+---------\n11.0 10.0 |12.5 8.5 |14.0 8.5 \n12.5 8.5  |14.0 8.5 |14.5 8.5 \n\n\njulia> mmedian(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 2, 1, rev=true)\n2 x 3 LabeledArray\n\n  |1        |2        |3        \n--+---------+---------+---------\n  |a    b   |a    b   |a    b   \n--+---------+---------+---------\n1 |14.5 8.5 |14.5 8.0 |14.5 6.5 \n2 |14.5 8.0 |14.5 6.5 |16.0 5.0   source:  MultidimensionalTables/src/util/array_helper_functions.jl:1043    MultidimensionalTables.mmiddle  \u00b6  mmiddle(arr, dims... [; rev=false, window=0])  for  arr  of type  AbstractArrayWrapper / LabeledArray / DictArray .  Calculate moving middle of  arr  using the last  window  elements, or cumulative middle if  window=0 .  Arguments   arr :  AbstractArrayWrapper / LabeledArray / DictArray , the input array. When applied to  DictArray ,  mmiddle  is applied to each field. When applied to  LabeledArray ,  mmiddle  is applied to the base.  dims : by default  dims=(1,) . That is, moving middle is performed in the first direction. If  dims=(n1, n2,...) , for each slice spanned along the directions  n1 ,  n2 , ..., moving middle is taken along the leading dimension in  dims  first (i.e.  minimum(dims) ), and then the next dimension, and so on.  rev : If  rev=true , moving middle is calculated backward starting for the last elements. By default,  rev=false .  window : If  window>0 , only the last  window  elements, including the one in consideration, will be used to calculate moving middle. If  window=0 ,  middle  calculates the cumulative middle.  NA  will be ignored.   Examples  julia> mmiddle(@nalift([11,14,12,11,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},1,Array{Nullable{Float64},1}}:\n Nullable(11.0)\n Nullable(12.5)\n Nullable(12.5)\n Nullable(12.5)\n Nullable(14.0)\n\njulia> mmiddle(@nalift([11,NA,12,11,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},1,Array{Nullable{Float64},1}}:\n Nullable(11.0)\n Nullable(11.0)\n Nullable(11.5)\n Nullable(11.5)\n Nullable(14.0)\n\njulia> mmiddle(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2)\n2 x 3 DictArray\n\na    b    |a    b   |a    b   \n----------+---------+---------\n11.0 10.0 |12.5 8.5 |13.0 8.0 \n12.5 8.5  |13.0 8.0 |13.5 7.5 \n\n\njulia> mmiddle(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 2, 1, rev=true)\n2 x 3 LabeledArray\n\n  |1        |2        |3        \n--+---------+---------+---------\n  |a    b   |a    b   |a    b   \n--+---------+---------+---------\n1 |13.5 7.5 |14.0 7.0 |14.5 6.5 \n2 |14.0 7.0 |14.5 6.5 |16.0 5.0   source:  MultidimensionalTables/src/util/array_helper_functions.jl:1108    MultidimensionalTables.mminimum  \u00b6  mminimum(arr, dims... [; rev=false, window=0])  for  arr  of type  AbstractArrayWrapper / LabeledArray / DictArray .  Calculate moving minimum of  arr  using the last  window  elements, or cumulative minimum if  window=0 .  Arguments   arr :  AbstractArrayWrapper / LabeledArray / DictArray , the input array. When applied to  DictArray ,  mminimum  is applied to each field. When applied to  LabeledArray ,  mminimum  is applied to the base.  dims : by default  dims=(1,) . That is, moving minimum is performed in the first direction. If  dims=(n1, n2,...) , for each slice spanned along the directions  n1 ,  n2 , ..., moving minimum is taken along the leading dimension in  dims  first (i.e.  minimum(dims) ), and then the next dimension, and so on.  rev : If  rev=true , moving minimum is calculated backward starting for the last elements. By default,  rev=false .  window : If  window>0 , only the last  window  elements, including the one in consideration, will be used to calculate moving minimum. If  window=0 ,  minimum  calculates the cumulative minimum.  NA  will be ignored.   Examples  julia> mminimum(@nalift([15,10,12,11,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(15)\n Nullable(10)\n Nullable(10)\n Nullable(10)\n Nullable(10)\n\njulia> mminimum(@nalift([15,NA,12,11,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(15)\n Nullable(15)\n Nullable(12)\n Nullable(11)\n Nullable(11)\n\njulia> mminimum(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2)\n2 x 3 DictArray\n\na  b  |a  b |a  b \n------+-----+-----\n11 10 |11 7 |11 6 \n11 7  |11 6 |11 5 \n\n\njulia> mminimum(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 2, 1, rev=true)\n2 x 3 LabeledArray\n\n  |1    |2    |3    \n--+-----+-----+-----\n  |a  b |a  b |a  b \n--+-----+-----+-----\n1 |11 5 |12 5 |13 5 \n2 |12 5 |13 5 |16 5   source:  MultidimensionalTables/src/util/array_helper_functions.jl:915    MultidimensionalTables.mprod  \u00b6  mprod(arr, dims... [; rev=false, window=0])  for  arr  of type  AbstractArrayWrapper / LabeledArray / DictArray .  Calculate moving product of  arr  using the last  window  elements, or cumulative product if  window=0 .  Arguments   arr :  AbstractArrayWrapper / LabeledArray / DictArray , the input array. When applied to  DictArray ,  mprod  is applied to each field. When applied to  LabeledArray ,  mprod  is applied to the base.  dims : by default  dims=(1,) . That is, moving product is performed in the first direction. If  dims=(n1, n2,...) , for each slice spanned along the directions  n1 ,  n2 , ..., moving product is taken along the leading dimension in  dims  first (i.e.  prod(dims) ), and then the next dimension, and so on.  rev : If  rev=true , moving product is calculated backward starting for the last elements. By default,  rev=false .  window : If  window>0 , only the last  window  elements, including the one in consideration, will be used to calculate moving product. If  window=0 ,  prod  calculates the cumulative product.  NA  will be ignored.   Examples  julia> mprod(@nalift([10,11,12,14,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(10)    \n Nullable(110)   \n Nullable(1320)  \n Nullable(18480) \n Nullable(314160)\n\njulia> mprod(@nalift([10,NA,12,14,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(10)   \n Nullable(10)   \n Nullable(120)  \n Nullable(1680) \n Nullable(28560)\n\njulia> mprod(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2)\n2 x 3 DictArray\n\na   b  |a     b    |a       b      \n-------+-----------+---------------\n11  10 |1848  630  |360360  30240  \n154 70 |27720 3780 |5765760 151200 \n\n\njulia> mprod(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 2, 1, rev=true)\n2 x 3 LabeledArray\n\n  |1              |2          |3      \n--+---------------+-----------+-------\n  |a       b      |a     b    |a   b  \n--+---------------+-----------+-------\n1 |5765760 151200 |37440 2160 |208 40 \n2 |524160  15120  |3120  240  |16  5    source:  MultidimensionalTables/src/util/array_helper_functions.jl:727    MultidimensionalTables.mquantile  \u00b6  mquantile(arr, quantile, dims... [; rev=false, window=0])  for  arr  of type  AbstractArrayWrapper / LabeledArray / DictArray .  Calculate moving quantile of  arr  using the last  window  elements, or cumulative quantile if  window=0 .  Arguments   arr :  AbstractArrayWrapper / LabeledArray / DictArray , the input array. When applied to  DictArray ,  mquantile  is applied to each field. When applied to  LabeledArray ,  mquantile  is applied to the base.  quantile : a number between 0 and 1 for the quantile to calculate.  dims : by default  dims=(1,) . That is, moving quantile is performed in the first direction. If  dims=(n1, n2,...) , for each slice spanned along the directions  n1 ,  n2 , ..., moving quantile is taken along the leading dimension in  dims  first (i.e.  minimum(dims) ), and then the next dimension, and so on.  rev : If  rev=true , moving quantile is calculated backward starting for the last elements. By default,  rev=false .  window : If  window>0 , only the last  window  elements, including the one in consideration, will be used to calculate moving quantile. If  window=0 ,  quantile  calculates the cumulative quantile.  NA  will be ignored.   Examples  julia> mquantile(@nalift([11,14,12,11,17]), 0.25)\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},1,Array{Nullable{Float64},1}}:\n Nullable(11.0) \n Nullable(11.75)\n Nullable(11.75)\n Nullable(11.75)\n Nullable(12.5) \n\njulia> mquantile(@nalift([11,NA,12,11,17]), 0.25)\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},1,Array{Nullable{Float64},1}}:\n Nullable(11.0) \n Nullable(11.0) \n Nullable(11.25)\n Nullable(11.25)\n Nullable(11.5) \n\njulia> mquantile(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 0.25, 1, 2)\n2 x 3 DictArray\n\na     b    |a     b    |a     b    \n-----------+-----------+-----------\n11.0  10.0 |11.75 7.75 |12.5  7.75 \n11.75 7.75 |12.5  7.75 |13.25 7.75 \n\n\njulia> mquantile(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 0.25, 2, 1, rev=true)\n2 x 3 LabeledArray\n\n  |1          |2          |3          \n--+-----------+-----------+-----------\n  |a     b    |a     b    |a     b    \n--+-----------+-----------+-----------\n1 |13.75 7.25 |13.75 6.5  |13.75 5.75 \n2 |13.75 6.5  |13.75 5.75 |16.0  5.0    source:  MultidimensionalTables/src/util/array_helper_functions.jl:1174    MultidimensionalTables.msum  \u00b6  msum(arr, dims... [; rev=false, window=0])  for  arr  of type  AbstractArrayWrapper / LabeledArray / DictArray .  Calculate moving sum of  arr  using the last  window  elements, or cumulative sum if  window=0 .  Arguments   arr :  AbstractArrayWrapper / LabeledArray / DictArray , the input array. When applied to  DictArray ,  msum  is applied to each field. When applied to  LabeledArray ,  msum  is applied to the base.  dims : by default  dims=(1,) . That is, moving sum is performed in the first direction. If  dims=(n1, n2,...) , for each slice spanned along the directions  n1 ,  n2 , ..., moving sum is taken along the leading dimension in  dims  first (i.e.  sum(dims) ), and then the next dimension, and so on.  rev : If  rev=true , moving sum is calculated backward starting for the last elements. By default,  rev=false .  window : If  window>0 , only the last  window  elements, including the one in consideration, will be used to calculate moving sum. If  window=0 ,  sum  calculates the cumulative sum.  NA  will be ignored.   Examples  julia> msum(@nalift([10,11,12,14,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(10)\n Nullable(21)\n Nullable(33)\n Nullable(47)\n Nullable(64)\n\njulia> msum(@nalift([10,NA,12,14,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(10)\n Nullable(10)\n Nullable(22)\n Nullable(36)\n Nullable(53)\n\njulia> msum(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2)\n2 x 3 DictArray\n\na  b  |a  b  |a  b  \n------+------+------\n11 10 |37 26 |65 40 \n25 17 |52 32 |81 45 \n\n\njulia> msum(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 2, 1, rev=true)\n2 x 3 LabeledArray\n\n  |1     |2     |3     \n--+------+------+------\n  |a  b  |a  b  |a  b  \n--+------+------+------\n1 |81 45 |56 28 |29 13 \n2 |70 35 |44 19 |16 5    source:  MultidimensionalTables/src/util/array_helper_functions.jl:642    MultidimensionalTables.nafill  \u00b6  nafill(arr, dims... [; rev=false, window=0])  for  arr  of type  AbstractArrayWrapper / LabeledArray / DictArray .  Fill forward (backward if  rev=true )  arr  using non-null values from the last  window  elements, or latest non-null value from the beginning if  window=0 .  Arguments   arr :  AbstractArrayWrapper / LabeledArray / DictArray , the input array. When applied to  DictArray ,  nafill  is applied to each field. When applied to  LabeledArray ,  nafill  is applied to the base.  dims : by default  dims=(1,) . That is, the fill forward is performed along the first direction. If  dims=(n1, n2,...) , for each slice spanned along the directions  n1 ,  n2 , ..., the fill forward is taken along the leading dimension in  dims  first (i.e.  sum(dims) ), and then the next dimension, and so on.  rev : If  rev=true , the backward filling is calculated instead, starting for the last elements. By default,  rev=false .  window : If  window>0 , only the last  window  elements, including the one in consideration, will be used to fill forward. If  window=0 ,  nafill  fills forward  arr  using all the elements so far.  NA  will be ignored.   Examples  julia> t = @nalift([1 NA;NA 4;NA NA])\n3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)        Nullable{Int64}()\n Nullable{Int64}()  Nullable(4)      \n Nullable{Int64}()  Nullable{Int64}()\n\njulia> nafill(t)\n3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable{Int64}()\n Nullable(1)  Nullable(4)      \n Nullable(1)  Nullable(4)      \n\njulia> nafill(t,2)\n3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)        Nullable(1)      \n Nullable{Int64}()  Nullable(4)      \n Nullable{Int64}()  Nullable{Int64}()\n\njulia> nafill(t,2,1)\n3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(1)\n Nullable(1)  Nullable(4)\n Nullable(1)  Nullable(4)\n\njulia> nafill(t, rev=true)\n3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)        Nullable(4)      \n Nullable{Int64}()  Nullable(4)      \n Nullable{Int64}()  Nullable{Int64}()\n\njulia> nafill(t, window=2)\n3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)        Nullable{Int64}()\n Nullable(1)        Nullable(4)      \n Nullable{Int64}()  Nullable(4)        source:  MultidimensionalTables/src/util/array_helper_functions.jl:491    MultidimensionalTables.nalift  \u00b6  nalift(arr)  Lift each element in an array  arr  to  Nullable  if it is not already so.\nUnlike  @nalift , it does not perform lifting recursively.\nIt returns  arr  itself when applied to a  DictArray / LabeledArray .  Examples  julia> nalift(Any[[1,2,3],[4,5]])\n2-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Array{Int64,1}},1,Array{Nullable{Array{Int64,1}},1}}:\n Nullable([1,2,3])\n Nullable([4,5])  \n\njulia> nalift([1,2,3])\n3-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(1)\n Nullable(2)\n Nullable(3)\n\njulia> nalift(Any[[1,2,3],[4,5]])\n2-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Array{Int64,1}},1,Array{Nullable{Array{Int64,1}},1}}:\n Nullable([1,2,3])\n Nullable([4,5])  \n\njulia> nalift(darr(a=[1 2;3 4;5 6], b=[:x :y;:z :w;:u :v]))\n3 x 2 DictArray\n\na b |a b \n----+----\n1 x |2 y \n3 z |4 w \n5 u |6 v   source:  MultidimensionalTables/src/na/na.jl:224    MultidimensionalTables.namerge  \u00b6  namerge(xs...)  Combine  Nullable  arrays and  Nullable  elements, having the later arguments override the preceding ones if the new element is not null.  Arguments  xs...  consists of either a  AbstractArrayWrapper  with  Nullable  element type, or a  Nullable  variable. If an element is neither  AbstractArray  or  Nullable , it will be wrapped by  Nullable .  Return   When there is no argument, an error will raise.  If there is only one argument, that argument will be returned.  If there are two arguments and if the two are not  AbstractArray , the second argument will be returned only if it is not null. Otherwise, the first argument will be returned.  If there are two arguments, and the two are  Nullable  arrays, the element at each position will be the one from the first argument if the second argument element is null. Otherwise, the element from the second argument will be used. If any argument is not  AbstractArray , it will be promoted to a  Nullable  array.   Examples  \njulia> namerge(10, @nalift([1 2 NA;4 NA NA]))\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)   Nullable(10)\n Nullable(4)  Nullable(10)  Nullable(10)\n\njulia> namerge(@nalift([1 2 NA;4 NA NA]), 10)\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(10)  Nullable(10)  Nullable(10)\n Nullable(10)  Nullable(10)  Nullable(10)\n\njulia> namerge(10, @nalift([1 2 NA;4 NA NA]))\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)   Nullable(10)\n Nullable(4)  Nullable(10)  Nullable(10)\n\njulia> namerge(@nalift([1 2 NA;4 NA NA]), @nalift([11 NA NA;14 15 NA]))\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(11)  Nullable(2)   Nullable{Int64}()\n Nullable(14)  Nullable(15)  Nullable{Int64}()  source:  MultidimensionalTables/src/util/array_util.jl:2162    MultidimensionalTables.peel  \u00b6  Peel off a variable to see its underlying data.    peel(arr::DictArray) : returns an  LDict  consisting of field name => field values array pairs.    peel(arr::LabeledArray) : returns the underlying data, which can be a  DictArray  but can also be any  AbstractArray .    Examples  julia> peel(darr(a=[1,2,3], b=[:m,:n,:p]))\nMultidimensionalTables.LDict{Symbol,MultidimensionalTables.AbstractArrayWrapper{T,1,A<:AbstractArray{T,N}}} with 2 entries:\n  :a => [Nullable(1),Nullable(2),Nullable(3)]\n  :b => [Nullable(:m),Nullable(:n),Nullable(:p)]\n\njulia> peel(larr(a=[1,2,3], b=[:m,:n,:p], axis1=[\"X\",\"Y\",\"Z\"]))\n3 DictArray\n\na b \n----\n1 m \n2 n \n3 p   source:  MultidimensionalTables/src/util/array_util.jl:763    MultidimensionalTables.pick  \u00b6  Pick fields from a  DictArray  or a  LabeledArray .   pick(arr::DictArray, fieldname) : returns the field value array corresponding to  fieldname .  pick(arr::DictArray, fieldnames::AbstractArray) : returns a  DictArray  whose field names are  fieldnames .  pick(arr::DictArray, fieldnames::Tuple) : returns a vector of field value arrays corresponding to  fieldnames .  pick(arr::DictArray, fieldnames::...)  if there are more than 1 field name in  fieldnames : returns a vector of field value arrays corresponding to the  fieldnames .  pick(arr::LabeledArray, fieldname) : returns the field value array corresponding to  fieldname . If  fieldname  corresponds to a field in an axis, the field value array is broadcast appropriately.  pick(arr::LabeledArray, fieldnames::AbstractArray) : returns a  DictArray  whose field names are  fieldnames .  pick(arr::LabeledArray, fieldnames::Tuple) : returns a vector of field value arrays corresponding to  fieldnames .  pick(arr::LabeledArray, fieldnames::...)  if there are more than 1 field name in  fieldnames : returns a vector of field value arrays corresponding to the  fieldnames .   Examples  julia> pick(darr(a=[1,2,3], b=[:m,:n,:p]), :a)\n3-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(1)\n Nullable(2)\n Nullable(3)\n\njulia> pick(darr(a=[1,2,3], b=[:m,:n,:p]), (:a,))\n1-element Array{MultidimensionalTables.AbstractArrayWrapper{T,1,A<:AbstractArray{T,N}},1}:\n [Nullable(1),Nullable(2),Nullable(3)]\n\njulia> pick(darr(a=[1,2,3], b=[:m,:n,:p]), :a, :b)\n2-element Array{MultidimensionalTables.AbstractArrayWrapper{T,1,A<:AbstractArray{T,N}},1}:\n [Nullable(1),Nullable(2),Nullable(3)]   \n [Nullable(:m),Nullable(:n),Nullable(:p)]\n\njulia> pick(darr(a=[1,2,3], b=[:m,:n,:p]), (:a, :b))\n2-element Array{MultidimensionalTables.AbstractArrayWrapper{T,1,A<:AbstractArray{T,N}},1}:\n [Nullable(1),Nullable(2),Nullable(3)]   \n [Nullable(:m),Nullable(:n),Nullable(:p)]\n\njulia> t = larr(a=[1 2;3 4;5 6], b=[:x :y;:z :u;:v :w], axis1=darr(k=[\"X\",\"Y\",\"Z\"]), axis2=[:A,:B])\n3 x 2 LabeledArray\n\n  |A   |B   \n--+----+----\nk |a b |a b \n--+----+----\nX |1 x |2 y \nY |3 z |4 u \nZ |5 v |6 w \n\n\njulia> pick(t, :a)\npic3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)\n Nullable(3)  Nullable(4)\n Nullable(5)  Nullable(6)\n\njulia> pick(t, :a, :k)\n2-element Array{MultidimensionalTables.AbstractArrayWrapper{T,N,A<:AbstractArray{T,N}},1}:\n 3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)\n Nullable(3)  Nullable(4)\n Nullable(5)  Nullable(6)                                                                                                                                                                                                                                                     \n 3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{ASCIIString},2,MultidimensionalTables.BroadcastAxis{Nullable{ASCIIString},2,MultidimensionalTables.AbstractArrayWrapper{Nullable{ASCIIString},1,Array{Nullable{ASCIIString},1}},MultidimensionalTables.DictArray{Symbol,2,MultidimensionalTables.AbstractArrayWrapper{T,2,A<:AbstractArray{T,N}},Nullable{T}}}}:\n Nullable(\"X\")  Nullable(\"X\")\n Nullable(\"Y\")  Nullable(\"Y\")\n Nullable(\"Z\")  Nullable(\"Z\")\n\njulia> pick(t, (:a, :k))\n2-element Array{MultidimensionalTables.AbstractArrayWrapper{T,N,A<:AbstractArray{T,N}},1}:\n 3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)\n Nullable(3)  Nullable(4)\n Nullable(5)  Nullable(6)                                                                                                                                                                                                                                                     \n 3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{ASCIIString},2,MultidimensionalTables.BroadcastAxis{Nullable{ASCIIString},2,MultidimensionalTables.AbstractArrayWrapper{Nullable{ASCIIString},1,Array{Nullable{ASCIIString},1}},MultidimensionalTables.DictArray{Symbol,2,MultidimensionalTables.AbstractArrayWrapper{T,2,A<:AbstractArray{T,N}},Nullable{T}}}}:\n Nullable(\"X\")  Nullable(\"X\")\n Nullable(\"Y\")  Nullable(\"Y\")\n Nullable(\"Z\")  Nullable(\"Z\")\n\njulia> pick(t, [:a, :k])\n3 x 2 DictArray\n\na k |a k \n----+----\n1 X |2 X \n3 Y |4 Y \n5 Z |6 Z   source:  MultidimensionalTables/src/util/array_util.jl:855    MultidimensionalTables.pickaxis  \u00b6  Pick axes from a  LabeledArray .   pickaxis(arr::LabeledArray)  picks a tuple of axes of  arr .  pickaxis(arr::LabeledArray, index::Integer)  picks the axis along the  index  direction.  pickaxis(arr::LabeledArray, index::Integer, fields...)  picks the fields  fields  from the  index th axis in  arr . It is the same as  pick(pickaxis(arr, index), fields...) .   Examples  julia> t = larr(a=[1 2;3 4;5 6], b=[:x :y;:z :u;:v :w], axis1=darr(k=[\"X\",\"Y\",\"Z\"]), axis2=[:A,:B])\n3 x 2 LabeledArray\n\n  |A   |B   \n--+----+----\nk |a b |a b \n--+----+----\nX |1 x |2 y \nY |3 z |4 u \nZ |5 v |6 w \n\n\njulia> pickaxis(t)\n(3 DictArray\n\nk \n--\nX \nY \nZ \n,[Nullable(:A),Nullable(:B)])\n\njulia> pickaxis(t, 1)\n3 DictArray\n\nk \n--\nX \nY \nZ \n\n\njulia> pickaxis(t, 1, :k)\n3-element MultidimensionalTables.AbstractArrayWrapper{Nullable{ASCIIString},1,Array{Nullable{ASCIIString},1}}:\n Nullable(\"X\")\n Nullable(\"Y\")\n Nullable(\"Z\")  source:  MultidimensionalTables/src/util/array_util.jl:923    MultidimensionalTables.providenames  \u00b6  providenames(arr::LabeledArray, create_fieldname::Funcion)  Add generic field names for fields without field names in a  LabeledArray .\nThis makes the data and all the axes components  DictArray s.\nThis is useful when you want to apply  selct / update / leftjoin / innerjoin  whose interface is friendlier to  DictArray s than general  AbstractArray s.\nThe reverse operation, removing generic field names, is done by  withdrawnames .\nAn optional argument  create_fieldname  is a function that gives a symbol that will be used as a new field name given an integer index.\nBy default, it generates  :xN  for an index integer  N .  Examples  julia> t = larr([1 2 3;4 5 6], axis1=[:X,:Y], axis2=darr(k=[\"A\",\"B\",\"C\"]))\n2 x 3 LabeledArray\n\nk |A |B |C \n--+--+--+--\n  |  |  |  \n--+--+--+--\nX |1 |2 |3 \nY |4 |5 |6 \n\n\njulia> providenames(t)\n2 x 3 LabeledArray\n\nk  |A  |B  |C  \n---+---+---+---\nx2 |x1 |x1 |x1 \n---+---+---+---\nX  |1  |2  |3  \nY  |4  |5  |6    source:  MultidimensionalTables/src/util/array_util.jl:1996    MultidimensionalTables.rename  \u00b6  Description  renames the fields such that the first field names are  names .\nThe rest field names remain the same.  source:  MultidimensionalTables/src/datatypes/labeled_array.jl:1230    MultidimensionalTables.reorder  \u00b6  Description  reorders the fields such that the first field names are  names .\nThe rest field names are placed sequentially after that.  source:  MultidimensionalTables/src/datatypes/labeled_array.jl:1220    MultidimensionalTables.replace_axes  \u00b6  Description  Replace axes with another fields.\nThe args are a list of pairs of the form (integer for the axis index) => new axes fields for this axis.\nOnly the first elements ( arr[:,...,:,1,:,...,:] ) will be taken. That is, if the underlying data array is 2 dimensional, and\nyou want to use the field  column1  as a new key for the 1st axis,  column1[:,1]  will be used as the new axis.\ne.g.  replace_axes(labeled_array, 1=>[:c1,:c2], 3=>[:c3])  source:  MultidimensionalTables/src/util/array_util.jl:353    MultidimensionalTables.selct  \u00b6  selct(t, agg... [; by=[...]..., where=[...]...])  Select a  LabeledArray  or  DictArray  into another by choosing / grouping / aggregating.  Arguments  Below  t'  is an object such that  t'[k]  for a field name  k  gives the corresponding array\nfor the field  k  in the table  t  at the coordinates selected so far.   t  : a  LabeledArray  or  DictArray .  agg...  : each argument can be field names, fieldname=>(t'->nullable array function) pair,  by[...]  or  where[...] . A fieldname=function can be used instead of the pair notation if the fieldname is a symbol.  by=[...] : the first  by=[...]  has an array of similar expressions and determines the 1st axis. The second  by=[...]  similarly determines the 2nd axis. The output  LabeledArray  will have dimensions of the number of  by[...]  clauses, or the original dimensions if no  by[...]  is provided.  where=[...] : has ( t' ->nullable boolean array) functions inside and chooses the appropriate portion of the original array. Multiple  where=[...]  will simply be combined.   Return  A  LabeledArray  transformed by  args...  if  t  is a  LabeledArray .\nIf  t  is  DictArray  and the transformed  LabeledArray  has  DefaultAxis  along each direction, the return value is also a  DictArray . Otherwise it is a  LabeledArray .  Examples  julia> t = @larr(a=1:10, b=[1,2,3,NA,NA,NA,1,1,2,3], c=[:x,:x,:x,:x,:y,:y,:y,:z,:z,:z])\n10 LabeledArray\n\n   |a  b c \n---+-------\n1  |1  1 x \n2  |2  2 x \n3  |3  3 x \n4  |4    x \n5  |5    y \n6  |6    y \n7  |7  1 y \n8  |8  1 z \n9  |9  2 z \n10 |10 3 z \n\n\njulia> selct(t, :a, :b=>d->d[:b] .* 2)\n10 LabeledArray\n\n   |a  b \n---+-----\n1  |1  2 \n2  |2  4 \n3  |3  6 \n4  |4    \n5  |5    \n6  |6    \n7  |7  2 \n8  |8  2 \n9  |9  4 \n10 |10 6 \n\n\njulia> selct(t, :a, :b=>d->d[:b] .* 2, where=[d->d[:c] .!= :z], where=[d->d[:a] .> 2])\n5 LabeledArray\n\n  |a b \n--+----\n1 |3 6 \n2 |4   \n3 |5   \n4 |6   \n5 |7 2 \n\n\njulia> selct(t, a=d->mean(d[:a]), b=d->sum(d[:b] .* 2), by=Any[:d=>d->d[:b] .* 2], by=[:c])\n4 x 3 LabeledArray\n\nc |x     |y     |z      \n--+------+------+-------\nd |a   b |a   b |a    b \n--+------+------+-------\n  |4.0 0 |5.5 0 |       \n2 |1.0 2 |7.0 2 |8.0  2 \n4 |2.0 4 |      |9.0  4 \n6 |3.0 6 |      |10.0 6   source:  MultidimensionalTables/src/util/select.jl:823    MultidimensionalTables.shift  \u00b6  shift(arr, offsets... [; isbound=false])  Parallel shift the input array  arr  so that the element at  [1,...,1]  in  arr  shows up at  [1,...,1]+offsets  in the return array.  Arguments   arr :  AbstractArrayWrapper / LabeledArray / DictArray , the input array. When applied to  DictArray ,  shift  is applied to each field. When applied to  LabeledArray ,  shift  is applied to the base.  offsets : integers to denote the amount of offset for each direction. It is assumed that there is no shift in the missing direcitons.  isbound : default  false . If  true , the index is floored and capped between 1 and the maximum possible index along that direction. If  false , any out of bound index due to shifting results in a nullable element.   Examples  julia> shift(nalift([1 2 3;4 5 6;7 8 9]), 1, 1)\n3x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(5)        Nullable(6)        Nullable{Int64}()\n Nullable(8)        Nullable(9)        Nullable{Int64}()\n Nullable{Int64}()  Nullable{Int64}()  Nullable{Int64}()\n\njulia> shift(nalift([1 2 3;4 5 6;7 8 9]), 1, 01)\n3x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(5)        Nullable(6)        Nullable{Int64}()\n Nullable(8)        Nullable(9)        Nullable{Int64}()\n Nullable{Int64}()  Nullable{Int64}()  Nullable{Int64}()\n\njulia> shift(nalift([1 2 3;4 5 6;7 8 9]), 1, 1)\n3x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(5)        Nullable(6)        Nullable{Int64}()\n Nullable(8)        Nullable(9)        Nullable{Int64}()\n Nullable{Int64}()  Nullable{Int64}()  Nullable{Int64}()\n\njulia> shift(nalift([1 2 3;4 5 6;7 8 9]), 1, -1)\n3x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable{Int64}()  Nullable(4)        Nullable(5)      \n Nullable{Int64}()  Nullable(7)        Nullable(8)      \n Nullable{Int64}()  Nullable{Int64}()  Nullable{Int64}()\n\njulia> shift(darr(a=[1 2 3;4 5 6;7 8 9]), 1, -1)\n3 x 3 DictArray\n\na |a |a \n--+--+--\n  |4 |5 \n  |7 |8 \n  |  |  \n\n\njulia> shift(larr(a=[1 2 3;4 5 6;7 8 9], axis2=[:X,:Y,:Z]), 1, -1)\n3 x 3 LabeledArray\n\n  |X |Y |Z \n--+--+--+--\n  |a |a |a \n--+--+--+--\n1 |  |4 |5 \n2 |  |7 |8 \n3 |  |  |    source:  MultidimensionalTables/src/util/array_helper_functions.jl:1408    MultidimensionalTables.tensorprod  \u00b6  tensorprod(arrs...)  Calculate the tensor product of  arrs .   tensorprod(::AbstractArray...)  calculates the tensor product where the product operation creates a tuple of the input elements at each position, if every input element at that position is not  NA . Otherwise, the result will be  NA .  tensorprod(::DictArray...)  calculates the tensor product where the product operation creates a merged  LDict  of the input  LDict s at each position.  tensorprod(::LabeledArray...)  calculates the tensor product of the bases of the inputs, which will be used as the base of the return  LabeledArray . The axes of the return value will be appropriately extended version of the inputs.   Examples  julia> tensorprod(@nalift([1,2,NA]), @nalift([3,NA]))\n3x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Tuple{Int64,Int64}},2,Array{Nullable{Tuple{Int64,Int64}},2}}:\n Nullable((1,3))                 Nullable{Tuple{Int64,Int64}}()\n Nullable((2,3))                 Nullable{Tuple{Int64,Int64}}()\n Nullable{Tuple{Int64,Int64}}()  Nullable{Tuple{Int64,Int64}}()\n\njulia> tensorprod(@darr(a=[1,2,NA]), @darr(b=[3,NA]))\n3 x 2 DictArray\n\na b |a b \n----+----\n1 3 |1   \n2 3 |2   \n  3 |    \n\n\njulia> tensorprod(@larr(a=[1,2,NA], axis1[:m,:n,:p]), @larr(b=[3,NA], axis1[:X,:Y]))\n3 x 2 LabeledArray\n\n  |X   |Y   \n--+----+----\n  |a b |a b \n--+----+----\nm |1 3 |1   \nn |2 3 |2   \np |  3 |      source:  MultidimensionalTables/src/util/array_util.jl:1198    MultidimensionalTables.ungroup  \u00b6  ungroup(arr, ...)  Ungroup array elements in an array into scalar elements along some direction.  Arguments   arr  : an array.  ...  can be  axis ,  indices , or  ref_field  : either an axis index along which to ungroup, a range tuple coordinates of the form  (i_1,...,i_k,:,i_{k+1},...,i_n)  for some integer i's, or the selected elements of  arr  after applying those types of tuples.   Return  An ungrouped array of the same type as  arr . If  arr  is  LabeledArray , the axis along the ungrouping direction will become a new field (a generic field name is provided if it was not a  DictArray  axis.  Examples  julia> t = larr(a=Any[[1,2,3],[4,5]], b=[:x,:x], c=Any[[11,12,13],[14,15]], axis1=[:X,:Y])\n2 LabeledArray\n\n  |a       b c          \n--+---------------------\nX |[1,2,3] x [11,12,13] \nY |[4,5]   x [14,15]    \n\n\njulia> ungroup(t, 1)\n5 LabeledArray\n\n  |x1 a b c  \n--+----------\n1 |X  1 x 11 \n2 |X  2 x 12 \n3 |X  3 x 13 \n4 |Y  4 x 14 \n5 |Y  5 x 15 \n\n\njulia> ungroup(t, (:,1))\n5 LabeledArray\n\n  |x1 a b c  \n--+----------\n1 |X  1 x 11 \n2 |X  2 x 12 \n3 |X  3 x 13 \n4 |Y  4 x 14 \n5 |Y  5 x 15 \n\n\njulia> m = nalift(reshape(Any[[1,2],[3,4],[5,6,7],[8,9,10]],2,2))\n2x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Array{Int64,1}},2,Array{Nullable{Array{Int64,1}},2}}:\n Nullable([1,2])  Nullable([5,6,7]) \n Nullable([3,4])  Nullable([8,9,10])\n\njulia> ungroup(m, 2)\n2x5 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)  Nullable(5)  Nullable(6)  Nullable(7) \n Nullable(3)  Nullable(4)  Nullable(8)  Nullable(9)  Nullable(10)  source:  MultidimensionalTables/src/util/ungroup.jl:64    MultidimensionalTables.update  \u00b6  update(t, agg... [; by=[...]..., where=[...]...])  Similar to  selct , but is used to update and create a new  LabeledArray  or  DictArray  from the original one.\nThe main difference from the  selct  function is that it keeps the original fields intact, unless\ndirected otherwise, whereas the  select  macro only chooses the fields that are explicitly specified.  Arguments  Below  t'  is an object such that  t'[k]  for a field name  k  gives the corresponding array\nfor the field  k  in the table  t  at the coordinates selected so far.   t  : a LabeledArray or  DictArray .  agg...  : each argument can be field names, fieldname=>(t'->nullable array function) pair,  by[...]  or  where[...] . A fieldname=function can be used instead of the pair notation if the fieldname is a symbol.  by=[...] :  by[...]  has ( t' ->nullable array) as its elements and used as in grouping when updateing. Multiple  by[...]  are simply combined.  where=[...] : has ( t' ->nullable boolean array) functions inside and chooses the appropriate portion of the original array. Multiple  where=[...]  will simply be combined.   Return  An updated array of the same type as  t .  Examples  julia> t = @larr(a=1:10, b=[1,2,3,NA,NA,NA,1,1,2,3], c=[:x,:x,:x,:x,:y,:y,:y,:z,:z,:z])\n10 LabeledArray\n\n   |a  b c \n---+-------\n1  |1  1 x \n2  |2  2 x \n3  |3  3 x \n4  |4    x \n5  |5    y \n6  |6    y \n7  |7  1 y \n8  |8  1 z \n9  |9  2 z \n10 |10 3 z \n\n\njulia> update(t, a=d->d[:a] .+ 100, d=d->d[:a] .* d[:b])\n10 LabeledArray\n\n   |a   b c d  \n---+-----------\n1  |101 1 x 1  \n2  |102 2 x 4  \n3  |103 3 x 9  \n4  |104   x    \n5  |105   y    \n6  |106   y    \n7  |107 1 y 7  \n8  |108 1 z 8  \n9  |109 2 z 18 \n10 |110 3 z 30 \n\n\njulia> update(t, a=d->d[:a] .+ 100, d=d->d[:a] .* d[:b], where=[d-> ~isna(d[:b])])\n10 LabeledArray\n\n   |a   b c d  \n---+-----------\n1  |101 1 x 1  \n2  |102 2 x 4  \n3  |103 3 x 9  \n4  |4     x    \n5  |5     y    \n6  |6     y    \n7  |107 1 y 7  \n8  |108 1 z 8  \n9  |109 2 z 18 \n10 |110 3 z 30 \n\n\njulia> update(t, a=d->sum(d[:a]), d=d->reverse(d[:a] .* d[:b]), where=[d-> ~isna(d[:b])], by=[:b])\n10 LabeledArray\n\n   |a  b c d  \n---+----------\n1  |16 1 x 8  \n2  |11 2 x 18 \n3  |13 3 x 30 \n4  |4    x    \n5  |5    y    \n6  |6    y    \n7  |16 1 y 7  \n8  |16 1 z 1  \n9  |11 2 z 4  \n10 |13 3 z 9    source:  MultidimensionalTables/src/util/select.jl:1042    MultidimensionalTables.withdrawnames  \u00b6  withdrawnames(arr::LabeledArray, check_fieldname::Function)  Remove generic field names from a  LabeledArray  if possible.  Arguments   arr  is an input  LabeledArray .  check_fieldname  is a function that returns whether an input field name is a generic name. By default, a field name is generic if it is a symbol of the form  :xN  for some integer  N .   Return  If a field name in  LabeledArray  gives  true  when applied to  check_fieldname , and the field name can be removed, it is removed in the return  LabeledArray . A field name can be removed if it is a part of a  DictArray  with only one field.  Examples  julia> t = larr([1 2 3;4 5 6], axis1=[:X,:Y], axis2=darr(k=[\"A\",\"B\",\"C\"]))\n2 x 3 LabeledArray\n\nk |A |B |C \n--+--+--+--\n  |  |  |  \n--+--+--+--\nX |1 |2 |3 \nY |4 |5 |6 \n\n\njulia> providenames(t)\n2 x 3 LabeledArray\n\nk  |A  |B  |C  \n---+---+---+---\nx2 |x1 |x1 |x1 \n---+---+---+---\nX  |1  |2  |3  \nY  |4  |5  |6  \n\n\njulia> withdrawnames(providenames(t))\n2 x 3 LabeledArray\n\nk |A |B |C \n--+--+--+--\n  |  |  |  \n--+--+--+--\nX |1 |2 |3 \nY |4 |5 |6   source:  MultidimensionalTables/src/util/array_util.jl:2068    rename(arr::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  ks...)  \u00b6  rename(arr::LabeledArray, ks...)  Rename the field names of the base of  arr  so that the first few field names are  ks .  Return  A new  LabeledArray  whose first few field names of the base of  arr  are  ks .  source:  MultidimensionalTables/src/datatypes/labeled_array.jl:1256    rename(ldict::MultidimensionalTables.LDict{K, V},  ks...)  \u00b6  rename(ldict::LDict, ks...)  Renames the first few keys using  ks .  Examples  julia> rename(LDict(:a=>1, :b=>2, :c=>3), :b, 'x')\nMultidimensionalTables.LDict{Any,Int64} with 3 entries:\n  :b  => 1\n  'x' => 2\n  :c  => 3  source:  MultidimensionalTables/src/datatypes/ldict.jl:300    reorder(arr::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  ks...)  \u00b6  reorder(arr::LabeledArray, ks...)  Reorder the field names of the base of  arr  so that the first few field names are  ks .\nThe base of  arr  is expected to be a  DictArray .  Return  A new  LabeledArray  whose base fields are shuffled from  arr  so that the first few field names are  ks .  source:  MultidimensionalTables/src/datatypes/labeled_array.jl:1244    reorder(ldict::MultidimensionalTables.LDict{K, V},  ks...)  \u00b6  reorder(ldict::LDict, ks...)  Reorder the keys so that the first few keys are  ks .  Examples  julia> reorder(LDict(:a=>1, :b=>2, :c=>3), :b, :c)\nMultidimensionalTables.LDict{Symbol,Int64} with 3 entries:\n  :b => 2\n  :c => 3\n  :a => 1  source:  MultidimensionalTables/src/datatypes/ldict.jl:281    replace_axes(arr::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  args...)  \u00b6  replace_axes(arr::LabeledArray, args...)  Arguments   arr : an input  LabeledArray . Note the data part of  arr  and the axis to replace need to be  DictArray s.  args... : arguments in  args  are of the form  i=>[f1,f2,...]  for some integer  i  and field names  f* .   Returns  For each  i=>[f1,f2,...]  in  args , the  i th axis is replaced by the fields  f1 ,  f2 , ....\nOnly the first elements will be taken. For example, if the underlying data array is 2 dimensional, and if you want to use some field for the 1st axis,  [:,1]  components will be used.\nThe original axis becomes the data part of  LabeledArray  after properly broadcast.\nIf the field name array is null for an argument in  args  ( i=>[] ), the corresponding axis will be  DefaultAxis .  Examples  julia> t = larr(a=[1 2 3;4 5 6], b=['a' 'b' 'c';'d' 'e' 'f'], axis1=darr(k=[:x,:y]), axis2=[\"A\",\"B\",\"C\"])\n2 x 3 LabeledArray\n\n  |A   |B   |C   \n--+----+----+----\nk |a b |a b |a b \n--+----+----+----\nx |1 a |2 b |3 c \ny |4 d |5 e |6 f \n\n\njulia> replace_axes(t, 1=>[:a])\n2 x 3 LabeledArray\n\n  |A   |B   |C   \n--+----+----+----\na |b k |b k |b k \n--+----+----+----\n1 |a x |b x |c x \n4 |d y |e y |f y \n\n\njulia> replace_axes(t, 1=>[:a, :b])\n2 x 3 LabeledArray\n\n    |A |B |C \n----+--+--+--\na b |k |k |k \n----+--+--+--\n1 a |x |x |x \n4 d |y |y |y   source:  MultidimensionalTables/src/util/array_util.jl:407    MultidimensionalTables.DictArray{K, N, VS, SV}  \u00b6  A multidimensional array whose elements are ordered dictionaries with common keys.\nInternally, it is represented as an ordered dictionary from keys to multidimensional arrays.\nNote that most functions return a new  DictArray  rather than modify the existing one.\nHowever, the new  DictArray  just shallow copies the key vector and the value vector\nof the underlying  LDict . Therefore, creating a new  DictArray  is cheap, but you have to be\ncareful when you modify the underlying array elements directly.  Because a  DictArray  can be multidimensional we will call the keys in the key vector of the underlying  LDict  the  field names .\nThe values in the value vector will be called  fields . With a slight bit of abuse of notation, we sometimes call a field name and a field tuple collectively just a field.  Use the function  darr  to construct a  DictArray .  Constructors  DictArraay is internally just a wrapper of  LDict . Therefore, the constructors takes the same kind of arguments:  DictArray(data::LDict{K,V})\nDictArray{K,V}(dict::Dict{K,V})\nDictArray{K,V}(dict::Dict{K,V}, ks)\nDictArray{K}(ks::Vector{K}, vs::Vector)\nDictArray(ps::Pair...)\nDictArray(tuples::Tuple...)\nDictArray(;kwargs...)  source:  MultidimensionalTables/src/datatypes/dict_array.jl:31    MultidimensionalTables.EnumerationArray{T, N, V, R<:Integer}  \u00b6  An array type to store elements that have only a few choices.\nThat is, it is a pooled array.\nUse  enumeration  to create an  EnumerationArray .  source:  MultidimensionalTables/src/datatypes/enumeration_array.jl:8    MultidimensionalTables.LDict{K, V}  \u00b6  LDict is an ordered dictionary. It is assumed to be used in the field name => field mapping. In practice, the number of columns is not that long, and it is more efficient to implement LDict as 2 vectors, one for keys and one for values.  Constructors  LDict{K,V}(dict::Associative{K, V}) # LDict from a dictionary dict. The result order is undetermined.\nLDict{K,V}(dict::Associative{K, V}, ks) # LDict from a dictionary dict. ks is a vector of keys, and the keys in the result are ordered in that way. An error is thrown if one of ks is not found in dict.\nLDict{K,V}(ks::Vector{K}, vs::Vector{V})\nLDict(ps::Pair...)\nLDict(ps::Tuple...)  source:  MultidimensionalTables/src/datatypes/ldict.jl:18    MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN}  \u00b6  A multidimensional array together with additional axes attached to it.\nEach axis is a one dimensional array, possibly a  DictArray .\nUse the function  larr  or a macro version  @larr  to create  LabeledArray s, rather than call the constructor directly.  A  LabeledArray  consists of one main array, which we call the  base  array, and an axis array for each direction.  Constructors   LabeledArray(arr, axes)  creates a  LabeledArray  from a  base  array  arr  and a tuple  axes  of one dimensional arrays for axes.  LabeledArray(arr; kwargs...)  creates a  LabeledArray  from a  base  array  arr  and a keyword argument of the form  axisN=V  for some integer  N  for the axis direction and a one dimensional array  V .   source:  MultidimensionalTables/src/datatypes/labeled_array.jl:16    @darr(args...)  \u00b6  @darr(...)  Create a  DictArray . The arguments  ...  can be one of the following:  Arguments   k=>v  creates a field using an array  v  with field name  k .  k  can be an arbitrary type. If the element type of  v  is not  Nullable , each element will be wrapped by  Nullable . If  NA  is provided as an element, it is translated as  Nullable{T}()  for an appropriate type  T .  k=v  creates a field using an array  v  with field name  :k .  There can be at most one non pair type argument, which will be converted into a  DictArray  and other pair arguments will update it.   Examples  julia> t = @darr(a=[1 2;NA 4;5 NA],b=[\"abc\" NA;1 2;:m \"xyz\"],:c=>[NA 1.5;:sym 'a';\"X\" \"Y\"])\n3 x 2 DictArray\n\na b   c   |a b   c   \n----------+----------\n1 abc     |2     1.5 \n  1   sym |4 2   a   \n5 m   X   |  xyz Y   \n\n\njulia> @darr(t, c=[1 2;3 4;5 6], \"d\"=>map(Nullable, [1 2;3 4;5 6]))\n3 x 2 DictArray\n\na b   c d |a b   c d \n----------+----------\n1 abc 1 1 |2     2 2 \n  1   3 3 |4 2   4 4 \n5 m   5 5 |  xyz 6 6   source:  MultidimensionalTables/src/datatypes/dict_array.jl:1209    @enumeration(args...)  \u00b6  @enumeration(arr [, poolorder])  Create an  EnumerationArray . Similar to the  enumeration  function, but you can type in a null element using  NA .  Arguments   arr : an input array of  Nullable  element type. It is assumed that there are only a few possible values in  arr  and each value is converted into an integer when creating an  EnumerationArray .  NA  is translated into a null element of appropriate type.  poolorder : a vector to fix some of the integer values in the mapping from the values in  arr  to integers. If there are  n  elements in  poolorder , those  n  elements in  arr  will be assigned 1... n  when creating an  EnumerationArray . All the others are assigned integers in order of their appearance.   Examples  julia> @enumeration([:A,:A,:B,NA,NA])\n5-element MultidimensionalTables.EnumerationArray{Symbol,1,MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}},Int64}:\n Nullable(:A)      \n Nullable(:A)      \n Nullable(:B)      \n Nullable{Symbol}()\n Nullable{Symbol}()\n\njulia> @enumeration([:A,:A,:B,NA,NA]).pool\n2-element Array{Symbol,1}:\n :A\n :B\n\njulia> @enumeration([:A,:A,:B,NA,NA]).elems\n5-element MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}}:\n 1\n 1\n 2\n 0\n 0\n\njulia> @enumeration([:A,:A,:B,NA,NA], [:B,:A])\n5-element MultidimensionalTables.EnumerationArray{Symbol,1,MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}},Int64}:\n Nullable(:A)      \n Nullable(:A)      \n Nullable(:B)      \n Nullable{Symbol}()\n Nullable{Symbol}()\n\njulia> @enumeration([:A,:A,:B,NA,NA], [:B,:A]).pool\n2-element Array{Symbol,1}:\n :B\n :A\n\njulia> @enumeration([:A,:A,:B,NA,NA], [:B,:A]).elems\n5-element MultidimensionalTables.AbstractArrayWrapper{Int64,1,Array{Int64,1}}:\n 2\n 2\n 1\n 0\n 0  source:  MultidimensionalTables/src/datatypes/enumeration_array.jl:247    @larr(args...)  \u00b6  @larr(...)  Create a  LabeledArray . The arguments  ...  can be one of the following:  Arguments   k=>v  creates a field using array  v  with field name  k  for the base of the return  LabeledArray .  k  can be an arbitrary type. If the element type of  v  is not  Nullable , each element will be wrapped by  Nullable . If  NA  is provided as an element, it is translated as  Nullable{T}()  for an appropriate type  T .  k=v  creates a field using array  v  of the base with field name  :k .  There can be at most one non pair type argument, which will be converted into a  LabeledArray  and other pair arguments will update it.  axisN[...]  for some integer  N : this creates an axis along the  N th direction. If  ...  are either keywords or pairs, those are used to create a  DictArray . Otherwise, an array will be created using  ... .   Examples  julia> t = @larr(a=[1 NA;3 4;NA NA],:b=>[1.0 1.5;:sym 'a';\"X\" \"Y\"],c=1,axis1[:U,NA,:W],axis2[r=['m','n']])\n3 x 2 LabeledArray\n\nr |m       |n       \n--+--------+--------\n  |a b   c |a b   c \n--+--------+--------\nU |1 1.0 1 |  1.5 1 \n  |3 sym 1 |4 a   1 \nW |  X   1 |  Y   1 \n\n\njulia> @larr(t, c=[NA NA;3 4;5 6], :d=>:X, axis1[k=[\"g\",\"h\",\"i\"]])\n3 x 2 LabeledArray\n\nr |m         |n         \n--+----------+----------\nk |a b   c d |a b   c d \n--+----------+----------\ng |1 1.0   X |  1.5   X \nh |3 sym 3 X |4 a   4 X \ni |  X   5 X |  Y   6 X   source:  MultidimensionalTables/src/datatypes/labeled_array.jl:1299    @nalift(expr)  \u00b6  @nalift(arr)  Lift each element in an array  arr  to  Nullable  if it is not already so.\nIt is mainly used to translate a manually typed array expression such as  [1,2,3,NA,5]  into a  Nullable  array.\nUnlike  nalift , it performs lifting recursively.\nIt returns  arr  itself when applied to a  DictArray / LabeledArray .  Examples  julia> @nalift([1,2,3])\n3-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(1)\n Nullable(2)\n Nullable(3)\n\njulia> @nalift([1,2,NA])\n3-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(1)      \n Nullable(2)      \n Nullable{Int64}()\n\njulia> @nalift(Any[[1,2,3],[NA,5]])\n2-element MultidimensionalTables.AbstractArrayWrapper{Nullable{MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}},1,Array{Nullable{MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}},1}}:\n Nullable([Nullable(1),Nullable(2),Nullable(3)])\n Nullable([Nullable{Int64}(),Nullable(5)])      \n\njulia> @nalift(larr(a=[1 2;3 4;5 6], b=[:x :y;:z :w;:u :v]))\n3 x 2 LabeledArray\n\n  |1   |2   \n--+----+----\n  |a b |a b \n--+----+----\n1 |1 x |2 y \n2 |3 z |4 w \n3 |5 u |6 v   source:  MultidimensionalTables/src/na/na.jl:335    @rap(args...)  \u00b6  @rap(args...)  Apply right-to-left evaluation order to the arguments.\nAn argument having an underscore symbol except the last one is translated into the function  x ->(that expression replacing _ by  x ).  Examples  julia> @rap _+3 5\n8\n\njulia> @rap _*2 x->x+1 10\n22\n\njulia> @rap (_ .* 2) reverse @nalift [1,2,NA,4,5]\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(10)     \n Nullable(8)      \n Nullable{Int64}()\n Nullable(4)      \n Nullable(2)        source:  MultidimensionalTables/src/util/array_util.jl:282    @select(t, args...)  \u00b6  @select(t, args...)  Select macro transforms a  LabeledArray  or  DictArray  into another by choosing / grouping / aggregating.  Arguments  Below  t'  is an object such that  t'[k]  for a field name  k  gives the corresponding array\nfor the field  k  in the table  t  at the coordinates selected so far.   t  : a  LabeledArray  or  DictArray .  args...  : each argument can be field names, fieldname=>(t'->nullable array function) pair,  by[...]  or  where[...] . A fieldname=function can be used instead of the pair notation if the fieldname is a symbol. The first  by[...]  has an array of similar expressions and determines the 1st axis. The second  by[...]  similarly determines the 2nd axis. The output  LabeledArray  will have dimensions of the number of  by[...]  clauses, or the original dimensions if no  by[...]  is provided.  where[...]  has ( t' ->nullable boolean array) functions inside and chooses the appropriate portion of the original array. Multiple  where[...]  will simply be combined.   Function Specification  Note that a function ( t' ->nullable array) is expressed by some  expression  with variable names with underscores. The  expression  is converted into `t''-> expression . Symbols with underscores are converted in the following way:   _k  : translates to  t'[k] . The field name  k  should be a symbol.  _!k  : translates to  isna(t')[k] . It gives a boolean array to denote whether an element is null. The field name  k  should be a symbol.  _  : translates to  t'  if none of the above is applicable. It is useful when the field name is not a symbol.   Return  A  LabeledArray  transformed by  args...  if  t  is a  LabeledArray .\nIf  t  is  DictArray  and the transformed  LabeledArray  has  DefaultAxis  along each direction, the return value is also a  DictArray . Otherwise it is a  LabeledArray .  Examples  julia> t = @larr(a=1:10, b=[1,2,3,NA,NA,NA,1,1,2,3], c=[:x,:x,:x,:x,:y,:y,:y,:z,:z,:z])\n10 LabeledArray\n\n   |a  b c \n---+-------\n1  |1  1 x \n2  |2  2 x \n3  |3  3 x \n4  |4    x \n5  |5    y \n6  |6    y \n7  |7  1 y \n8  |8  1 z \n9  |9  2 z \n10 |10 3 z \n\n\njulia> @select(t, :a, :b=>_b .* 2)\n10 LabeledArray\n\n   |a  b \n---+-----\n1  |1  2 \n2  |2  4 \n3  |3  6 \n4  |4    \n5  |5    \n6  |6    \n7  |7  2 \n8  |8  2 \n9  |9  4 \n10 |10 6 \n\n\njulia> @select(t, :a, :b=>_b .* 2, where[_c .!= :z], where[_a .> 2])\n5 LabeledArray\n\n  |a b \n--+----\n1 |3 6 \n2 |4   \n3 |5   \n4 |6   \n5 |7 2 \n\n\njulia> @select(t, a=mean(_a), b=sum(_b .* 2), by[d=_b .* 2], by[:c])\n4 x 3 LabeledArray\n\nc |x     |y     |z      \n--+------+------+-------\nd |a   b |a   b |a    b \n--+------+------+-------\n  |4.0 0 |5.5 0 |       \n2 |1.0 2 |7.0 2 |8.0  2 \n4 |2.0 4 |      |9.0  4 \n6 |3.0 6 |      |10.0 6   source:  MultidimensionalTables/src/util/select.jl:734    @update(t, args...)  \u00b6  @update(t, args...)  Similar to  select  macro, but is used to update and create a new  LabeledArray  or  DictArray  from the original one.\nThe main difference from the  select  macro is that it keeps the original fields intact, unless\ndirected otherwise, whereas the  select  macro only chooses the fields that are explicitly specified.  Arguments  Below  t'  is an object such that  t'[k]  for a field name k gives the corresponding array\nfor the field  k  in the table  t  at the coordinates selected so far.   t  : a  LabeledArray  or  DictArray .  args...  : each argument can be field names, fieldname=>( t' ->nullable array function) pair or  where[...] . A fieldname=function can be used instead of the pair notation if the fieldname is a symbol.  by[...]  has ( t' ->nullable array) as its elements and used as in grouping when updateing. Multiple  by[...]  are simply combined.  where[...]  has\n( t' ->nullable boolean array) functions inside and chooses the appropriate portion of the original array. Multiple  where[...]  will simply be combined.   Function Specification  Note that a function ( t' ->nullable array) is expressed by some  expression  with variable names with underscores. The  expression  is converted into `t''-> expression . Symbols with underscores are converted in the following way:   _k  : translates to  t'[k] . The field name  k  should be a symbol.  _!k  : translates to  isna(t')[k] . It gives a boolean array to denote whether an element is null. The field name  k  should be a symbol.  _  : translates to  t'  if none of the above is applicable. It is useful when the field name is not a symbol.   Return  An updated array of the same type as  t .  Examples  julia> t = @larr(a=1:10, b=[1,2,3,NA,NA,NA,1,1,2,3], c=[:x,:x,:x,:x,:y,:y,:y,:z,:z,:z])\n10 LabeledArray\n\n   |a  b c \n---+-------\n1  |1  1 x \n2  |2  2 x \n3  |3  3 x \n4  |4    x \n5  |5    y \n6  |6    y \n7  |7  1 y \n8  |8  1 z \n9  |9  2 z \n10 |10 3 z \n\n\njulia> @update(t, a=_a .+ 100, d=_a .* _b)\n10 LabeledArray\n\n   |a   b c d  \n---+-----------\n1  |101 1 x 1  \n2  |102 2 x 4  \n3  |103 3 x 9  \n4  |104   x    \n5  |105   y    \n6  |106   y    \n7  |107 1 y 7  \n8  |108 1 z 8  \n9  |109 2 z 18 \n10 |110 3 z 30 \n\n\njulia> @update(t, a=_a .+ 100, d=_a .* _b, where[~isna(_b)])\n10 LabeledArray\n\n   |a   b c d  \n---+-----------\n1  |101 1 x 1  \n2  |102 2 x 4  \n3  |103 3 x 9  \n4  |4     x    \n5  |5     y    \n6  |6     y    \n7  |107 1 y 7  \n8  |108 1 z 8  \n9  |109 2 z 18 \n10 |110 3 z 30 \n\n\njulia> @update(t, a=sum(_a), d=reverse(_a .* _b), where[~isna(_b)], by[:b])\n10 LabeledArray\n\n   |a  b c d  \n---+----------\n1  |16 1 x 8  \n2  |11 2 x 18 \n3  |13 3 x 30 \n4  |4    x    \n5  |5    y    \n6  |6    y    \n7  |16 1 y 7  \n8  |16 1 z 1  \n9  |11 2 z 4  \n10 |13 3 z 9    source:  MultidimensionalTables/src/util/select.jl:943",
            "title": "Exported"
        },
        {
            "location": "/api/#internal",
            "text": "MultidimensionalTables.create_dict  \u00b6  create_dict(::LabeledArray)  Create a nested  Dict  from a  LabeledArray .  Examples  julia> t = larr(a=[1 2;3 4], axis1=[:x,:y], axis2=[\"A\",\"B\"])\n2 x 2 LabeledArray\n\n  |  |A B \n--+--+----\nx |a |1 2 \n--+--+----\ny |a |3 4 \n\n\njulia> create_dict(t)\nDict{Nullable{Symbol},Dict{Nullable{ASCIIString},MultidimensionalTables.LDict{Symbol,Nullable{Int64}}}} with 2 entries:\n  Nullable(:y) => Dict(Nullable(\"B\")=>MultidimensionalTables.LDict(:a=>Nullable(4)),Nullable(\"A\")=>MultidimensionalTables.LDict(:a=>Nullable(3)))\n  Nullable(:x) => Dict(Nullable(\"B\")=>MultidimensionalTables.LDict(:a=>Nullable(2)),Nullable(\"A\")=>MultidimensionalTables.LDict(:a=>Nullable(1)))  source:  MultidimensionalTables/src/datatypes/labeled_array.jl:1063    MultidimensionalTables.gdrop  \u00b6  gdrop(arr, N1, N2, ...)  Drop a block of an array. similar to  drop  in one dimensional case, but is slightly different and more general.\nIt can also be applied to an  LDict .\nIt drops the first  N1  elements along direction 1, and similarly for other directions. Drops from rear if  N*  is negative.  Examples  julia> t = larr(a=rand(5,3), b=reshape(1:15,5,3), axis1=[:X,:Y,:Z,:U,:V])\n5 x 3 LabeledArray\n\n  |1                     |2                      |3                      \n--+----------------------+-----------------------+-----------------------\n  |a                   b |a                   b  |a                   b  \n--+----------------------+-----------------------+-----------------------\nX |0.27289790581491746 1 |0.8493197848353495  6  |0.8370920536703472  11 \nY |0.8424940964507834  2 |0.21518951524950136 7  |0.9290437789813346  12 \nZ |0.9498541774517255  3 |0.942687447396005   8  |0.1341678643795654  13 \nU |0.7356663426240728  4 |0.7662948222160162  9  |0.24109069576951692 14 \nV |0.8716491751450759  5 |0.27472373001295436 10 |0.08909928028262804 15 \n\n\njulia> gdrop(t, 3, 2)\n2 x 1 LabeledArray\n\n  |1                      \n--+-----------------------\n  |a                   b  \n--+-----------------------\nU |0.24109069576951692 14 \nV |0.08909928028262804 15 \n\n\njulia> gdrop(t, 5)\n0 x 3 LabeledArray\n\n |1   |2   |3   \n-+----+----+----\n |a b |a b |a b \n\n\njulia> gdrop(t, -3, -2)\n2 x 1 LabeledArray\n\n  |1                     \n--+----------------------\n  |a                   b \n--+----------------------\nX |0.27289790581491746 1 \nY |0.8424940964507834  2   source:  MultidimensionalTables/src/util/array_util.jl:1516    MultidimensionalTables.gtake  \u00b6  gtake(arr, N1, N2, ...)  Take a block of an array. similar to  take  in one dimensional case, but is slightly different and more general.\nIt can also be applied to an  LDict .\nIt takes first  N1  elements along direction 1, and similarly for other directions. Repeats if the number of elements are less than  N* . Picks from rear if  N*  is negative.  Examples  julia> t = larr(a=rand(5,3), b=reshape(1:15,5,3), axis1=[:X,:Y,:Z,:U,:V])\n5 x 3 LabeledArray\n\n  |1                     |2                      |3                      \n--+----------------------+-----------------------+-----------------------\n  |a                   b |a                   b  |a                   b  \n--+----------------------+-----------------------+-----------------------\nX |0.3219487839233375  1 |0.4863723989946185  6  |0.8784616074632225  11 \nY |0.04069063166302023 2 |0.06614308437642014 7  |0.31870618693881947 12 \nZ |0.7855545407740521  3 |0.5208010912357377  8  |0.4421485355996708  13 \nU |0.8134241459627629  4 |0.8256022894268482  9  |0.3127049127123851  14 \nV |0.8536688845922342  5 |0.7263660648355621  10 |0.9315379228053462  15 \n\n\njulia> gtake(t, 3, 2)\n3 x 2 LabeledArray\n\n  |1                     |2                     \n--+----------------------+----------------------\n  |a                   b |a                   b \n--+----------------------+----------------------\nX |0.3219487839233375  1 |0.4863723989946185  6 \nY |0.04069063166302023 2 |0.06614308437642014 7 \nZ |0.7855545407740521  3 |0.5208010912357377  8 \n\n\njulia> gtake(t, 3, 4)\n3 x 4 LabeledArray\n\n  |1                     |2                     |3                      |4                     \n--+----------------------+----------------------+-----------------------+----------------------\n  |a                   b |a                   b |a                   b  |a                   b \n--+----------------------+----------------------+-----------------------+----------------------\nX |0.3219487839233375  1 |0.4863723989946185  6 |0.8784616074632225  11 |0.3219487839233375  1 \nY |0.04069063166302023 2 |0.06614308437642014 7 |0.31870618693881947 12 |0.04069063166302023 2 \nZ |0.7855545407740521  3 |0.5208010912357377  8 |0.4421485355996708  13 |0.7855545407740521  3 \n\n\njulia> gtake(t, -2, -1)\n2 x 1 LabeledArray\n\n  |1                     \n--+----------------------\n  |a                  b  \n--+----------------------\nU |0.3127049127123851 14 \nV |0.9315379228053462 15   source:  MultidimensionalTables/src/util/array_util.jl:1303    MultidimensionalTables.selectfield  \u00b6  selectfield(t, fld, inds)  : select a field whose name is  fld  at cartesian coordinates  inds  in a LabeledArray  t .\nIf  inds  is  nothing , it chooses an entire  fld  from  t .  source:  MultidimensionalTables/src/util/select.jl:502    MultidimensionalTables.setna!  \u00b6  setna!(arr, args...)  Set the element of an array  arr  at  args  to  NA .\nIf  args...  is omitted, all elements are set to  NA .   If  arr  is an array of element type  Nullable{T} ,  NA  means  Nullable{T}() .  If  arr  is a  DictArray ,  NA  means all fields at that position are  NA .  If  arr  is a  LabeledArray ,  NA  means the base of  arr  at that position is  NA .   Examples  julia> setna!(@nalift([1,2,NA,4,5]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable{Int64}()\n Nullable{Int64}()\n Nullable{Int64}()\n Nullable{Int64}()\n Nullable{Int64}()\n\njulia> setna!(@nalift([1,2,NA,4,5]), 2)\n5-element Array{Nullable{Int64},1}:\n Nullable(1)      \n Nullable{Int64}()\n Nullable{Int64}()\n Nullable(4)      \n Nullable(5)      \n\njulia> setna!(@darr(a=[1 2 NA;4 5 6], b=[:x :y :z;:u :v :w]), 1:2, 1)\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n    |2 y |  z \n    |5 v |6 w \n\n\njulia> setna!(larr(a=[1 2 3;4 5 6], b=[:x :y :z;:u :v :w], axis1=[:X,:Y]), 1, 2:3)\n2 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nX |1 x |    |    \nY |4 u |5 v |6 w   source:  MultidimensionalTables/src/na/na.jl:414    MultidimensionalTables.type_array  \u00b6  type_array(arr)  type_array  finds the most constraining type of the elements of an array  arr , and converts the array element type.\nSometimes, an array is given type  Array{Any} , even though the components are all Float64, for example. type_array  will convert the type into the most constraining one.  Arguments   arr::AbstractArray : an abstract array whose element type will be constrained by  type_array .   Returns  An array with the same elements as in  arr , but the element type has been constrained just enough to contain all elements.  Examples  julia> type_array(Any[1, 3.0, 2])\n3-element Array{Float64,1}:\n 1.0\n 3.0\n 2.0\n\njulia> type_array(Any[1, 3.0, 'x'])\n3-element Array{Any,1}:\n 1   \n 3.0 \n  'x'  source:  MultidimensionalTables/src/util/array_util.jl:34    diff  \u00b6  diff(arr, dims... [; rev=false])  for  arr  of type  AbstractArrayWrapper / LabeledArray / DictArray .  Take the difference between adjacent elements of  arr  along the directions belonging to the integers  dims .\nNote that  diff  applied to  AbstractArrayWrapper  (or to  LabeledArray  or  DictArray  by extension) will have the same shape as the original array. The first elements will be the first elements of the input array. This will ensure cumsum(diff(arr)) == diff(cumsum(arr)) == arr if there is no  Nullable  element.  Arguments   arr :  AbstractArrayWrapper / LabeledArray / DictArray , the input array. When applied to  DictArray ,  diff  is applied to each field. When applied to  LabeledArray ,  diff  is applied to the base.  dims : by default  dims=(1,) . That is, difference is calculated along the first direction. If  dims=(n1, n2,...) , for each slice spanned along the directions  n1 ,  n2 , ..., difference is taken along the leading dimension in  dims  first (i.e.  sum(dims) ), and then the next dimension, and so on.  rev : If  rev=true , difference is taken backward starting for the last elements. By default,  rev=false .   Examples  julia> diff(@nalift([10,NA,12,14,17]))\n5-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(10)     \n Nullable{Int64}()\n Nullable{Int64}()\n Nullable(2)      \n Nullable(3)      \n\njulia> diff(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2)\n2 x 3 DictArray\n\na  b  |a  b  |a  b  \n------+------+------\n11 10 |-2 2  |-2 2  \n3  -3 |3  -3 |3  -3 \n\n\njulia> diff(darr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2, rev=true)\n2 x 3 DictArray\n\na  b  |a  b  |a  b \n------+------+-----\n-3 3  |-3 3  |-3 3 \n2  -2 |2  -2 |16 5 \n\n\njulia> diff(larr(a=[11 12 13;14 15 16], b=[10 9 8;7 6 5]), 1, 2, rev=true)\n2 x 3 LabeledArray\n\n  |1     |2     |3    \n--+------+------+-----\n  |a  b  |a  b  |a  b \n--+------+------+-----\n1 |-3 3  |-3 3  |-3 3 \n2 |2  -2 |2  -2 |16 5   source:  MultidimensionalTables/src/util/array_helper_functions.jl:574    allfieldnames(arr::MultidimensionalTables.DictArray{K, N, VS, SV})  \u00b6  allfieldnames(::DictArray)  Return all field names in the input  DictArray , which are just the keys in the underlying  LDict .  Examples  julia> allfieldnames(darr(a=reshape(1:6,3,2),b=rand(3,2)))\n2-element Array{Symbol,1}:\n :a\n :b  source:  MultidimensionalTables/src/datatypes/dict_array.jl:535    allfieldnames(table::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN})  \u00b6  returns all field names for LabeledArray or DictArray. Returns an empty array for other types of arrays.  source:  MultidimensionalTables/src/datatypes/labeled_array.jl:754    cat(catdim::Integer,  arr1::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  arrs::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN}...)  \u00b6  cat(catdim::Integer, arrs::LabeledArray...)  Concatenate  LabeledArray s  arrs  along the  catdim  direction.\nThe base of each element of  arrs  are concatenated and become the new base of the return  LabeledArray .\nThe axes of each of  arrs  not along the  catdim  direction should be identical. Otherwise, there will be an error.\nThe axis along the  catdim  direction will be the concatenation of the axis of each of  arrs  along that direction.  julia> t1 = larr(a=[1 2 3;4 5 6], axis1=[:x,:y], axis2=[\"A\",\"B\",\"C\"])\nt2 x 3 LabeledArray\n\n  |  |A B C \n--+--+------\nx |a |1 2 3 \n--+--+------\ny |a |4 5 6 \n\n\njulia> t2 = larr(a=[11 12 13;14 15 16], axis1=[:x,:y], axis2=[\"D\",\"E\",\"F\"])\n2 x 3 LabeledArray\n\n  |  |D  E  F  \n--+--+---------\nx |a |11 12 13 \n--+--+---------\ny |a |14 15 16 \n\n\njulia> cat(2, t1, t2)\n2 x 6 LabeledArray\n\n  |  |A B C D  E  F  \n--+--+---------------\nx |a |1 2 3 11 12 13 \n--+--+---------------\ny |a |4 5 6 14 15 16   source:  MultidimensionalTables/src/datatypes/labeled_array.jl:804    cat(catdim::Integer,  arrs::MultidimensionalTables.DictArray{K, N, VS, SV}...)  \u00b6  cat(catdim::Integer, arrs::DictArray...)  Concatenate the  DictArray s  arrs  along the  catdim  direction.\nThe common fields are concatenated field by field.\nIf a field name does not exist in all of  arrs , a null field with that field name will be added to those  DictArray s with that missing field name, and then the arrays will be concatenated field by field.  Examples  julia> cat(1, darr(a=[1 2 3], b=[:x :y :z]),\n              darr(c=[3 2 1], b=[:m :n :p]))\n2 x 3 DictArray\n\na b c |a b c |a b c \n------+------+------\n1 x   |2 y   |3 z   \n  m 3 |  n 2 |  p 1 \n\njulia> cat(2, darr(a=[1 2 3], b=[:x :y :z]),\n              darr(c=[3 2 1], b=[:m :n :p]))\n1 x 6 DictArray\n\na b c |a b c |a b c |a b c |a b c |a b c \n------+------+------+------+------+------\n1 x   |2 y   |3 z   |  m 3 |  n 2 |  p 1   source:  MultidimensionalTables/src/datatypes/dict_array.jl:613    convert(::Type{DataFrames.DataFrame},  arr::MultidimensionalTables.DictArray{K, N, VS, SV})  \u00b6  convert(::Type{DataFrame}, arr::DictArray)  converts a  DictArray  into a  DataFrame . If the dimensions of  arr  are greater than 1,  arr  is first flattend into 1 dimension using  collapse_axes , and then converted into a  DataFrame .  source:  MultidimensionalTables/src/util/dataframe_interface.jl:96    convert(::Type{DataFrames.DataFrame},  arr::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN})  \u00b6  convert(::Type{DataFrame}, arr::LabeledArray)  converts a  LabeledArray  into a  DataFrame  by first creating a  DictArray  by broadcasting all axes, and then convert that  DictArray  into a  DataFrame .  source:  MultidimensionalTables/src/util/dataframe_interface.jl:102    convert(::Type{MultidimensionalTables.DictArray{K, N, VS, SV}},  df::DataFrames.DataFrame)  \u00b6  convert(::Type{DictArray}, df::DataFrame)  converts a  DataFrame  into  DictArray .  source:  MultidimensionalTables/src/util/dataframe_interface.jl:84    convert(::Type{MultidimensionalTables.EnumerationArray{T, N, V, R<:Integer}},  arr::DataArrays.PooledDataArray{T, R<:Integer, N})  \u00b6  convert(::Type{EnumerationArray}, arr::PooledDataArray)  converts a  PooledDataArray  into an  EnumerationArray .  source:  MultidimensionalTables/src/util/dataframe_interface.jl:108    convert(::Type{MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN}},  df::DataFrames.DataFrame)  \u00b6  convert(::Type{LabeledArray}, df::DataFrame)  converts a  DataFrame  into  LabeledArray  simply by wrapping  convert(DictArray, df)  by  LabeledArray .  source:  MultidimensionalTables/src/util/dataframe_interface.jl:90    deletekeys{K, V}(dict::MultidimensionalTables.LDict{K, V},  keys...)  \u00b6  deletekeys(dict::LDict, keys...)  Delete  keys  keys from  dict . A missing key will be silently ignored.  julia> deletekeys(LDict(:a=>3, :b=>5, :c=>10), :a, :b, :x)\nMultidimensionalTables.LDict{Symbol,Int64} with 1 entry:\n  :c => 10  source:  MultidimensionalTables/src/datatypes/ldict.jl:155    dropnaiter{T, N}(arr::AbstractArray{Nullable{T}, N})  \u00b6  dropnaiter(arr)  Generate an iterator from a nullable array  arr , which iterates over only non-null elements.  Examples  julia> for x in dropnaiter(@nalift([1,2,NA,4,5]))\n         println(x)\n       end\n1\n2\n4\n5  source:  MultidimensionalTables/src/util/array_helper_functions.jl:24    enum_dropnaiter{T, N}(arr::AbstractArray{Nullable{T}, N})  \u00b6  enum_dropnaiter(arr)  Generate an iterator from a nullable array  arr , which yields (index, elem) for an integer  index  for non-null element positions of  arr  and a non-null element  elem .  Examples  julia> for x in enum_dropnaiter(@nalift([:A,:B,NA,NA,:C]))\n         println(x)\n       end\n(1,:A)\n(2,:B)\n(5,:C)  source:  MultidimensionalTables/src/util/array_helper_functions.jl:44    fill(ldict::MultidimensionalTables.LDict{K, V},  dims::Integer...)  \u00b6  fill(ldict::LDict, dims...)  Fill a  DictArray  with  ldict .  Return  A new  DictArray  whose elements are  ldict  and whose dimensions are  dims... .  source:  MultidimensionalTables/src/datatypes/dict_array.jl:1141    flipdim(arr::MultidimensionalTables.DictArray{K, N, VS, SV},  dims::Integer...)  \u00b6  flipdim(arr::DictArray, dims...)  Flip a  DictArray   arr  using an iterable variable  dims . The same method as  reverse(arr::DictArray, dims) .  Arguments   arr  is an input  DictArray .  dims  is an iterable variable of  Int s.   Return  A  DictArray  whose elements along any directions belonging to  dims  are fliped.  Examples  julia> t = darr(a=[1 2 3;4 5 6], b=[:x :y :z;:u :v :w])\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n1 x |2 y |3 z \n4 u |5 v |6 w \n\n\njulia> flipdim(t, 1)\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n4 u |5 v |6 w \n1 x |2 y |3 z \n\n\njulia> flipdim(t, 1, 2)\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n6 w |5 v |4 u \n3 z |2 y |1 x   source:  MultidimensionalTables/src/datatypes/dict_array.jl:1129    getindexvalue(arr::AbstractArray{T, N},  args...)  \u00b6  getindexvalue(arr::AbstractArray, args...)  Return  arr[args...] .  source:  MultidimensionalTables/src/datatypes/dict_array.jl:190    getindexvalue(arr::MultidimensionalTables.DictArray{K, N, VS, SV},  args...)  \u00b6  getindexvalue(arr::DictArray, args...)  Return the value tuple of  arr  at index  args .  source:  MultidimensionalTables/src/datatypes/dict_array.jl:180    intersect(dim::Integer,  arr0::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  arr_rest::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN}...)  \u00b6  intersect(dim, arrs...)  Take intersection of arrays of type  LabeledArray / DictArray / AbstractArrayWrapper . The order is preserved.  Arguments   dim  : direction along which to intersect.  arrs...  : arrays to intersect.   Examples  julia> intersect(1, nalift([1 2 3;4 5 6]), nalift([1 2 3;5 5 6]))\n1x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)  Nullable(3)\n\njulia> intersect(2, nalift([1 2 3;4 5 6]), nalift([1 2 3;5 5 6]))\n2x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(2)  Nullable(3)\n Nullable(5)  Nullable(6)\n\njulia> intersect(1, darr(a=[:x,:y,:z]), darr(a=[:x,:x,:y]), darr(a=[:y,:y,:y]))\n1 DictArray\n\na \n--\ny \n\n\njulia> intersect(1, larr(a=[1 2 3;4 5 6], axis1=[:X,:Y]), larr(a=[1 2 3;4 3 2], axis1=[:X,:Y]))\n1 x 3 LabeledArray\n\n  |1 |2 |3 \n--+--+--+--\n  |a |a |a \n--+--+--+--\nX |1 |2 |3 \n\n\njulia> intersect(1, larr(a=[1 2 3;4 5 6], axis1=[:X,:Y]), larr(a=[1 2 3;4 3 2], axis1=[:Z,:Y]))\n0 x 3 LabeledArray\n\n |1 |2 |3 \n-+--+--+--\n |a |a |a   source:  MultidimensionalTables/src/util/intersect.jl:53    keys(arr::MultidimensionalTables.DictArray{K, N, VS, SV})  \u00b6  keys(::DictArray)  Return the field name vector of the input  DictArray , which are the keys of the underlying  LDict .  Examples  julia> keys(darr(a=[1,2,3], b=[:x,:y,:z]))\n2-element Array{Symbol,1}:\n :a\n :b  source:  MultidimensionalTables/src/datatypes/dict_array.jl:1001    map(f::Function,  arr::MultidimensionalTables.DictArray{K, N, VS, SV})  \u00b6  map(f::Function, arr::DictArray)  Apply the function  f  to each element of  arr . f  will take an  LDict  and produces a value of type, say  T .\nThe return value will have the same size as  arr  and its elements have type  T .\nIf the return element type  T  is not nullable, the result elements are wrapped by  Nullable .\nIf the return element type  T  is  LDict , the result will be again a  DictArray .\nHowever, in this case, the  LDict  should be of the type  LDict{K,Nullable{V}} .  Examples  julia> map(x->x[:a].value + x[:b].value, darr(a=[1 2;3 4], b=[1.0 2.0;3.0 4.0]))\n2x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Float64},2,MultidimensionalTables.FloatNAArray{Float64,2,Array{Float64,2}}}:\n Nullable(2.0)  Nullable(4.0)\n Nullable(6.0)  Nullable(8.0)\n\njulia> map(x->LDict(:c=>Nullable(x[:a].value + x[:b].value)), darr(a=[1 2;3 4], b=[1.0 2.0;3.0 4.0]))\n2 x 2 DictArray\n\nc   |c   \n----+----\n2.0 |4.0 \n6.0 |8.0   source:  MultidimensionalTables/src/datatypes/dict_array.jl:719    mapslices(f::Function,  arr::MultidimensionalTables.DictArray{K, N, VS, SV},  dims::AbstractArray{T, 1})  \u00b6  mapslices(f::Function, arr::DictArray, dims)  Apply the function  f  to each slice of  arr  specified by  dims .  dims  is a vector of integers along which direction to reduce.   If  dims  includes all dimensions,  f  will be applied to the whole  arr .  If  dims  is empty,  mapslices  is the same as  map .  Otherwise,  f  is applied to each slice spanned by the directions.   Return  Return a dimensionally reduced array along the directions in  dims .\nIf the return value of  f  is an  LDict , the return value of the corresponding  mapslices  is a  DictArray .\nOtherwise, the return value is an  Array .  julia> mapslices(d->d[:a] .* 2, darr(a=[1 2 3;4 5 6], b=[10 11 12;13 14 15]), [1])\n3-element MultidimensionalTables.AbstractArrayWrapper{Nullable{MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}}},1,Array{Nullable{MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}}},1}}:\n Nullable([Nullable(2),Nullable(8)]) \n Nullable([Nullable(4),Nullable(10)])\n Nullable([Nullable(6),Nullable(12)])\n\njulia> mapslices(d->d[:a] .* 2, darr(a=[1 2 3;4 5 6], b=[10 11 12;13 14 15]), [2])\n2-element MultidimensionalTables.AbstractArrayWrapper{Nullable{MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}}},1,Array{Nullable{MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}}},1}}:\n Nullable([Nullable(2),Nullable(4),Nullable(6)])  \n Nullable([Nullable(8),Nullable(10),Nullable(12)])\n\njulia> mapslices(d->LDict(:c=>sum(d[:a]), :d=>sum(d[:b] .* 3)), darr(a=[1 2 3;4 5 6], b=[10 11 12;13 14 15]), [2])\n2 DictArray\n\nc  d   \n-------\n6  99  \n15 126   source:  MultidimensionalTables/src/datatypes/dict_array.jl:797    merge(arr1::MultidimensionalTables.DictArray{K, N, VS, SV},  args...)  \u00b6  merge(::DictArray, args...)  Construct a  DictArray  using  args... , and merges the two  DictArray s together.  Example  julia> merge(darr(a=[1,2,3], b=[4,5,6]), b=[:x,:y,:z], :c=>[\"A\",\"B\",\"C\"])\n3 DictArray\n\na b c \n------\n1 x A \n2 y B \n3 z C   source:  MultidimensionalTables/src/datatypes/dict_array.jl:338    merge(arr1::MultidimensionalTables.DictArray{K, N, VS, SV},  arr2::MultidimensionalTables.DictArray{K, N, VS, SV})  \u00b6  merge(::DictArray, ::DictArray)  Merge the two  DictArray s. A duplicate field in the second  DictArray  will override that in the first one. Otherwise, the new field in the second  DictArray  will be appened after the first  DictArray  fields.\nIf the first is  DictArray  and the remaining arguments are used to construct a  DictArray  and then the two are merged.  Example  julia> merge(darr(a=[1,2,3], b=[4,5,6]), darr(b=[:x,:y,:z], c=[\"A\",\"B\",\"C\"]))\n3 DictArray\n\na b c \n------\n1 x A \n2 y B \n3 z C   source:  MultidimensionalTables/src/datatypes/dict_array.jl:317    merge(arr1::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  args::MultidimensionalTables.DictArray{K, N, VS, SV}...)  \u00b6  merge(::LabeledArray, ::DictArray...)  Merge the base of the  LabeledArray  and the rest  DictArray s.\nTogether with the axes set of the input  LabeledArray , return a new  LabeledArray .  Examples  julia> merge(larr(a=[1,2,3],b=[:x,:y,:z],axis1=[:a,:b,:c]),darr(c=[4,5,6],b=[:m,:n,:p]),darr(a=[\"X\",\"Y\",\"Z\"]))\n3 LabeledArray\n\n  |a b c \n--+------\na |X m 4 \nb |Y n 5 \nc |Z p 6   source:  MultidimensionalTables/src/datatypes/labeled_array.jl:1530    merge(arr1::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  arr2::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN})  \u00b6  merge(::LabeledArray, ::LabeledArray)  Merge two  LabeledArrays . The axes set of the two should be identical.\nThe bases are merged together and the common axes set is used.  Examples  julia> merge(larr(a=[1,2,3],b=[:x,:y,:z],axis1=[:a,:b,:c]),larr(c=[4,5,6],b=[:m,:n,:p],axis1=[:a,:b,:c]))\n3 LabeledArray\n\n  |a b c \n--+------\na |1 m 4 \nb |2 n 5 \nc |3 p 6   source:  MultidimensionalTables/src/datatypes/labeled_array.jl:1504    merge(dict::MultidimensionalTables.LDict{K, V},  ds::Associative{K, V}...)  \u00b6  merge(dict::LDict, ds...)  Combine an  LDict   dict  with  Associative   ds 's.\nThe subsequent elements in ds will either update the preceding one, or append the key-value pair.  Examples  julia> merge(LDict(:a=>3, :b=>5), Dict(:b=>\"X\", :c=>\"Y\"), LDict(:c=>'x', 'd'=>'y'))\nMultidimensionalTables.LDict{Any,Any} with 4 entries:\n  :a  => 3\n  :b  => \"X\"\n  :c  => 'x'\n  'd' => 'y'  source:  MultidimensionalTables/src/datatypes/ldict.jl:98    reducedim(f::Function,  arr::MultidimensionalTables.DictArray{K, N, VS, SV},  dims,  initial)  \u00b6  reducedim(f::Function, arr::DictArray, dims [, initial])  Reduce a two argument function  f  along dimensions of  arr .  dims  is a vector specifying the dimensions to reduce, and  initial  is the initial value to use in the reduction.\n* If  dims  includes all dimensions,  reduce  will be applied to the whole  arr  with initial value  initial.\n* Otherwise, reduce is applied with the function f to each slice spanned by the directions with initial value initial . initial can be omitted if the underlying reduce` does not require it.  julia> reducedim((acc,d)->acc+d[:a].value, darr(a=[1 2 3;4 5 6]), [1], 0)\n3-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(5)\n Nullable(7)\n Nullable(9)\n\njulia> reducedim((acc,d)->acc+d[:a].value, darr(a=[1 2 3;4 5 6]), [2], 0)\n2-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable(6) \n Nullable(15)\n\njulia> reducedim((acc,d)->acc+d[:a].value, darr(a=[1 2 3;4 5 6]), [1,2], 0)\nNullable(21)  source:  MultidimensionalTables/src/datatypes/dict_array.jl:747    repeat(arr::MultidimensionalTables.DictArray{K, N, VS, SV})  \u00b6  repeat(arr::DictArray [; inner=..., outer=...])  Apply  repeat  field by field to the  DictArray   arr .  source:  MultidimensionalTables/src/datatypes/dict_array.jl:640    replace_expr(expr)  \u00b6  replace_expr(expr)  Create a function expression from a domain expression.  Expressions  Below t' is an object such that t'[k] for a field name k gives the corresponding array\nfor the field k in the table t at the coordinates selected so far.   _k  : translates to  t'[k] . The field name  k  should be a symbol.  __k  : translates to  igna(t')[k] . It ignores the null elements. The null elements are replaced with arbitrary values, so make sure there is no null value in the array if you want to use it. The field name  k  should be a symbol.  _!k  : translates to  isna(t')[k] . It gives a boolean array to denote whether an element is null. The field name  k  should be a symbol.  _  : translates to  t'  if none of the above is applicable. It is useful when the field name is not a symbol.   source:  MultidimensionalTables/src/util/select.jl:1118    reshape(arr::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  dims::Int64...)  \u00b6  reshape(arr::LabeledArray, dims...)  Reshape  arr  into different sizes, if there is no ambiguity.\nThis means you can collapse several contiguous directions into one direction,\nin which case all axes belonging to collapsing direction will be concatenated.\nFor other case, sometimes it is possible to disambiguate the axis position.\nBut in general, the result is either an error or an undetermined result\nas long as the axis positions are concerned.  Examples  julia> t = larr(a=[1 2 3;4 5 6], axis1=[:x,:y], axis2=[\"A\",\"B\",\"C\"])\n2 x 3 LabeledArray\n\n  |A |B |C \n--+--+--+--\n  |a |a |a \n--+--+--+--\nx |1 |2 |3 \ny |4 |5 |6 \n\n\n1 x 6 LabeledArray\n\nx1 |x |y |x |y |x |y \nx2 |A |A |B |B |C |C \n---+--+--+--+--+--+--\n   |a |a |a |a |a |a \n---+--+--+--+--+--+--\n1  |1 |4 |2 |5 |3 |6 \n\n\njulia> reshape(t, 6, 1)\n6 x 1 LabeledArray\n\n      |1 \n------+--\nx1 x2 |a \n------+--\nx  A  |1 \ny  A  |4 \nx  B  |2 \ny  B  |5 \nx  C  |3 \ny  C  |6 \n\n\njulia> reshape(t, 6)\n6 LabeledArray\n\nx1 x2 |a \n------+--\nx  A  |1 \ny  A  |4 \nx  B  |2 \ny  B  |5 \nx  C  |3 \ny  C  |6 \n\n\njulia> reshape(t, 3,2)\nERROR: ArgumentError: dims (3,2) are inconsistent.  source:  MultidimensionalTables/src/datatypes/labeled_array.jl:1177    reverse(arr::MultidimensionalTables.DictArray{K, N, VS, SV},  dims)  \u00b6  reverse(arr::DictArray, dims)  Reverse a  DictArray   arr  using an iterable variable  dims .  Arguments   arr  is an input  DictArray .  dims  is an iterable variable of  Int s.   Return  A  DictArray  whose elements along any directions belonging to  dims  are reversed.  Examples  julia> t = darr(a=[1 2 3;4 5 6], b=[:x :y :z;:u :v :w])\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n1 x |2 y |3 z \n4 u |5 v |6 w \n\n\njulia> reverse(t, [1])\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n4 u |5 v |6 w \n1 x |2 y |3 z \n\n\njulia> reverse(t, 1:2)\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n6 w |5 v |4 u \n3 z |2 y |1 x   source:  MultidimensionalTables/src/datatypes/dict_array.jl:1072    sel(func,  t)  \u00b6  sel(func, t [; c=[], b=[], a=[]])  an intermediate  select / update  function to connect  selectfunc / updatefunc  and  @select ( selct )/ @update ( update ).  Arguments  Below  t'  is an object such that  t'[k]  for a field name  k  gives the corresponding array\nfor the field  k  in the table  t  at the coordinates selected so far.   func  : selectfunc or updatefunc.   t  : a LabeledArray.   c  : an array of conditions of type  t'  -> nullable boolean array.   b  : an array of arrays of pairs from field names to by functions specified as  t'  -> a nullable array.\n*  a  : an array of pairs from field names to aggregate functions specified as  t'  -> a nullable array.  source:  MultidimensionalTables/src/util/select.jl:597    selectfunc{N}(t::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  c,  b,  a)  \u00b6  selectfunc(t::LabeledArray, c, b, a)  main select function. This function is internal and is meant to be used via  selct . selectfunc  takes a table  t , condition  c , aggreagtion by rule  b , aggregate function  a .   t : a LabeledArray  c : an array of functions  (t, inds)  -> boolean array.  t  is a LabeledArray and inds is either  nothing  to choose the entire  t  or an array of Cartesian indices.  b : an array of arrays of pairs of field name => function  (t, inds)  -> array.  t  is a LabeledArray and inds is either  nothing  to choose the entire  t  or an array of Cartesian indices.  c : an array of pairs of field name => function  (t, inds)  -> array.  t  is a LabeledArray and inds is either  nothing  to choose the entire  t  or an array of Cartesian indices.   source:  MultidimensionalTables/src/util/select.jl:34    selectkeys{K, V}(dict::MultidimensionalTables.LDict{K, V},  keys...)  \u00b6  selectkeys(dict::LDict, keys...)  Select  keys  keys from  dict . A missing key will raise an error.  Examples  julia> selectkeys(LDict(:a=>3, :b=>5, :c=>10), :a, :b)\nMultidimensionalTables.LDict{Symbol,Int64} with 2 entries:\n  :a => 3\n  :b => 5  source:  MultidimensionalTables/src/datatypes/ldict.jl:186    show{N}(io::IO,  arr::MultidimensionalTables.DictArray{K, N, VS, SV})  \u00b6  show(io::IO, arr::DictArray [; height::Int=..., width::Int=..., alongorow::Bool=true])  Show a  DictArray  in  io  in a square box of given  height  and  width . If not provided, the current terminal's size is used to get the default  height  and  weight .  alongrow  determines whether to display field names along row or columns.  Examples  julia> show(STDOUT, darr(a=[1,2,3], b=[:x,:y,:z]))\n3 DictArray\n\na b \n----\n1 x \n2 y \n3 z \n\njulia> show(STDOUT, darr(a=[1,2,3], b=[:x,:y,:z]), alongrow=false)\n3 DictArray\n\na |1 \nb |x \n--+--\na |2 \nb |y \n--+--\na |3 \nb |z   source:  MultidimensionalTables/src/datatypes/dict_array.jl:376    show{N}(io::IO,  arr::MultidimensionalTables.DictArray{K, N, VS, SV},  indent)  \u00b6  show(io::IO, arr::DictArray [; height::Int=..., width::Int=..., alongorow::Bool=true])  Show a  DictArray  in  io  in a square box of given  height  and  width . If not provided, the current terminal's size is used to get the default  height  and  weight .  alongrow  determines whether to display field names along row or columns.  Examples  julia> show(STDOUT, darr(a=[1,2,3], b=[:x,:y,:z]))\n3 DictArray\n\na b \n----\n1 x \n2 y \n3 z \n\njulia> show(STDOUT, darr(a=[1,2,3], b=[:x,:y,:z]), alongrow=false)\n3 DictArray\n\na |1 \nb |x \n--+--\na |2 \nb |y \n--+--\na |3 \nb |z   source:  MultidimensionalTables/src/datatypes/dict_array.jl:376    show{N}(io::IO,  table::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN})  \u00b6  show(io::IO, table::LabeledArray [, indent=0; height=..., width=...])  Show a LabeledArray.  Arguments   height  and  width (optional, default set by show_size()): sets the maximum height and width to draw, beyond which the table will be cut.  alongrow (optional, default set by  set_dispalongrow!! .  tru  by default): if  true , the fields in the array will be displayed along the row in each cell. Otherwise, they will be stacked on top of each other.   source:  MultidimensionalTables/src/datatypes/labeled_array.jl:244    show{N}(io::IO,  table::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  indent)  \u00b6  show(io::IO, table::LabeledArray [, indent=0; height=..., width=...])  Show a LabeledArray.  Arguments   height  and  width (optional, default set by show_size()): sets the maximum height and width to draw, beyond which the table will be cut.  alongrow (optional, default set by  set_dispalongrow!! .  tru  by default): if  true , the fields in the array will be displayed along the row in each cell. Otherwise, they will be stacked on top of each other.   source:  MultidimensionalTables/src/datatypes/labeled_array.jl:244    sort(arr::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  axis::Integer,  fields...)  \u00b6  sort(arr, axis fields... [; alg=..., ...])  Sort a  DictArray  or  LabeledArray  along some axis.  Arguments   arr  : either a  DictArray  or a  LabeledArray .  axis  : an axis direction integer to denote which direction to sort along.  fields...  : the names of fields to determine the order. The preceding ones have precedence over the later ones. Note only the components [1,...,1,:,1,...1], where : is placed at the axis position, will be used out of each field.  optionally,  alg=algorithm  determines the sorting algorithm.  fieldname_lt=ltfunc  sets the less-than function for the field fieldname, and similarly for  by / rev / ord .   Examples  julia> t = larr(a=[3 3 2;7 5 3], b=[:b :a :c;:d :e :f], axis1=[\"X\",\"Y\"])\n2 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nX |3 b |3 a |2 c \nY |7 d |5 e |3 f \n\n\njulia> sort(t, 1, :a)\n2 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nX |3 b |3 a |2 c \nY |7 d |5 e |3 f \n\n\njulia> sort(t, 2, :a)\n2 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nX |2 c |3 b |3 a \nY |3 f |7 d |5 e \n\n\njulia> sort(t, 2, :a, :b)\n2 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nX |2 c |3 a |3 b \nY |3 f |5 e |7 d \n\n\njulia> sort(t, 2, :a, :b, a_rev=true)\n2 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nX |3 a |3 b |2 c \nY |5 e |7 d |3 f   source:  MultidimensionalTables/src/util/sort.jl:132    unique{T}(arr::MultidimensionalTables.AbstractArrayWrapper{Nullable{T}, N, A<:AbstractArray{T, N}})  \u00b6  unique(arr, dims...)  Return unique elements of an array  arr  of type  LabeledArray / DictArray / Nullable AbstractArrayWrapper .  Arguments   arr  : an array  dims...  : either an integer or, if an array is a DictArray or a LabeledArray, a list of integers. It specifies the directions along which to traverse. Any duplicate elements will be replaced by Nullable{T}(). If all components along some direction are missing, those components will be removed and the whole array size will shrink.\nIf  dims...  is missing, unique elements along the whole directions will be found. It is equivalent to  unique(arr, 1, 2, ..., ndims(arr)) .\nNote that it compares each slice spanned by directions orthogonal to  dims... .   Examples  julia> unique(nalift([1 2 3;3 4 1]))\n2x2 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)\n Nullable(3)  Nullable(4)\n\njulia> unique(nalift([1 2 3;3 4 1]), 1)\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)  Nullable(3)\n Nullable(3)  Nullable(4)  Nullable(1)\n\njulia> unique(nalift([1 2 3;3 4 1]), 2)\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)  Nullable(3)\n Nullable(3)  Nullable(4)  Nullable(1)\n\njulia> unique(nalift([1 2 3;1 2 3;4 5 6]), 1)\n2x3 MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},2,Array{Nullable{Int64},2}}:\n Nullable(1)  Nullable(2)  Nullable(3)\n Nullable(4)  Nullable(5)  Nullable(6)\n\njulia> t = darr(a=[1 2 1;1 5 1;1 2 1], b=[:a :b :a;:a :c :a;:a :b :a])\n3 x 3 DictArray\n\na b |a b |a b \n----+----+----\n1 a |2 b |1 a \n1 a |5 c |1 a \n1 a |2 b |1 a \n\n\njulia> unique(t, 1)\n2 x 3 DictArray\n\na b |a b |a b \n----+----+----\n1 a |2 b |1 a \n1 a |5 c |1 a \n\n\njulia> unique(t, 2)\n3 x 2 DictArray\n\na b |a b \n----+----\n1 a |2 b \n1 a |5 c \n1 a |2 b \n\n\njulia> m = larr(a=[1 2 1;1 5 1;1 2 1], b=[:a :b :a;:a :c :a;:a :b :a], axis1=[\"X\",\"Y\",\"Z\"])\n3 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nX |1 a |2 b |1 a \nY |1 a |5 c |1 a \nZ |1 a |2 b |1 a \n\n\njulia> unique(m, 1)\n2 x 3 LabeledArray\n\n  |1   |2   |3   \n--+----+----+----\n  |a b |a b |a b \n--+----+----+----\nX |1 a |2 b |1 a \nY |1 a |5 c |1 a \n\n\njulia> unique(m, 2)\n3 x 2 LabeledArray\n\n  |1   |2   \n--+----+----\n  |a b |a b \n--+----+----\nX |1 a |2 b \nY |1 a |5 c \nZ |1 a |2 b   source:  MultidimensionalTables/src/util/unique.jl:102    updatefunc{N}(t::MultidimensionalTables.LabeledArray{T, N, AXES<:Tuple, TN},  c,  b,  a)  \u00b6  updatefunc(t::LabeledArray, c, b, a)  main update function. This function is internal and is meant to be used via  update . updatefunc  takes a table  t , condition  c , aggreagtion by rule  b , aggregate function  a .   t  : a LabeledArray  c  : an array of functions  (t, inds)  -> boolean array.  t  is a LabeledArray and inds is either  nothing  to choose the entire  t  or an array of Cartesian indices.  b  : an array of arrays of pairs of field name => function  (t, inds)  -> array.  t  is a LabeledArray and inds is either  nothing  to choose the entire  t  or an array of Cartesian indices.  c  : an array of pairs of field name => function  (t, inds)  -> array.  t  is a LabeledArray and inds is either  nothing  to choose the entire  t  or an array of Cartesian indices.   source:  MultidimensionalTables/src/util/select.jl:111    values(arr::MultidimensionalTables.DictArray{K, N, VS, SV})  \u00b6  values(::DictArray)  Return the vector of field arrays of the input  DictArray , which are the values of the underlying  LDict .  Examples  julia> values(darr(a=[1,2,3], b=[:x,:y,:z]))\n2-element Array{MultidimensionalTables.AbstractArrayWrapper{T,1,A<:AbstractArray{T,N}},1}:\n [Nullable(1),Nullable(2),Nullable(3)]   \n [Nullable(:x),Nullable(:y),Nullable(:z)]  source:  MultidimensionalTables/src/datatypes/dict_array.jl:1019    wrap_array(arr::MultidimensionalTables.AbstractArrayWrapper{T, N, A<:AbstractArray{T, N}})  \u00b6  wrap_array(arr)  Wrap an array by  AbstractArrayWrapper  if it is not  DictArray  or  labeledArray , and not already  AbstractArrayWrapper .  source:  MultidimensionalTables/src/na/naarray_operators.jl:11    zip_dropnaiter{N}(arrs::MultidimensionalTables.AbstractArrayWrapper{T, N, A<:AbstractArray{T, N}}...)  \u00b6  zip_dropnaiter(arrs...)  Generate a zipped iterator from nullable arrays  arrs... . If any element in  arrs...  is null, the iterator will skip it and move to the next element tuple.  Examples  julia> for x in zip_dropnaiter(@nalift([11,12,NA,NA,15]),\n                               @nalift([:X,NA,:Z,NA,:V]),\n                               @nalift([71,72,73,NA,75]))\n         println(x)\n       end\n(11,:X,71)\n(15,:V,75)  source:  MultidimensionalTables/src/util/array_helper_functions.jl:132    MultidimensionalTables.AbstractArrayWrapper{T, N, A<:AbstractArray{T, N}}  \u00b6  A thin wrapper around AbstractArray. The reason to introduce this wrapper is to redefine\nthe dotted operators such as .+, .-. Those operators will be mapped to arrays, elementwise just as before,\nbut, if each element is null, those operators will be applied to the one inside the Nullable.\nFor example,  julia> AbstractArrayWrapper([Nullable(1), Nullable(2)]) .+ AbstractArrayWrapper([Nullable{Int}(), Nullable(3)])\n2-element MultidimensionalTables.AbstractArrayWrapper{Nullable{Int64},1,Array{Nullable{Int64},1}}:\n Nullable{Int64}()\n Nullable(5)        Note that this means lifting those dotted operators via the list(AbstractArray) and maybe(Nullable) functors.  It is possible to redefine those operators for AbstractArray, but concerning about compatibility, it may be\nbest to introduce a new wrapper class for that.  source:  MultidimensionalTables/src/na/na.jl:25    MultidimensionalTables.DefaultAxis  \u00b6  Default axis used when no axis is specified for a  LabeledArray .\nIt behaves mostly as an array  [Nullable(1), Nullable(2), ...] .\nHowever, one notable exception is when using  @select / selct / extract / discard / getindex /etc to choose, set or drop specific elements of a  LabeledArray .\nIn this case, the result array of reduced size will again have a  DefaultAxis  of an appropriate size.  source:  MultidimensionalTables/src/datatypes/labeled_array.jl:47",
            "title": "Internal"
        }
    ]
}